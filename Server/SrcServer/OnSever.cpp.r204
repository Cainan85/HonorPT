#define _WIN32_WINNT    0x0400  /* Get new material from the headers */
#define _WIN32_WINDOWS  0x040a

#include <windows.h>
#include <io.h>
#include <stdio.h>         /* for sprintf                           */
#include <string.h>        /* for strlen                            */
#include <memory.h>
#include <process.h>       /* for _beginthread                      */
//#include <winsock2.h>
//#include <mswsock.h>

#include "..\\resource.h"
#include "..\\smwsock.h"

//#include "..\\smPacket.h"

#include "..\\smlib3d\\smd3d.h"
#include "..\\character.h"
#include "..\\fileread.h"
#include "..\\playmain.h"
#include "..\\field.h"
#include "..\\sinbaram\\sinlinkheader.h"
#include "..\\effectsnd.h"

#include "..\\record.h"
#include "..\playsub.h"

#include "gamesql.h"
#include "DllServer.h"

#include "..\\language.h"

#include "..\\sinbaram\\sinitem.h"

#include "ClientFuncPos.h"

#include "OnServer.h"
#include "svr_Damage.h"
#include "openlive.h"

#include "..\\damage.h"

//#define	_BELLATRA_OLD_VERSION
//#define	_BELLATRA_OLD_VERSION_NOMOEY

#ifdef _W_SERVER
#include "ServerMsg.h"			//각종 국가별 메세지
#else
//클라이언트 컴파일용 ( 의미없음 )
#define CHAT_ANGERMONSTER_MAX		2
char *szAngerMonster[CHAT_ANGERMONSTER_MAX] = {	"","" };
char *szMonsterFlagMsg= "";
#define		SERVER_DOWN_MSG_COUNT	2
char *szServerDownMsg[SERVER_DOWN_MSG_COUNT] = { "", "" };
char *szSeverDownCountMsg = "";
char	*srMsg_Bl_01;
char	*srMsg_Bl_02;
char	*srMsg_BI_03;
char	*srMsg_BI_04;
char	*srMsg_Bl_100;
char	*srMsg_Bl_1001;//해외
char	*srMsg_Bl_101;
char	*srMsg_Bl_102;
char	*srMsg_011;
char	*srMsg_038;
char	*srMsg_300;
char	*srMsg_301;
char	*srMsg_400;
char	*srMsg_401;
char	*srItem_BB;

char *srBlessCastle_LeagueMsg_01;// = "공지> 지금부터 3분후에 블레스캐슬에서 공성전이 시작됩니다. 참여하실 분들은 준비해 주십시오"; 
char *srBlessCastle_LeagueMsg_02;// = "공지> 지금 블레스캐슬에서 공성전이 시작했습니다. 참가하신 모든 분들께 행운을 빕니다"; 
char *srBlessCastle_LeagueMsg_03;// = "공지> 공성전이 종료되었습니다. 참가해주신 모든 분들께 감사드립니다"; 
char *srBlessCastle_LeagueMsg_04;//
char *srBlessCastle_LeagueMsg_05;// 

char *srMsg_StartUser_PresentItem;
char *srMsg_ThanksPolling;

#endif


//XTRAP 관련파일
#ifdef _XTRAP_GUARD_4_SERVER
#include "..\\XtrapSrc4\XTrapCC.h"
#include "..\\XTrapSrc4\ServerXtrap.h"
#endif

#include "..\Chinese\c_TimeLimit.h" //해외

/////////////////////////////////////////////////////////////////////
//중국판 만 따로 틀린점 
//
//중국판은 유니크 와 이펙트 아이템 없음 ( 무조건 불량 아이템 처리 )
//중국판 해킹이 많기 때문에 이펙트 기능 제한함
//
/////////////////////////////////////////////////////////////////////

#ifdef	_LANGUAGE_KOREAN
//SetWindowText( hwnd , "Hotuk GameServer [ PT_CHINESE ]" );
char	*finehack_message = "http://info.pristontale.com/blackWarning/warning.asp?id=%s&name=%s";
#endif
#ifdef	_LANGUAGE_CHINESE
//SetWindowText( hwnd , "Hotuk GameServer [ PT_CHINESE ]" );
char	*finehack_message = "http://info.pristontale.com/blackWarning/warning.asp?id=%s&name=%s";
#endif

#ifdef	_LANGUAGE_JAPANESE 
//SetWindowText( hwnd , "Hotuk GameServer [ PT_JAPANESE ]" );
char	*finehack_message = "http://info.pristontale.com/blackWarning/warning.asp?id=%s&name=%s";
#endif

#ifdef _LANGUAGE_TAIWAN
//SetWindowText( hwnd , "Hotuk GameServer [ PT_TAIWAN ]" );
char	*finehack_message = "http://info.pristontale.com/blackWarning/warning.asp?id=%s&name=%s";
#endif

#ifdef _LANGUAGE_ENGLISH
#ifdef _LANGUAGE_PHILIPIN
//SetWindowText( hwnd , "Hotuk GameServer [ PT_PHILIPPINE ]" );
char	*finehack_message = "http://update.netplay.ph/pstale/WarningMsg/warning.asp?id=%s&name=%s";
#else
//SetWindowText( hwnd , "Hotuk GameServer [ PT_ENGLISH ]" );
char	*finehack_message = "http://info.pristontale.com/blackWarning/warning.asp?id=%s&name=%s";
#endif
#endif
#ifdef _LANGUAGE_VEITNAM
//SetWindowText( hwnd , "Hotuk GameServer [ PT_VEITNAM ]" );
char	*finehack_message = "http://info.pristontale.com/blackWarning/warning.asp?id=%s&name=%s";
#endif
#ifdef _LANGUAGE_THAI
//SetWindowText( hwnd , "Hotuk GameServer [ PT_THAILAND ]" );
char	*finehack_message = "http://info.pristontale.com/blackWarning/warning.asp?id=%s&name=%s";
#endif
#ifdef _LANGUAGE_BRAZIL
char	*finehack_message = "http://info.pristontale.com/blackWarning/warning.asp?id=%s&name=%s";
#endif

//////////디버깅 /////////////
int LogOnThread_Count;
int	LogOnThread_Process;
int LogOnThread_ProcessTime;
int LogOnThread_Sucess;

char	szLastLogInID[64];
int		LastLogInResult = 0;

//세팅파일 다시 설정
int rsRefreshConfig();

HFONT	hServerFont = 0;

int		Svr_DisplayMode = 0;		//서버 창 표시모드

/////////////////////////////

char *srEventMonName1 = "좀비";

#define	srCRISTAL_MAX		20		// pluto 가디안 디바인 추가 20
#define MARVELCRISTAL_MAX	8

struct srCRISTAL_MONSTER {
	char *szName;
	smCHAR_INFO	*lpCharInfo;
	int	RndCount;
};

#define	srCRISTAL_RANDOM		8
#define	srCRISTAL_CLAN			9
#define srCLAN_MONSTER_MAX		3
#define	srCRISTAL_CASTLE_START	13
#define	srCRISTAL_CASTLE_END	16

#define	srCRISTAL_SKELETON		16	
#define	srCRISTAL_KAOS			17	
#define	srCRISTAL_IMPERNA		18	
#define srCRISTAL_EXTREME		19		// pluto 익스트림 크리스탈
#define	srCRISTAL_MARVEL_RANDOM	20		// pluto 마벨 크리스탈
#define	srCRISTAL_G_DIVINE_CLAN			21		// pluto 가디안 디바인


srCRISTAL_MONSTER	srCristalMonster[srCRISTAL_MAX] = {
	{ " 호피 "				, 0 , 20	},
	{ " 홉고블린 "			, 0 , 20	},
	{ " 디코이 "			, 0 , 15	},
	{ " 바곤 "				, 0 , 15	},
	{ " 헤드커터 "			, 0 , 15	},
	{ " 파이곤 "			, 0 , 10	},
	{ " 킹호피 "			, 0 , 5		},
	{ " 헐크 "				, 0 , 0		},
	{ " 랜덤 "				, 0 , 0		},
	{ "가디안 세인트"		, 0 , 0		},
	{ " 웹 "				, 0 , 0		},
	{ " 다크 스펙터 "		, 0 , 0		},
	{ " 아이언 가드 "		, 0 , 0		},
	{ "리카르텐 민병대"		, 0 , 0		},
	{ "리카르텐 경비대"		, 0 , 0		},
	{ "블레스왕국 경비대"	, 0 , 0		},

	{ "스켈레톤 크리스탈"	, 0 , 0		},
	{ "카오스   크리스탈"	, 0 , 0		},
	{ "인페르나 크리스탈"	, 0 , 0		},
	{ "가디안 디바인"		, 0 , 0		}		// pluto 가디안 디바인

};






srCRISTAL_MONSTER	srCristalMonsterBoss[srCRISTAL_MAX] = {
	{ " 짱피 "				, 0 , 20	},
	{ " 와일드 고블린 "		, 0 , 20	},
	{ " 맥시멈 디코이 "		, 0 , 15	},
	{ " 바우톤 "			, 0 , 15	},
	{ " 베가 드미르 "		, 0 , 15	},
	{ " 헬싱 "				, 0 , 10	},
	{ " 호러피온 "			, 0 , 5		},
	{ " 타이푼 "			, 0 , 0		},
	{ " 랜덤 "				, 0 , 0		},
	{ "가디안 세인트"		, 0 , 0		},
	{ " 커즈웹 "			, 0 , 0		},
	{ " 다크 팬텀 "			, 0 , 0		},
	{ " 이미티르 가드 "		, 0 , 0		},
	{ "리카르텐 민병대"		, 0 , 0		},
	{ "리카르텐 경비대"		, 0 , 0		},
	{ "블레스왕국 경비대"	, 0 , 0		},

	{ "스켈레톤 크리스탈"	, 0 , 0		},
	{ "카오스   크리스탈"	, 0 , 0		},
	{ "인페르나 크리스탈"	, 0 , 0		},
	{ "가디안 디바인"		, 0 , 0		}		// pluto 가디안 디바인
};

srCRISTAL_MONSTER srMarvelCristalMonster[MARVELCRISTAL_MAX] = {			// pluto 마벨 크리스탈
	{ " 바곤 "				, 0 , 20	},
	{ " 헤드커터 "			, 0 , 20	},
	{ " 파이곤 "			, 0 , 15	},
	{ " 킹호피 "			, 0 , 15	},
	{ " 헐크 "				, 0 , 12	},
	{ " 웹 "				, 0 , 10	},
	{ " 다크 스펙터 "		, 0 , 5		},
	{ " 아이언 가드 "		, 0 , 3		}
};

#define	srSKILL_MONSTER_MAX		3

//스킬소환 몬스터
srCRISTAL_MONSTER	srSkillMonster[srSKILL_MONSTER_MAX] = {
	{ "메탈 고렘"		, 0 , 0	},
	{ "울버린"			, 0 , 0	},
	{ "파이어 엘레멘탈"	, 0 , 0	}
};


//빌링용 크리스탈
#define	srBC_MONSTER_MAX		4
#define	srBC_MONSTER_TOTAL		16
srCRISTAL_MONSTER	srBillingCrystalMonster[srBC_MONSTER_TOTAL] = {
	{ " 스켈레톤 아처 "     , 0 , 0	},
	{ " 스켈레톤 레인저 "	, 0 , 0	},
	{ " 스켈레톤 워리어 "	, 0 , 0	},
	{ " 스켈레톤 나이트 "	, 0 , 0	},

	{ " 나즈 "	        , 0 , 0	},
	{ " 헤비 고블린 "	, 0 , 0	},
	{ " 스트라이더 "	, 0 , 0	},
	{ " 디-머신 "	        , 0 , 0	},

	{ " 라투 "	        , 0 , 0	},
	{ " 그로테스크 "	, 0 , 0	},
	{ " 아이언 피스트 "	, 0 , 0	},
	{ " 프로스트 에이션트 "	, 0 , 0	},
	// pluto 익스트림 크리스탈 몬스터 추가
	{ " 오미크론 "	        , 0 , 35	},
	{ " 스파이더 트루퍼 "	, 0 , 30	},
	{ " 마운틴 "	, 0 , 20	},
	{ " 오메가 "	, 0 , 15	}
};



//해머 몬스터 목록
#define srHAMMER_MONSTER_MAX		16

smCHAR_INFO	*srCharInfo_HammerMonster[srHAMMER_MONSTER_MAX];
int	srHammerMonsterCount = 0;


#ifdef _W_SERVER
char *szAdminIP = "211.219.44.";
char *szAdminIP2 = "211.44.231.";
#else
char *szAdminIP = "220.76.89.";
char *szAdminIP2 = "220.76.88.";
#endif

#define MYWM_NOTIFYICON		(WM_USER+140)
#define MYWM_USER_COUNT		(WM_USER+110)
#define ID_MESSTEXT		101

void TrayIconClose();
void TrayIconCreat();
//초기화
int InitAll();
//종료 모든 작업을 메모리에서 제거
void RemoveAll();

//크리티컬 섹션 선언
CRITICAL_SECTION	cSerSection;
static CRITICAL_SECTION	cOdbcSection;

char	szServer_DebugString[256];
DWORD	dwServer_DebugMessage;				//디버깅 최후로 받은 메세지 구분
char	szServer_DebugLastUserID[32];			//마지막으로 처리된 계정
char	szServer_DebugLastUserName[32];			//마지막으로 처리된 이름
int		Server_DebugCount;						//디버그 처리 카운터

int		rsNSpriteMode = 0;						//nSprite 사용 ( 중국보안 )

int		rsOpenNPC_RandomPos =0;					//NPC오픈 난수설정값

HWND	hDebugWnd=0;
#define	SWM_DISPDEBUG	(WM_USER+77)

//서버 기동 
int	ServerMode = 0;
int	Server_SqlReady = 0;
int	ServerNameCode = 0;

static HINSTANCE hInst;              /* current instance                      */
extern HWND hwnd;
static HWND hMsgTextWnd;
static HDC	hdc;
static int Quit = 0;
static char *szAppName = "호떡 온라인 게임서버";
static LONG APIENTRY WndProc(HWND,UINT,WPARAM,LPARAM);
static int WinWidth = 320;
static int WinHeight = 240;

static int WSA_RecvMsgCount = 0;

static	int AccountPerl = 100;
static	int	ShutDownFlag =0;
static	int	ShutDownLeftTime =0;


INT SetupDefWindow(HINSTANCE hInstance, HANDLE hPreInst, LPSTR lpszCmdParam, int nCmdShow)
{
	WNDCLASS	wndclass;

	hInst = hInstance;

	if (!hPreInst) {
		wndclass.style        =CS_HREDRAW|CS_VREDRAW;
		wndclass.lpfnWndProc  =WndProc;
		wndclass.cbClsExtra   =0;
		wndclass.cbWndExtra   =0;
		wndclass.hInstance	  =hInst;
		wndclass.hIcon		  =LoadIcon (hInstance, MAKEINTRESOURCE(IDI_SERVER_ICON) );
		wndclass.hCursor      =LoadCursor(NULL,IDC_ARROW);
		wndclass.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH);
		wndclass.lpszMenuName ="IDR_MENU1";
		wndclass.lpszClassName=szAppName;
		RegisterClass(&wndclass);
	}

	hwnd=CreateWindow(szAppName,szAppName,
//				  WS_SYSMENU|WS_OVERLAPPED|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MINIMIZE ,
				  WS_SYSMENU|WS_MINIMIZEBOX|WS_MINIMIZE ,
				  CW_USEDEFAULT,
				  CW_USEDEFAULT,WinWidth,WinHeight,NULL,NULL,
				  hInst,NULL);



	HMENU	hMenu;
	hMenu = CreateMenu(  );
#ifndef _LANGUAGE_KOREAN
	hMenu = LoadMenu( hInstance , MAKEINTRESOURCE(IDR_MENU2) );
#else
	hMenu = LoadMenu( hInstance , MAKEINTRESOURCE(IDR_MENU1) );
#endif

	SetMenu( hwnd , hMenu );

	ShowWindow(hwnd,nCmdShow);
	UpdateWindow(hwnd);


#ifdef	_LANGUAGE_CHINESE
SetWindowText( hwnd , "Hotuk GameServer [ PT_CHINESE ]" );
#endif

#ifdef	_LANGUAGE_JAPANESE 
SetWindowText( hwnd , "Hotuk GameServer [ PT_JAPANESE ]" );
#endif

#ifdef _LANGUAGE_TAIWAN
SetWindowText( hwnd , "Hotuk GameServer [ PT_TAIWAN ]" );
#endif

#ifdef _LANGUAGE_ENGLISH
#ifdef _LANGUAGE_PHILIPIN
SetWindowText( hwnd , "Hotuk GameServer [ PT_PHILIPPINE ]" );
#else
SetWindowText( hwnd , "Hotuk GameServer [ PT_ENGLISH ]" );
#endif
#endif
#ifdef _LANGUAGE_BRAZIL
SetWindowText( hwnd , "Hotuk GameServer [ PT_BRAZIL ]" );
#endif

#ifdef _LANGUAGE_ARGENTINA
SetWindowText( hwnd , "Hotuk GameServer [ PT_ARGENTINA ]" );
#endif

#ifdef _LANGUAGE_VEITNAM
SetWindowText( hwnd , "Hotuk GameServer [ PT_VIETNAM ]" );
#endif
#ifdef _LANGUAGE_THAI
SetWindowText( hwnd , "Hotuk GameServer [ PT_THAILAND ]" );
#endif

#ifndef _LANGUAGE_KOREAN
	AccountPerl = 40;
#endif

	// 트레이 아이콘 생성
	TrayIconCreat();

	ServerMode = TRUE;
	szServer_DebugString[0] = 0;

	//서버 재설정
	rsRefreshConfig();


	//게임 소켓 초기화
	InitGameSocket(TRUE);

	InitAll();

	if ( smConfig.dwServerPort )
		InitBindSock(smConfig.dwServerPort);
	else
		InitBindSock(TCP_SERVPORT);


	EnableMenuItem(GetMenu( hwnd ), ID_STOP , MF_ENABLED );
	EnableMenuItem(GetMenu( hwnd ), ID_START, MF_GRAYED );

	return	TRUE;

}






//=============================================================================//


char szMessageBuff[256];
DWORD ListBuff[smSOCKBUFF_SIZE/4];
int PlayerCount;


//공지 사항 메세지
struct	rsSERVER_NOTICE {
	DWORD Counter;	
	char szMessage[256];
};
rsSERVER_NOTICE	rsNoticeMessage;



extern	smWINSOCK	smWSock[CONNECTMAX];

#define DIST_AROUND_NEAR	(256*256)
#define DIST_AROUND_MIDDLE	(16*64 * 16*64)

#define CHATBUFF_MAX		1024
#define CHATBUFF_MASK		1023

#define TRANS_IPMAX			(1000/sizeof(TRANS_IPLIST))

//한구역의 최대 수용 인원
#define AREA_USERMAX		256
#define AREA_MAX			256

#define AUTOPLAYER_MAX		2048
#define AUTOPLAYER_MASK		2047

//유저 서버 접속 제한수
int rsConnectUserLimit = 800;

//캐릭터플레이 데이타 동시 전송 최대치
#ifdef	_LANGUAGE_THAILOW		//C7
//#define	TRANS_MAX_CHAR_LIMIT	14
//#define	TRANS_MAX_USER_LIMIT	10
#define	TRANS_MAX_CHAR_LIMIT	24
#define	TRANS_MAX_USER_LIMIT	16
#else
#define	TRANS_MAX_CHAR_LIMIT	28
#define	TRANS_MAX_USER_LIMIT	18
#endif


//수신 시간 초과시 송신 금지 
#define	OVER_TRANS_TIME		1500

#define STAGE_MAX			10
smSTAGE3D	*lpsmStage[STAGE_MAX];

DWORD		dwPlayServTime = 0;
DWORD		dwOffsetTime = 0;

#define	CHR_MONSTER_MAX		400
#define	DEF_ITEM_MAX		800

//다시 시작하는 카운터 ( 슬립 모드 대기시 )
#define	REOPEN_COUNT_NUM	256


#define TRANS_VIEW_LIMIT		(64*64)

//깃발 하나당 발생할수 있는 최대 몬스터 수
#define OPEN_START_MONSTER_MAX		3

//아이템 사라지는 시간
#define	STG_ITEM_WAIT_TIME		(1000*60*3)
#define	STG_ITEM_WAIT_TIME_LOW	(1000*90)


#define ITEM_SET_DIST	24

POINT	ptItemSettingPosi[8] = {
	{  0			 , -ITEM_SET_DIST },
	{  ITEM_SET_DIST , -ITEM_SET_DIST },
	{  ITEM_SET_DIST ,  0			  },
	{  ITEM_SET_DIST ,  ITEM_SET_DIST },
	{  0             ,  ITEM_SET_DIST },
	{ -ITEM_SET_DIST ,  ITEM_SET_DIST },
	{ -ITEM_SET_DIST ,  0             },
	{ -ITEM_SET_DIST , -ITEM_SET_DIST }
};

//자동 캐릭터 서버모드 설정 
//( 자동 캐릭터가 없으면 서버는 단순 캐릭터 데이타 서버로 동작 )
int	LoginServer = 0;
int	AutoPlayServer = 0;
int	UserPlayServer = 0;

int chrMonsterCnt;
int	EventMonster=0;			//몬스터 이벤트

//PK가능한 레벨 
#define	LIMIT_PK_LEVEL	10

//int	rsHardCoreEvent = 1;			//하드코어 이벤트 실시
int	rsHardCoreEvent = 0;			//하드코어 이벤트 실시
int	rsDamgeOffEvent = 0;			//공격력 활인 이벤트
//해외버전용///////////////////////////////////////////////////////
//필리핀
//#ifdef	_LANGUAGE_PHILIPIN
int	rsDamgeOffEvent1 = 0;			//공격력 할인 이벤트1
int	rsDamgeOffEvent2 = 0;			//공격력 할인 이벤트2
//#endif

int rsDefenseOffEvent	= 0;			//몬스터 방어력 할인 이벤트
///////////////////////////////////////////////////////////////////
int	rsCristalEvent = 0;				//몬스터 크리스탈 이벤트
DWORD	dwBabelPlayTime = 0;		//거대 몬스터 바벨 출현 유지시간
int		BabelPlayField = -1;


char *MonsterPath = "GameServer\\monster\\";
char *ItemPath = "GameServer\\OpenItem\\";
char *szNpcInfoPath = "GameServer\\npc\\";
char *szFieldInfoPath = "GameServer\\Field\\";
char *HackLogDirectory = "LogFile";
char *LogDirectory = "LogFile";
char *DebugLogDirectory = "LogDebug";
char *AdminLogDirectory = "LogAdmin";

//데스트용 서버 이름
static char *szDebugServer = "penguin-pc";
int DebugServerMode = 0;

int	DefaultItemCount;

//static rsPLAYINFO *AreaPlayUserInfo[ AREA_MAX ][AREA_USERMAX];
static int	ChatBuffCnt;
static char TransTemp[1024];
static char	szChkID[32];

/*
smCHAR_INFO			chrMonsterList[CHR_MONSTER_MAX];
smCHAR_MONSTER_INFO	chrMonInfoList[CHR_MONSTER_MAX];
static rsPLAYINFO	rsPlayInfo[CONNECTMAX];
static CHATBUFF ChatBuff[CHATBUFF_MAX];
sDEF_ITEMINFO	DefaultItems[DEF_ITEM_MAX];
*/

smCHAR_INFO			*chrMonsterList;		//[CHR_MONSTER_MAX];
smCHAR_MONSTER_INFO	*chrMonInfoList;		//[CHR_MONSTER_MAX];
rsPLAYINFO	*rsPlayInfo;				//[CONNECTMAX];
static CHATBUFF *ChatBuff;					//[CHATBUFF_MAX];
sDEF_ITEMINFO	*DefaultItems;				//[DEF_ITEM_MAX];
//자동 조정 캐릭터 들
smCHAR		*chrAutoPlayer;					//[AUTOPLAYER_MAX];

smCHAR_INFO	*chrNpcMonsterInfo = 0;				//NPC가 변하는 몬스터

DWORD	dwConnectCount = 0;
DWORD	rsAutoPlayTransCount = 0;

/*
struct	rsCURRENCY_LOG {	
	//사용된 돈 통화량 기록
	INT64	int64_CraftMoney = 0;
	INT64	int64_AgingMoney = 0;
	INT64	int64_ShopMoney = 0;
	INT64	int64_ShopPotionMoney[3] = { 0 , 0 , 0 };

	INT64	int64_ForceOrbMoney = 0;
	INT64	int64_WarpgateMoney = 0;
	INT64	int64_LearnSkillMoney = 0;
};
*/
rsCURRENCY_LOG	CurrencyLog;


int ActivePlayCounter;
int	srAutoPlayCount =0;

smCHAR		*lpActiveChar;

time_t		tServerTime=0;			//서버의 시간 ( 빌링 처리용 )

char *rsRecordDataBuff =0;

//억셉트 모니터
int			srAcceptErrorCount = 0;
int			srLastAcceptRsult = 0;
int			srRouteErrorCount = 0;
int			srLogFailedCount = 0;

//아이템 강제 특화 생성
static int			spJobCode = 0;
static int			spItemNormal = 0;
static DWORD		spJobCodeTime = 0;

//시간제 아이템 날짜 보정 생성
static int			spTimeAdjust = 0;
static DWORD		spTimeAdjustTime = 0;


char	*szLogItemDataDirectory = "LogItemData";			//아이템 기록 보관소



rsUSER_LIST_TOP10	rsUserListDamageTop10;		//데미지준 유저 목록 10명까지



//블레스 캐슬 세율 적용 시간 (새벽2시)
//공성세율
#ifdef _LANGUAGE_ENGLISH
#ifdef _LANGUAGE_PHILIPIN
#define	rsBLESSCASTLE_TAX_TIME			23
#else
#define	rsBLESSCASTLE_TAX_TIME			4
#endif
#else
#ifdef _LANGUAGE_VEITNAM
#define	rsBLESSCASTLE_TAX_TIME			23
#else
#define	rsBLESSCASTLE_TAX_TIME			2
#endif
#endif

rsBLESS_CASTLE		rsBlessCastle;				//블래스 캐슬 공성 정보

// pluto 제작 조합
//Rune_Formula RuneFormula[MAX_RECIPE_KIND];

//시스템 패킷 ( 다른 서버에서 들어옴 )
int rsRecvSystemInfo( rsPLAYINFO *lpPlayInfo , void *Buff );
//다른 서버와 연결 초기화
int rsInit_SerToServer();
//시스템 회선 연결 종료 ( 다른서버와의 연결 )
int	rsDisconnectSystemLine( smWINSOCK *lpsmSock );

//클라이언트 끈김 ( 크리티칼 사용 안함 )
int DisconnectUser( smWINSOCK *lpsmSock );
//던져진 아이템 저장
int SaveThrowItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode, DWORD dwKey , DWORD dwSum );
//DB ACCOUNT 인증
int rsLogAccount( rsPLAYINFO *lpPlayInfo , char *szID , char *szPassword );
//로그인 큐 카운트
int rsGetLogOnQueCount();

//해킹 시도 기록 파일로 남김
int RecordHackLogFile( rsPLAYINFO *lpPlayInfo , void *lpTransCommand );
//int RecordHackLogFile( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );
//디버그 접속 유저 기록 파일로 남김
int RecordDebugPlayLogFile( rsPLAYINFO *lpPlayInfo );
//아이템 믹스 기록
int RecordMixItem( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpSrcItem , sITEMINFO *lpMixItem );
//아이템 에이징 기록
int RecordAgingItem( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpSrcItem , sITEMINFO *lpMixItem , int Mode );

//int RecordHackLogFile( rsPLAYINFO *lpPlayInfo );
//크랙 찾기 초기화
int	InitCrackFinding();
//네트웤 상태 로그 전송
int rsSendNetLog( rsPLAYINFO *lpPlayInfo );
//기부금 파일로 기록
int RecordCollectMoney( rsPLAYINFO *lpPlayInfo , int Money );
//캐릭터 제거 기록 파일로 남김
int RecordDeleteCharacter( char *szID , char *szIP, smCHAR_INFO *lpCharInfo );
//고가의 아이템 입수 기록 파일로 남김
int RecordGetHighItem( rsPLAYINFO *lpPlayInfo , struct STG_ITEMS *lpStgItem );
//하위 게임 서버와 IP가 맞는지 확인한다
int rsCheckChildServer( char *szIP );

//서버를 종료시킨다 ( 종료시키는데 걸리는 시간은 약 6~10분 정도 소요 )
int	rsShutDown();

// pluto 제련
int RecordSmeltingItem( rsPLAYINFO *lpPlayInfo, sITEMINFO *lpSmeltingItem );
// pluto 제작
int RecordManufactureItem( rsPLAYINFO *lpPlayInfo, sITEMINFO *lpManufactureItem );

class STG_AREA;

//이벤트 몬스터 생성
int rsOpenEventMonster( int EventCode , int wParam , int lParam , int sParam );
// 같은 종류의 이벤트 몬스터 생성
int rsReOpenEventMonster( STG_AREA *lpStgArea , smCHAR *lpChar );
//이벤트 몬스터 제거
int rsCloseEventMonster( int EventCode );
//아이템 특정 유저의 인벤토리보냄
int rsPutItem( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode );
//아이템 특정 유저의 인벤토리보냄 ( 특화/물약수 설정 )
int rsPutItem( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , int spJobCode );
//아이템 특정 유저의 인벤토리보냄 ( 유니크옵션 )
int rsPutItemUnique( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , int spJobCode , DWORD dwUniqueCode );

//아이템 특정 유저의 인벤토리보냄
int rsPutItem2( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpItem );
//전업 확인 처리
int rsCheck_ChageJob( rsPLAYINFO *lpPlayInfo , int NewCnageJob );
//선물형 아이템 생성
int CreatePresentItem( DWORD dwItemCode , STG_AREA *lpStgArea , int x, int y, int z , int count );


//보스 몬스터세트 생성
int rsOpenBossMonster( STG_AREA *lpStgArea , sBOSS_MONSTER *lpBossMonster );
//캐릭터 변경
int rsCharChanger( smCHAR *lpChar , smCHAR_INFO *lpCharInfo , smCHAR_MONSTER_INFO *lpMonInfo ) ;

//하드코어 이벤트 초기화
int	rsInitHardCoreEvent();
//모금함 열기
int SendOpenCollectMoney( smWINSOCK *lpsmSock );
//이벤트 지역인지 첵크
int rsCheckHardCoreEventArea( int x, int y, int z ) ;
//Sod 점수 업그레이드
int	rsTransUpdateSod( rsPLAYINFO *lpPlayInfo );


//위치로 해당 배경 구역을 찾는다 
STG_AREA *FindStageField( int x, int z );

extern TRANS_SERVER_LIST	TransServerList;			//서버 설정 정보
extern rsSERVER_CONFIG		rsServerConfig;				//서버 설정 구조
//서버 선택 리스트를 보내준다
int rsSendServerList( smWINSOCK *lpsmSock , int ClanTicket );

//데이타서버로 경유전송
int rsSendDataServer( smWINSOCK *lpsmSock , void *szData );
//게임 서버로 클라이언트 경유 전송
int rsSendGameServer( smWINSOCK *lpsmSock , void *szData );
//게임 지역 서버로 클라이언트 경유 전송
int rsSendAreaServer( smWINSOCK *lpsmSock , void *szData );

//주변 유저에게 명령 보냄
int	rsSendCommandUser( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX	*lpTransCommandEx );

//고친 경험치를 기록으로 남긴다
int	rsRecordFixExp( rsPLAYINFO *lpPlayInfo );

//나쁜자들 명단 등록
int rsAddBackListID( char *szID , DWORD dwTime );
//나쁜자들 명단 확인
DWORD rsCheckBackListID( char *szID );
//나쁜자들 명단 모두 초기화
int rsResetBackList();
//나쁜자들 명단에서 해제
int rsFreekBackListID( char *szID );
//나쁜자들 명단을 보내준다
int rsShowBlackList( smWINSOCK *lpsmSock , char *szID );
//전업자 기록 파일로 남김
int RecordJobChanger( rsPLAYINFO *lpPlayInfo );
//유저 영구블럭 확인
int	rsCheckBlockUserFile( char *szID );
//유저를 영구 블럭
int rsAddBlockUserFile( char *szID , char *szLog );
//군서버로 경험치 정보 보냄
int rsSendGameServerExp( rsPLAYINFO *lpPlayInfo );

//접근 허가 IP 확인
int	rsCheckEnableIP( DWORD dwUserIP );
//접근 금지 IP 확인
int	rsCheckDisableIP( DWORD dwUserIP );
//아이피 주소를 뒤집어서 변환
DWORD GetSwapIPCode( char *szIP );
//관리자 IP 확인
int	rsCheckAdminIP( DWORD dwUserIP );
//시스템 IP 확인
int	rsCheckSystemIP( DWORD dwUserIP );
//로긴서버 IP 확인
int	rsCheckLoginServerIP( DWORD dwUserIP );

//인벤 아이템 추가
int	rsAddInvenItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum );
//인벤 아이템 제거
int	rsDeleteInvenItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum );
//인벤 아이템 찾기
int	rsFindInvenItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum );
//같은 코드의 아이템 찾기
int	rsCheckInvenItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode );

//아이템 정보송수신 구조체에 보안코드 해독 비교 ( 컴파일시 서버에서만 존재 )
int	rsCheck_ItemSecCode( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum , int Money , DWORD dwSeCode_0, DWORD dwSeCode_1, DWORD dwSeCode_2, DWORD dwSeCode_3 , int *pPotionCount );
//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
int	rsRegist_ItemSecCode( rsPLAYINFO *lpPlayInfo , TRANS_ITEMINFO *lpTransItemInfo , int NewItem );
//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
int	rsRegist_ItemSecCode( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommandEx );

//기타 임시 기록 파일로 남김
int Record_TempLogFile( char *szMessage );
//빌링 접속 종료 기록 파일로 남김
int Record_BillingLogFile( rsPLAYINFO *lpPlayInfo , DWORD wParam , DWORD lParam , DWORD sParam , DWORD eParam );
//캐릭터 사망 기록 파일로 남김
int Record_DeadUser( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );

//ShutDown 로그 생성
int RecordShutdownLog( int LogCode , int LParam , int SParam );


//복사 아이템 목록 불러 오기
int rsLoadCopiedItemList();
//복사 아이템 목록 제거
int rsRemoveCopiedItemList();
//아이템이 복사 아이템인지 확인
int rsCheckCopiedItem( sITEMINFO *lpItem );
//아이템이 복사 아이템인지 확인
int rsCheckCopiedItem( DWORD dwCode , DWORD dwHead , DWORD dwChkSum );

//SOD 결과를 데이타 서버로 보냄
int rsSend_ResultSOD( rsPLAYINFO *lpPlayInfo , int Point , int KillCount , int TotalPoint , int TotalSucessUser , int TotalUser , int ClassCode );
//스킬 사용 정보를 파티원에게 보내기
int	rsRecvSkillPartyUser( TRANS_PARTY_SKILL *lpTransPartySkill );
//스킬 실행
int rsRecvProcessSkill( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );
//스킬취소
int rsCancelSkill( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );
//스킬 업데이트
int rsUpdateSkill( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );

//클랜 업데이트 하기
int rsClanUpdate( rsPLAYINFO *lpPlayInfo , TRANS_CLAN_COMMAND_USER *lpTransClanUser );

//야호 동작 실행
int rsRecvYahooMotion( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );

//이름으로 찾기
rsPLAYINFO *FindUserFromName( char *szName );


//몬스터 사냥정보 보관
int	rsPushKillMonster( smCHAR *lpChar , rsPLAYINFO *lpPlayInfo , STG_AREA *lpStgArea );


//운영자 명령 사용기록
int	rsSaveAdminCommand( rsPLAYINFO *lpPlayInfo , char *szChatCommand , int Level );
//운영자 명령 사용기록
int	rsRecordAdminCommand( rsPLAYINFO *lpPlayInfo , char *szChatCommand , int Level );
//관리자 인지 조사
int	rsCheckAdminPlayer( rsPLAYINFO *lpPlayInfo );
//별 포인트 관련 처리
int rsRecvStarPoint( rsPLAYINFO *lpPlayInfo ,  smTRANS_COMMAND *lpTransCommand );
//SOD 클랜 상금 관련 처리
int rsRecvSodClanCash( rsPLAYINFO *lpPlayInfo ,  smTRANS_COMMAND *lpTransCommand );
//돈 기부 관련 처리
int rsRecvGiveMoney( rsPLAYINFO *lpPlayInfo ,  smTRANS_COMMAND *lpTransCommand );
//사용 요금 돈 관련 처리
int rsRecvPaymentMoney( rsPLAYINFO *lpPlayInfo ,  smTRANS_COMMAND *lpTransCommand );
//퍼즐 아이템 생성 유무
DWORD rsOpenEventPuzzleItem( rsPLAYINFO *lpPlayInfo , smCHAR *lpChar );
//개인 상점 거래 처리
int	rsTrade_PersonalShop( rsPLAYINFO *lpPlayInfo , rsPLAYINFO *lpPlayInfo2 , smTRANS_COMMAND_BUFF *lpTransCommandBuff );
//사랑의 아이템을 사용
int	rsUseLovelyItem( rsPLAYINFO *lpPlayInfo , DWORD	dwItemCode );
//이벤트용 모리프 대시
int	rsMorifEventMessage( smCHAR *lpChar );
//이벤트용 늑대 대사
int	rsMollyWolfEventMessage( smCHAR *lpChar );
//퀘스트용 마스터 대사
int	rsQuestMasterMessage( smCHAR *lpChar , rsPLAYINFO *lpPlayInfo );
//산타고블린 대사
int	rsSantaGoblinEventMessage( smCHAR *lpChar );
//이벤트용 월드컵 대사
//int	rsWorldCupEventMessage( smCHAR *lpChar );

//퀘스트 진행 처리
int rsGetQuestCommand( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );

//공지사항을 설정한다
int	rsSetNoticeMessage( char *szMessage );

//성 초기화
int rsInit_Castle();
//공성모드 시작
int	rsStart_CombatCastle();
//공성모드 종료
int	rsEnd_CombatCastle( int DefenceFlag );
//공성모드 종료
int	rsEnd_CombatCastle();
//공성모드 종료
int	rsEasy_CastleMode();
//공성 처리메인
int rsMain_CombatCastle();
//데미지준 클랜 10명 선별
int	rsSelectDamageClanTop10( smCHAR *lpChar ,  rsUSER_LIST_TOP10 *lpUserListDamageTop10 );
//블레스캐슬 정보 게임서버로부터 받기
int	rsRecvBlessCastleInfoFromGameServer( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommand );
//블레스캐슬 정보 데이타 서버로 보내기
int	rsSendBlessCastleInfoToDataServer( rsPLAYINFO *lpPlayInfo );
//블레스 캐슬 영혼의 샘터
int	rsBlessCastle_SoulFountainMain();
//블레스 캐슬 로딩
int rsLoadCastleInfo();
//블레스캐슬 저장
int	rsSaveCastleInfo();
//공성전 점수 로그
int RecordBlessCastleLog( rsUSER_LIST_TOP10 *lpUserListDamageTop10 );
//공성전 설정 변경 로그
int RecordBlessCastleSetup( rsPLAYINFO *lpPlayInfo , smTRANS_BLESSCASTLE *lpBlessCastleSetup );

//블레스 캐슬 정보 암호화 코드 생성
int rsCheck_BlessCastleClanSkill( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );
//블레스캐슬 스킬 적용
int rsSendBlessCastleClanSkill( rsPLAYINFO *lpPlayInfo );
//공성 아이템 사용
int	rsOpenSiegeCastleItem( DWORD dwItemCode , int x, int y, int z , rsPLAYINFO *lpPlayInfo );

//현재 플레이어의 필드 바닥위치 확인
int rsCheckPlayField( rsPLAYINFO *lpPlayInfo );
//처음시작 유저 아이템 지급
int rsStartUser_PresentItem( rsPLAYINFO *lpPlayInfo );
//저 레벨용 아이템 우연히 자동 생성하기
DWORD rsLowLevelItem( rsPLAYINFO *lpPlayInfo , smCHAR *lpChar );
//다른서버에서의 업데이트
int rsRecvUpdateServerParam( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );

////////////////////////// 베트남 경험치 시간분배 /////////////////////////////
int rsSendUserID_MainServer( rsPLAYINFO *lpPlayInfo );
int rsRecvUserID_MainServer( rsPLAYINFO *lpPlayInfo , smTRANS_CHAR_COMMAND2 *lpTransCharCommand );

//해킹용 함정
int rsRecvHackTrap(rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCharCommand );

#ifdef _CHECK_MESH
//아이템메쉬 조작검사 결과값 수신
int rsRecvCheckItemMesh( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand );
#endif

//클라이언트에 강제 저장후 종료 요구
int	rsSendCloseClient( rsPLAYINFO *lpPlayInfo );

// pluto 선물상자
int rsPutItem_TreasureBox( rsPLAYINFO *lpPlayInfo, DWORD Code );
///////////////////////////////// 아이템 이동 로그 //////////////////////////////////////////
#define	ITEMLOG_GET				0
#define	ITEMLOG_PUT				6
#define	ITEMLOG_MIXING			3
#define	ITEMLOG_MIXLOST			9
#define	ITEMLOG_AGING			4
#define	ITEMLOG_AGINGLOST		10
#define	ITEMLOG_AGINGUP			12
#define	ITEMLOG_BUYSHOP			5
#define	ITEMLOG_SELLSHOP		7
#define	ITEMLOG_TRADE			8
#define	ITEMLOG_USED			11
#define	ITEMLOG_EXPRESS			13
#define	ITEMLOG_GETWING			14
#define	ITEMLOG_WINGLOST		15
#define	ITEMLOG_BUYSTAR			16

#define	ITEMLOG_AGING_2UP		17
#define	ITEMLOG_AGING_2DOWN		18
#define	ITEMLOG_AGING_1DOWN		19
#define	ITEMLOG_AGING_KEEP		20

#define	ITEMLOG_PRESENT			21
#define	ITEMLOG_MYSHOP			22

#define	ITEMLOG_USE_ALCHMY		24
#define	ITEMLOG_LOST_ALCHMY		25
#define	ITEMLOG_GET_ALCHMY		26

#define	ITEMLOG_GET_RECON		27
#define	ITEMLOG_LOST_RECON		28
#define ITEMLOG_SMELTING_LOST	29		// pluto 제련 분실
#define ITEMLOG_SMELTING_GET	30		// pluto 제련 획득
#define ITEMLOG_MANUFACTURE_LOST 31		// pluto 제작 분실
#define ITEMLOG_MANUFACTURE_GET 32		// pluto 제작 획득
#define ITEMLOG_MANUFACTURE_FAIL 33		// pluto 제작 실패

//아이템 로그 일반 아이템 ( 출/입 기록 )
int	rsRecord_ItemLog( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , DWORD	dwHead , DWORD dwChkSum , int Flag );
//아이템 로그 일반 아이템 ( 출/입 기록 )
int	rsRecord_ItemLog2( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , DWORD	dwHead , DWORD dwChkSum , int Flag );
//아이템 로그 믹스쳐 및 에이징으로 변경된 아이템 ( 출/입 기록 )
int	rsRecord_ItemLog_Change( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , DWORD	dwHead , DWORD dwChkSum , 
		DWORD dwItemCode2 , DWORD	dwHead2 , DWORD dwChkSum2 ,	int Flag );
//아이템 로그 일반 믹스쳐,에이징에 사용된 쉘텀 
int	rsRecord_ItemLost( rsPLAYINFO *lpPlayInfo , DWORD *lpItemCode , DWORD *lpHead , DWORD *lpChkSum , int Flag );
//아이템 로그 트레이드
int	rsRecord_ItemLog_Trade( rsPLAYINFO *lpPlayInfo , rsPLAYINFO *lpPlayInfo2, TRANS_TRADE_ITEMKEY *lpTransTradeItemKey );
//아이템 로그 증정 아이템
int	rsRecord_ItemLog_Post( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , DWORD	dwHead , DWORD dwChkSum , DWORD dwGCode , char *szTelNum , int Flag );

// pluto 제련 아이템 로그
int rsRecord_SmeltingItemLog( rsPLAYINFO *lpPlayInfo, DWORD *lpItemCode, DWORD *lpHead, DWORD *lpChkSum, int Flag );
// pluto 제작 아이템 로그
int rsRecord_ManufactureItemLog( rsPLAYINFO *lpPlayInfo, DWORD *lpItemCode, DWORD *lpHead, DWORD *lpChkSum, int Flag );
////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////// 시스템 라인 관련 ///////////////////////

struct	smTRANS_SYSTEM_COMMAND {
	int		size,code;

	int		tCode;
	DWORD	dwObjectSerial;
	DWORD	dwNameCode;
	int		x,y,z;

	DWORD	Param[32];
};

#define	smTRANS_SYSCODE_CONNECT			0x1000
#define	smTRANS_SYSCODE_KILL_MONSTER	0x1100
#define	smTRANS_SYSCODE_GET_MONEY		0x1110
#define	smTRANS_SYSCODE_GET_ITEM		0x1112
#define	smTRANS_SYSCODE_DMG_USER_LIST	0x1120
#define	smTRANS_SYSCODE_NETSTATE		0x1200
#define	smTRANS_SYSCODE_NETSUCCESS		0x1250

#define	smTRANS_SYSCODE_CONNECT_USER	0x1300
#define	smTRANS_SYSCODE_USER_FAILED		0x1302
#define	smTRANS_SYSCODE_EXP_INFO		0x1310


#define	SER_TO_SERVER_SOCKET_MAX	4
#define	SER_TO_SERVER_SOCKET_MASK	3

smWINSOCK	*lpsmSock_SerToServer[ SER_TO_SERVER_SOCKET_MAX ] = { 0,0,0,0 };
DWORD		dwSerToSerIP = 0;
DWORD		dwSerToSer_Count = 0;
char		szSerToSerIP[32];

#define	SER_TO_LOGIN_SOCKET_MAX	16
rsPLAYINFO	*lpPlayInfo_LoginServer[ SER_TO_LOGIN_SOCKET_MAX ] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
DWORD		dwSerToLogin_Count = 0;
DWORD		dwSerToLogin_Num = 0;


rsKILL_MONSTER_INFO	rsKillMonster_Que[srMONSTER_KILL_QUE_MAX+10];
int	rsKillMonster_Push =0;
int	rsKillMonster_Pop =0;

HANDLE	hSerToServer_Thread =0;
DWORD	dwSerToServer_ID =0;

int	rsSystemNetCount = 0;
int	rsSystemLineConnCount = 0;
int rsSystemLineFailedCount = 0;
int rsSystemLinePlayCount = 0;



int	rsGetSystemLineCount();		//시스템 라인 연결 갯수 구하기
int	rsSetSerToLoginLine();		//로긴서버 라인 구하여 설정
int rsSendPacketToLoginLine( char *szBuff , int size );		//로긴 서버로 데이타 보내기


smWINSOCK	*rsFindNextSertoServerSock();
int	rsSendMoneyToSystemLine( rsPLAYINFO *lpPlayInfo , int Money );		//메인서버로 돈을 보낸다
int rsSendCharInfoToLoginServer( rsPLAYINFO *lpPlayInfo );				//군서버로 연결한 캐릭터 정보를 보낸다

int	rsMonHuntCount = 0;			//몹 사냥 카운터 ( 경험치 발생 횟수 )
int	rsMonOpenCount = 0;			//몹 발생 카운터
int	rsItemOpenCount = 0;		//아이템 발생 카운터 ( 몹에서 발생한 아이템만 기록 )
int	rsMoneyTotalCount = 0;		//돈 발생 카운터
int	rsItemBuffOverCount = 0;	//아이템 버퍼 오버 카운터
/////////////////////////////////////////////////////////////////////////

int	rsSendMoneyToUser( rsPLAYINFO *lpPlayInfo , int Money );			//돈을 유저에게 보낸다

POINT3D	*lprsFixedPoint = 0;		//몬스터 고정 좌표에서 출현일 경우 위치포인터 설정

#ifdef _xTrap_GUARD_SERVER
//로그인 성공 (엑스트랩 키생성)
int rsXTrap_Login( rsPLAYINFO *lpPlayInfo );
#endif


extern int	Server_LimitVersion;				//서버 입장 제한 버전

//서버관련 메모리 확보
int Server_AllocMemory()
{
	chrMonsterList	=	new	smCHAR_INFO[CHR_MONSTER_MAX];
	chrMonInfoList	=	new	smCHAR_MONSTER_INFO[CHR_MONSTER_MAX];
	rsPlayInfo		=	new	rsPLAYINFO[CONNECTMAX];
	ChatBuff		=	new	CHATBUFF[CHATBUFF_MAX];
	DefaultItems	=	new	sDEF_ITEMINFO[DEF_ITEM_MAX];
	chrAutoPlayer	=	new	smCHAR[AUTOPLAYER_MAX];

	//----------------------------------------<< _ignore_bug_fix_0x00000000 //해외
	// bug name : 유니온 코어
	#ifdef _LANGUAGE_CHINESE
	{
		ZeroMemory(DefaultItems,sizeof(sDEF_ITEMINFO)*DEF_ITEM_MAX);
	}
	#endif
	//----------------------------------------   _ignore_bug_fix_0x00000000  >>

	ZeroMemory( chrAutoPlayer , sizeof(smCHAR)*AUTOPLAYER_MAX );

	return TRUE;
}

//서버관련 메모리 해제
int Server_RemoveMemory()
{
	//delete	chrAutoPlayer;
	delete	DefaultItems;
	delete	ChatBuff;
	delete	rsPlayInfo;
	delete	chrMonInfoList;
	delete	chrMonsterList;

	return TRUE;
}



//관리자 및 권한설정
int InitAdminCommand();

#ifdef _xTrap_GUARD_SERVER
	rsXTrap_Init();
#endif

#ifdef _XTRAP_GUARD_4_SERVER
	rsXTrap_Init();
#endif

//세팅파일 다시 설정
int rsRefreshConfig()
{

#ifdef _W_SERVER

	//크리티칼 섹션 선언
	EnterCriticalSection( &cSerSection );

	smConfigDecode( "hotuk.ini"  );
	//관리자 및 권한설정
	InitAdminCommand();

	if ( rsServerConfig.LimitVersion )
		Server_LimitVersion = rsServerConfig.LimitVersion;

	if ( rsServerConfig.szServerName[0] && lstrlen(rsServerConfig.szServerName)<16 ) {
		lstrcpy( TransServerList.szServerName , rsServerConfig.szServerName );
	}

	if ( rsServerConfig.Permit_Exp ) Permit_CheckExp = rsServerConfig.Permit_Exp;
	else Permit_CheckExp = TOTAL_CHECK_EXP_MAX;

	if ( rsServerConfig.Permit_Money ) Permit_CheckMoney = rsServerConfig.Permit_Money;
	else Permit_CheckMoney = TOTAL_CHECK_MONEY_MAX;

	rsServerConfig.ServerInventoryMode = TRUE;			//새로운 버전부터 서버 인벤적용
	rsServerConfig.UseRecorMemory = TRUE;
	rsServerConfig.PotionMonitor = TRUE;

	//접속 제한 인원 설정
	if ( rsServerConfig.ConnectUserMax>0 ) rsConnectUserLimit=rsServerConfig.ConnectUserMax;

	rsResetBackList();				//나쁜 사람들 목록 초기화

	rsResetClientFuncPos();			//클라이언트 펑션 포지션 리셋

	//크랙 찾기 초기화
	InitCrackFinding();

	//크리티칼 섹션 해제
	LeaveCriticalSection( &cSerSection );

	hDebugWnd = FindWindow( NULL,"호떡 디버거" );
	if ( hDebugWnd ) SendMessage( hDebugWnd , SWM_DISPDEBUG , 0x800 , dwPlayServTime );

	if ( rsServerConfig.TestSeverMode==(rsServerConfig.LimitVersion+1)*88 )
		DebugServerMode=TRUE;

	rsInit_SerToServer();					//다른 서버와 연결 초기화

#ifdef _npGAME_GUARD_AUTH
	LoadAuthTable("CSAuth.tab" );
	LoadAuthIndex("CSAuth.idx" );
#endif

#ifdef _xTrap_GUARD_SERVER
	rsXTrap_Init();
#endif

#ifdef _XTRAP_GUARD_4_SERVER
	rsXTrap_Init();
#endif

#endif

	return TRUE;
}


/////////////////////////////// 중국판 인증 DLL ////////////////////////////////
/*

HINSTANCE hUsrLogInDLL;					// Handle to DLL
LPFNUSRLOGIN URSLoginIP=0;				// Function pointer
LPFNUSRLOGOUT URSLogoutIP=0;				// Function pointer
LPFNUSRLOGOUT_IP_BLOCK URSLogoutIPBlock=0;				// Function pointer


//중국판 인증DLL 로드
int LoadUsrLoginDLL()
{
	hUsrLogInDLL = LoadLibrary("URSLogin");
	if (hUsrLogInDLL != NULL) {
		URSLoginIP = (LPFNUSRLOGIN)GetProcAddress(hUsrLogInDLL,"URSLoginIP");
		URSLogoutIP = (LPFNUSRLOGOUT)GetProcAddress(hUsrLogInDLL,"URSLogoutIP");
		URSLogoutIPBlock = (LPFNUSRLOGOUT_IP_BLOCK)GetProcAddress(hUsrLogInDLL,"URSLogoutIPBlock");

		if (!URSLoginIP) {
			// handle the error
			FreeLibrary(hUsrLogInDLL);
			hUsrLogInDLL = 0;
			return FALSE;
		}

		//URSLogin( "abc","cde" );
		return TRUE;
	}
	return FALSE;
}
*/

//로그 아웃
int rsLogOut( rsPLAYINFO *lpPlayInfo )
{
	int BlockTime;
	int Money;

	if ( lpPlayInfo && lpPlayInfo->szID[0] && lpPlayInfo->lpsmSock ) {
/*
		if ( URSLogoutIP ) {
			URSLogoutIP( lpPlayInfo->szID , lpPlayInfo->lpsmSock->szIPAddr );
		}
*/
		if (  lpPlayInfo->szName[0] ) {
			Money = lpPlayInfo->ServerMoney-lpPlayInfo->WareHouseMoney;
			//DB LOG 기록
			RecordLogSql( LOG_SQL_LOGOUT ,lpPlayInfo->lpsmSock->szIPAddr , lpPlayInfo->szID , lpPlayInfo->szName , lpPlayInfo->szGPCode , 1 , lpPlayInfo->smCharInfo.JOB_CODE , 
				GetExp64( &lpPlayInfo->smCharInfo ) , lpPlayInfo->smCharInfo.Level , Money );	//lpPlayInfo->smCharInfo.Money );
		}

		//레벨업 선물주기 이벤트
		if ( rsServerConfig.PresentLevel>0 && lpPlayInfo->spLevel_Start>0 && rsServerConfig.PresentLevel>lpPlayInfo->CharLevelMax ) {

			lpPlayInfo->smCharInfo.Level = GetLevelFromExp( GetExp64( &lpPlayInfo->smCharInfo ) );			//경험치로 레벨 추산

			if ( lpPlayInfo->spLevel_Start<rsServerConfig.PresentLevel && lpPlayInfo->smCharInfo.Level>=rsServerConfig.PresentLevel ) {

				//아이템선물 우편 저장
				rsAddPostBox_Present( lpPlayInfo );

				//아이템 로그 증정 아이템
				rsRecord_ItemLog_Post( lpPlayInfo , 99 , 0 ,0 , lpPlayInfo->smCharInfo.Level , 0 , ITEMLOG_PRESENT );

			}
		}


		if ( lpPlayInfo->BlockTime==0x7FFFFFFF ) 
			BlockTime = 60*24*30*3;				//3달 블럭 ( 영구블럭과 다름 없음 )
		else
			BlockTime = lpPlayInfo->BlockTime/(60*1000);

		// Game Log 기록
		RecordGameLogSql( GAMELOG_SQL_LOGOUT ,lpPlayInfo->lpsmSock->szIPAddr , lpPlayInfo->szID , lpPlayInfo->szName , lpPlayInfo->szGPCode ,
				lpPlayInfo->smCharInfo.JOB_CODE,  lpPlayInfo->szGuid , BlockTime );



		if ( lpPlayInfo->szGPCode[0] ) {

			bSql_Logout( lpPlayInfo->szID, lpPlayInfo->szName, lpPlayInfo->lpsmSock->szIPAddr, lpPlayInfo->szGPCode, 
				lpPlayInfo->DisuseDay, lpPlayInfo->UsePeriod ,  lpPlayInfo->szGuid , lpPlayInfo->Bl_RNo );

		}

		if ( lpPlayInfo->ClanTicketCode && lpPlayInfo->szName[0] )
			bClan_UserTicket( lpPlayInfo , 1 );			//클랜 티켓 제거

	
		//고친 경험치를 기록으로 남긴다
		rsRecordFixExp( lpPlayInfo );

	}

	//시간별경험치분배 로그아웃DB에 기록 (베트남)
	if ( rsServerConfig.ExpGameTimeMode ) {
		if ( lpPlayInfo->dwExpGameTimeCheck ) {
			bSql_GetExpGameTime( lpPlayInfo , lpPlayInfo->dwExpGameTime/1000 );
		}
	}

	return TRUE;
}


//몬스터 그룹 초기화
int InitMonster()
{

	HANDLE hFindHandle;
	WIN32_FIND_DATA	fd;
	char	szFindPath[64];
	char	szFilePath[64];

	chrMonsterCnt = 0;

	ZeroMemory( chrMonsterList , sizeof(smCHAR_INFO)*CHR_MONSTER_MAX );
	ZeroMemory( chrMonInfoList , sizeof(smCHAR_MONSTER_INFO)*CHR_MONSTER_MAX );

	lstrcpy( szFindPath , MonsterPath );
	lstrcat( szFindPath , "*.inf" );

	hFindHandle = FindFirstFile( szFindPath , &fd );
	if ( hFindHandle!=INVALID_HANDLE_VALUE ) {
		while(1) {
			lstrcpy( szFilePath , MonsterPath );
			lstrcat( szFilePath, fd.cFileName );

			smCharDecode( szFilePath , &chrMonsterList[chrMonsterCnt] , &chrMonInfoList[chrMonsterCnt] , 0 );

			//고속 비교용 코드 구함
			chrMonInfoList[chrMonsterCnt].dwAutoCharCode = GetSpeedSum( chrMonsterList[chrMonsterCnt].szName );

			//테스트 서버 경험치 4배
			if ( rsServerConfig.TestSeverMode ) {
				chrMonsterList[chrMonsterCnt].Exp *= 4;
				chrMonInfoList[chrMonsterCnt].GetExp *= 4;
			}

			ReformCharForm( &chrMonsterList[chrMonsterCnt] );			//캐릭터 정보 인증 받기

			chrMonsterCnt++;
			//다음 파일 찾음
			if ( FindNextFile( hFindHandle , &fd )==FALSE ) break;
			if ( chrMonsterCnt>=CHR_MONSTER_MAX ) break;
		}
	}
	FindClose( hFindHandle );

	//smCharDecode( "char\\monster\\나쁜꼬마.inf" , &chrMonsterList[0] , 0 );

	int cnt,cnt2;


	rsInitHardCoreEvent();			//하드코어 이벤트 초기화

	//NPC 변하는 몬스터 캐릭터 정보 저장
	for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {

		//자주쓰는 메시 로드 ( 몬스터 캐릭 )
		if ( chrMonsterList[cnt].szModelName[0] ) {
			LoadOftenMeshPattern( chrMonsterList[cnt].szModelName  );
		}

		//if ( lstrcmp( chrMonsterList[cnt].szName , "좀비" )==0 ) {
		if ( lstrcmp( chrMonsterList[cnt].szName , srEventMonName1 )==0 ) {
			chrNpcMonsterInfo = &chrMonsterList[cnt];
		}

		//몬스터 크리스탈 포인터 설정
		for(cnt2=0;cnt2<srCRISTAL_MAX;cnt2++) {
			if ( lstrcmp( chrMonsterList[cnt].szName , srCristalMonster[cnt2].szName )==0 ) {
				srCristalMonster[cnt2].lpCharInfo = &chrMonsterList[cnt];
			}
		}
		for(cnt2=0;cnt2<srCRISTAL_MAX;cnt2++) {
			if ( lstrcmp( chrMonsterList[cnt].szName , srCristalMonsterBoss[cnt2].szName )==0 ) {
				srCristalMonsterBoss[cnt2].lpCharInfo = &chrMonsterList[cnt];
			}
		}
		for(cnt2=0;cnt2<srSKILL_MONSTER_MAX;cnt2++) {
			if ( lstrcmp( chrMonsterList[cnt].szName , srSkillMonster[cnt2].szName )==0 ) {
				srSkillMonster[cnt2].lpCharInfo = &chrMonsterList[cnt];
			}
		}
		for(cnt2=0;cnt2<srBC_MONSTER_TOTAL;cnt2++) {
			if ( lstrcmp( chrMonsterList[cnt].szName , srBillingCrystalMonster[cnt2].szName )==0 ) {
				srBillingCrystalMonster[cnt2].lpCharInfo = &chrMonsterList[cnt];
			}
		}

		// pluto 마벨 크리스탈
		for( cnt2 = 0; cnt2 < MARVELCRISTAL_MAX; cnt2++ )
		{
			if( lstrcmp( chrMonsterList[cnt].szName, srMarvelCristalMonster[cnt2].szName ) == 0 )
			{
				srMarvelCristalMonster[cnt2].lpCharInfo = &chrMonsterList[cnt];
			}
		}


		//해머 몬스터 목록
		if ( chrMonsterList[cnt].wPlayClass[0]==MONSTER_CLASS_HAMMER ) {
			if ( srHammerMonsterCount<srHAMMER_MONSTER_MAX )
				srCharInfo_HammerMonster[srHammerMonsterCount++] = &chrMonsterList[cnt];
		}

		//몬스터 보조이름만 있을경우 몬스터이름으로 확정
		if ( chrMonInfoList[cnt].szName[0] && !chrMonsterList[cnt].szName[0]) {
			lstrcpy( chrMonsterList[cnt].szName , chrMonInfoList[cnt].szName );
			chrMonInfoList[cnt].szName[0] = 0;
		}

	}


	return TRUE;
}

//국가별 몬스터 이름 확인 변환
int ConvertMonsterNames()
{
	int cnt;

	for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
		//몬스터 보조이름을 실제 이름으로 사용
		if ( chrMonInfoList[cnt].szName[0] && chrMonsterList[cnt].szName[0]) {
			lstrcpy( chrMonsterList[cnt].szName , chrMonInfoList[cnt].szName );
			chrMonInfoList[cnt].szName[0] = 0;
		}
	}

	return TRUE;
}


char *szUserModelPath = "char\\tmABCD";

//파일이 존재하는지 확인
int rsCheckActiveFile( char *szFile )
{
	WIN32_FIND_DATA	fd;
	HANDLE	hFindHandle;

	hFindHandle = FindFirstFile( szFile , &fd );
	if ( hFindHandle==INVALID_HANDLE_VALUE ) return FALSE;//해외부분 수정
	FindClose(hFindHandle);


	int cnt,len;
	char szFileName[128];

	len = lstrlen(szFile);
	memcpy( szFileName , szFile , len+1 );

	for(cnt=len-1;cnt>=0;cnt--) {
		if ( szFileName[cnt]=='\\' ) {
			szFileName[cnt] = 0;
			break;
		}
	}

	if ( lstrcmpi( szFileName , szUserModelPath )!=0 ) 
		return FALSE;

	return TRUE;
}



//아이템 초기화
int InitItems()
{

	HANDLE hFindHandle;
	WIN32_FIND_DATA	fd;
	char	szFindPath[64];
	char	szFilePath[64];
	sDEF_ITEMINFO	DefItem;

	DefaultItemCount = 0;

	lstrcpy( szFindPath , ItemPath );
	lstrcat( szFindPath , "*.txt" );

	hFindHandle = FindFirstFile( szFindPath , &fd );
	if ( hFindHandle!=INVALID_HANDLE_VALUE )
	{
		while(1)
		{
			//-----------------------------------------------------< _ignore_bug_fix_0x00000000_ //해외
			//ZeroMemory(&DefItem,sizeof(DefItem));
			//-----------------------------------------------------  _ignore_bug_fix_0x00000000_ >

			lstrcpy( szFilePath , ItemPath );	
			lstrcat( szFilePath, fd.cFileName );

			DecodeItemInfo( szFilePath , &DefaultItems[DefaultItemCount] );

			memcpy( &DefItem , &DefaultItems[DefaultItemCount] , sizeof(sDEF_ITEMINFO) );
			SetLowerItem( &DefItem );	//기본 아이템의 설정값을 최하로

			//상점용 아이템 백업 코드 제거
			DefItem.Item.BackUpKey = 0;
			DefItem.Item.BackUpChkSum = 0;
			DefItem.Item.dwCreateTime = 0;

			/*
			if ( DefItem.Item.JobCodeMask ) {
				DefItem.Item.JobCodeMask = 0;
				ZeroMemory( &DefItem.Item.JobItem , sizeof(sITEM_SPECIAL) );
				//아이템 인증 받기
				ReformItem( &DefItem.Item );
			}
			*/

			//데이타 압축 ( Z/NZ 방식 )
			DefaultItems[DefaultItemCount].DefCompressDataLen = 
				EecodeCompress( (BYTE *)&DefItem.Item , (BYTE *)DefaultItems[DefaultItemCount].DefCompressData  , sizeof(sITEMINFO) );

			//-------------------------------------------------------------< _ignore_bug_fix_0x00000000 //해외
#ifdef _LANGUAGE_CHINESE
			if( DefaultItems[DefaultItemCount].Item.CODE == 0x6010500 )
			{// 유니언 코어이면
				for(int i=9;i<32;i++)
				{
					DefaultItems[DefaultItemCount].Item.ItemName[i] = 0;
				}
			}
#endif
			//-------------------------------------------------------------- _ignore_bug_fix_0x00000000 >

			DefaultItemCount++;
			//다음 파일 찾음
			if ( FindNextFile( hFindHandle , &fd )==FALSE ) break;
			if ( DefaultItemCount>=DEF_ITEM_MAX ) break;
		}
	}
	FindClose( hFindHandle );

/*
	FILE *fp;
	fp = fopen( "Def_Item.dat" , "wb" );
	if ( fp ) {
		fwrite( DefaultItems , sizeof(sDEF_ITEMINFO) * DefaultItemCount , 1 , fp );
		fclose( fp );
	}
*/
	return TRUE;
}

//필드에 연결된 정보 파일경로를 찾음
char *SetFieldInfoPath( char *SaveBuff , char *szFieldPath , char *InfoExt )
{
	int cnt;
	int len;
	char *szFile;

	len = lstrlen( szFieldPath );
	cnt = len-1;

	szFile = szFieldPath;

	while(cnt>0) {
		if ( szFieldPath[cnt]=='\\' ) {
			szFile = &szFieldPath[cnt+1];
			break;
		}
		cnt--;
	}

	wsprintf( SaveBuff , "%s%s.%s" , szFieldInfoPath , szFile , InfoExt );

	return SaveBuff;
}


DWORD	dwServ_GameTimeHour;			//서버내의 시간
DWORD	dwServ_NightDay;				//밤낮의 변화

//서버에서의 시스템 시간을 게임시간으로 변경
DWORD	GetGameTimeHour() 
{
	DWORD	dwTime;

	dwTime = GetCurrentTime()-dwOffsetTime;
	dwTime = ( dwTime / GAME_WORLDTIME_MIN )/60;
	dwTime = dwTime-(((int)(dwTime/24))*24);			//게임내부에서의 시

	return dwTime;
}

//유저 카운터 실제 변환
int rsGetUserCounter( int Counter )
{
	return Counter;
/*
	int cnt;
	int ps;
	int ds;
	int top;
	int max;



	if ( !AutoPlayServer && !UserPlayServer ) {
		top = 2000;
		max = 100;
	}
	else {
		top = 500;
		max = 10;
	}

	if ( Counter>top ) {
		ps = (Counter*((Counter-top)/AccountPerl))/100;
		if ( ps>max ) ps=max;
		ds = ps/20;
		cnt = Counter+ps;
		if ( ds )
			cnt +=rand()%ds;
	}
	else
		cnt = Counter;

	return cnt;
*/
}

//FIELD_EVENT_NIGHTMARE




#define START_POINT_MAX			8
#define START_POINT_MASK		(START_POINT_MAX-1)

POINT	StartPointNpc[START_POINT_MAX] = {
	{ 1692 , -584 },
	{ 34 , -618 },
	{ -741 , 877 },
	{ 1000 , 1000 }
};

POINT	StartPoint[START_POINT_MAX] = {
	{	-1500,	-2800 },
	{	600,	-3200 },
	{	840,	-4000 },
	{	-90,	-5000 },
	{	-900,	-6500 },
	{	-1600,	-7100 },
	{	-3000,	-7200 },
	{	400,	-6100 }
};



int StartPointCnt = 0;



//발생한 아이템 기록정보를 찾아서 설정
int	rsLoadCreateItemToHDD( psITEM	*lpItem , char *szFileCode );
//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
int	rsSaveCreateItemToHDD( psITEM	*lpItem );
//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
int	rsSaveAgingItemToHDD( sITEMINFO *lpItem );




//캐릭터를 찾는다 ( 나중에 빨리 칮을수 있게 코드화 시켜 바꿔 줘야 함 )
rsPLAYINFO *srFindUserFromSerial( DWORD dwObjectSerial )
{
	int cnt;

	if ( dwObjectSerial==0 ) return NULL;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial==dwObjectSerial ) {
			return &rsPlayInfo[cnt];
		}
	}

	return NULL;
}

//캐릭터를 찾는다 ( 나중에 빨리 칮을수 있게 코드화 시켜 바꿔 줘야 함 )
smCHAR *srFindCharFromSerial( DWORD dwObjectSerial )
{
	int cnt;

	if ( dwObjectSerial==0 ) return NULL;

	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].dwObjectSerial==dwObjectSerial &&
			chrAutoPlayer[cnt].Flag ) {

			return &chrAutoPlayer[cnt];
		}
	}

	return NULL;
}

//해당 필드에서 캐릭터를 찾는다
smCHAR *srFindCharFromSerial( DWORD dwObjectSerial , int AreaNum )
{
	//STG_AREA	*StageArea;				//Stg_Area 선언
	int cnt;
	STG_AREA *lpStgArea;


	if ( dwObjectSerial && AreaNum<STAGE_AREA_MAX && StageArea[AreaNum].lpStage ) {
		lpStgArea = &StageArea[AreaNum];

		for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]->dwObjectSerial==dwObjectSerial ) {
				return lpStgArea->lpCharMonster[cnt];
			}
		}
	}

	return NULL;
}


//캐릭터를 찾는다 ( 나중에 빨리 칮을수 있게 코드화 시켜 바꿔 줘야 함 )
smCHAR *srFindEmptyChar()
{
	int cnt;

	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( !chrAutoPlayer[cnt].Flag ) {
			return &chrAutoPlayer[cnt];
		}
	}

	return NULL;
}


//기본 아이템 설정 (유니크 아이템 제외)
int srSetItemFromCode( psITEM *lpsItem , char *szCoed )
{
	int cnt;
	DWORD dwCode;
	DWORD dwCodeMask1,dwCodeMask2;

	for(cnt=0;cnt<MAX_ITEM;cnt++) {
		if ( lstrcmpi( szCoed , sItem[cnt].LastCategory )==0 ) {
			dwCode = sItem[cnt].CODE; break; }
	}

	if ( cnt>=MAX_ITEM ) return FALSE;

	for(cnt=0;cnt<DefaultItemCount;cnt++) {
		if ( DefaultItems[cnt].Item.CODE==dwCode && !DefaultItems[cnt].Item.UniqueItem ) {
			CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt] , spJobCode , spItemNormal );

			//시간제 아이템 날짜보정 생성
			if ( spTimeAdjust ) {
				dwCodeMask1 = lpsItem->ItemInfo.CODE&sinITEM_MASK2;
				dwCodeMask2 = lpsItem->ItemInfo.CODE&sinITEM_MASK3;
				if ( (dwCodeMask1==sinDA1 || dwCodeMask1==sinDA2) && dwCodeMask2>=sin31 ) {
					ReformItem_AdjustTime( &lpsItem->ItemInfo , spTimeAdjust );
				}
			}

			//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
			rsSaveCreateItemToHDD( lpsItem );
			return TRUE;
		}
	}
//

	return FALSE;
}


//기본 아이템 이름으로 찾아 설정
int srSetItemFromName( psITEM *lpsItem , char *szItemName )
{
	int cnt;

	for(cnt=0;cnt<DefaultItemCount;cnt++) {
		if ( lstrcmpi( DefaultItems[cnt].Item.ItemName , szItemName )==0 ) {
			CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt] , spJobCode , spItemNormal );
			//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
			rsSaveCreateItemToHDD( lpsItem );
			return TRUE;
		}
	}

	return FALSE;
}

//이전에 생성된 아이템 코드를 찾아 설정
int srSetItemFromLogData( psITEM *lpsItem , char *LogFileCode )
{
	//발생한 아이템 기록정보를 찾아서 설정
	return rsLoadCreateItemToHDD(lpsItem , LogFileCode );
}


//NPC 상점 아이템코드를 아이템 리스트로 연결
int srLinkNpcItem( smCHAR *lpChar )
{
	int cnt,cnt2;
	DWORD	dwCode;

	for( cnt=0;cnt<lpChar->smMonsterInfo.SellAttackItemCount;cnt++) {
		dwCode = (DWORD)lpChar->smMonsterInfo.SellAttackItem[cnt];
		lpChar->smMonsterInfo.SellAttackItem[cnt] = 0;
		for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
			if ( !DefaultItems[cnt2].Item.UniqueItem && dwCode==DefaultItems[cnt2].Item.CODE ) {
				lpChar->smMonsterInfo.SellAttackItem[cnt] = &DefaultItems[cnt2];
				break;
			}
		}
	}

	for( cnt=0;cnt<lpChar->smMonsterInfo.SellDefenceItemCount;cnt++) {
		dwCode = (DWORD)lpChar->smMonsterInfo.SellDefenceItem[cnt];
		lpChar->smMonsterInfo.SellDefenceItem[cnt] = 0;
		for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
			if ( !DefaultItems[cnt2].Item.UniqueItem && dwCode==DefaultItems[cnt2].Item.CODE ) {
				lpChar->smMonsterInfo.SellDefenceItem[cnt] = &DefaultItems[cnt2];
				break;
			}
		}
	}

	for( cnt=0;cnt<lpChar->smMonsterInfo.SellEtcItemCount;cnt++) {
		dwCode = (DWORD)lpChar->smMonsterInfo.SellEtcItem[cnt];
		lpChar->smMonsterInfo.SellEtcItem[cnt] = 0;
		for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
			if ( !DefaultItems[cnt2].Item.UniqueItem && dwCode==DefaultItems[cnt2].Item.CODE ) {
				lpChar->smMonsterInfo.SellEtcItem[cnt] = &DefaultItems[cnt2];
				break;
			}
		}
	}
	return TRUE;
}

//기본 아이템 설정
int srGetRandomItem( psITEM *lpsItem )
{

	int	rnd;

	ZeroMemory( lpsItem , sizeof( sITEMINFO ) );

	if ( ((GetCurrentTime()>>4)&0x3)==0 ) {
		rnd = GetRandomPos( 1 , 100 );
		lpsItem->ItemInfo.CODE = sinGG1|sin01;			//돈이다
		wsprintf( lpsItem->ItemInfo.ItemName , sinGold , rnd );
		lpsItem->ItemInfo.Money = rnd;
		ReformItem( &lpsItem->ItemInfo );						//아이템 인증
	}
	else {
		rnd = rand()%DefaultItemCount;
		if ( DefaultItems[rnd].Item.UniqueItem ) return FALSE;
		CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[rnd] );
	}


	return TRUE;
}

#define	OS_TRAN	(sinOS1|sin06)
#define	OS_MUKY	(sinOS1|sin07)
#define	OS_DEBI	(sinOS1|sin08)
#define	OS_ALL	(sinOS1|sin12)

//모리프 제한 필드 아이템
DWORD	dwMorifFieldItem[] = {
	//0		1		2		3
	OS_TRAN,	OS_TRAN,	OS_TRAN,	OS_TRAN,	
	//4		5		6		7
	OS_TRAN,	OS_TRAN,	OS_TRAN,	OS_TRAN,	
	//8		9		10		11
	OS_TRAN,	OS_MUKY,	OS_MUKY,	OS_MUKY,	
	//12		13		14		15
	OS_DEBI ,	OS_MUKY,	OS_MUKY,	OS_DEBI ,	
	//16		17		18		19
	OS_TRAN,	OS_TRAN,	OS_TRAN,	OS_TRAN,	
	//20		21		22		23
	OS_TRAN,	OS_TRAN,	OS_ALL , 	OS_ALL ,	
	//24		25		26		27
	OS_DEBI,	OS_DEBI,	OS_ALL ,	OS_ALL ,	
	//28		29		30		31
	OS_ALL,		OS_TRAN,	OS_TRAN,	OS_ALL,	
	//32		33		34		35
	OS_TRAN,	OS_TRAN,	OS_TRAN,	OS_TRAN
};

//모리프 아이템 필드
int	srCheckMorifItemField( DWORD dwItemCode , STG_AREA *lpStgArea )
{

	DWORD	dwItemCodeMask = dwItemCode&sinITEM_MASK3;

	if ( !lpStgArea || !lpStgArea->lpField ) return FALSE;

	DWORD	dwAreaCode = lpStgArea->lpField->FieldCode;

	if ( dwAreaCode>=0 && dwAreaCode<36 ) {

		if ( dwMorifFieldItem[dwAreaCode]==OS_ALL && dwItemCodeMask<sin05 )	//전체드롭 필드의 경우 os105 이상만 나오게 해달라고 함
			return FALSE;

		if ( dwItemCodeMask>(dwMorifFieldItem[dwAreaCode]&sinITEM_MASK3) ) 
			return FALSE;
	}

	return TRUE;
}



//몬스터에서 나오는 아이템 설정
int srGetMonsterItem( rsPLAYINFO *lpPlayInfo , smCHAR *lpChar , psITEM *lpsItem )
{

	int	rnd;
	int cnt,cnt2;
	int rcnt;
	DWORD dwCode;
	smCHAR_MONSTER_INFO *lpMonInfo = &lpChar->smMonsterInfo;
	STG_AREA *lpStgArea;

	ZeroMemory( lpsItem , sizeof( sITEMINFO ) );

	if ( lpMonInfo->FallItemPerMax==0 || lpMonInfo->FallItemCount==0 ) return FALSE;

	////////////////// 송편 이벤트 ////////////////////////////
	if ( rsServerConfig.Event_Mandoo ) {
		rnd = rand()%100;
		dwCode = 0;

		if ( rnd<4 ) {	//4%
			//물만두 ( 보통송편 )
			dwCode = (sinSP1|sin01);
		}
		else {	//2%
			if ( rnd<6 ) {
				//왕만두 ( 큰송편 )
				dwCode = (sinSP1|sin02);
			}
		}

		if ( dwCode ) {
			//아이템 나오기
			for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
				if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
					CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
					return TRUE;
				}
			}
		}
	}

	////////////////// 발렌타인데이 이벤트 ////////////////////////////
	if ( rsServerConfig.Event_ValentineDay ) {
		rnd = rand()%10000;
		cnt = abs(lpPlayInfo->smCharInfo.Level-lpChar->smCharInfo.Level);

		if ( cnt>15 || (lpChar->smCharInfo.Level<20 && cnt>8 ) ) {
			rnd = rsServerConfig.Event_ValentineDay;		//레벨차 많이 나서
		}

		if ( rnd<rsServerConfig.Event_ValentineDay ) {
			dwCode = 0;
			rnd = rand()%10;
			if ( rnd<7 ) {
				//초콜렛 
				dwCode = (sinCH1|sin01);
//태국수정
#ifdef _LANGUAGE_THAI_RING
				dwCode = (sinOR2|sin01);
#endif
#ifdef _LANGUAGE_JAPANESE_RING
				dwCode = (sinOR2|sin01);
#endif
			}
			else {
				//초콜렛 
				dwCode = (sinCH1|sin02);
#ifdef _LANGUAGE_THAI_RING
				dwCode = (sinOR2|sin01);
#endif
#ifdef _LANGUAGE_JAPANESE_RING
				dwCode = (sinOR2|sin01);
#endif
			}

			if ( dwCode ) {
				//아이템 나오기
				for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
					if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
						CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
						return TRUE;
					}
				}
			}
		}
	}

	////////////////// 화이트데이 이벤트 ////////////////////////////
	if ( rsServerConfig.Event_WhiteDay ) {
		rnd = rand()%10000;
		cnt = abs(lpPlayInfo->smCharInfo.Level-lpChar->smCharInfo.Level);

		if ( cnt>15 || (lpChar->smCharInfo.Level<20 && cnt>8 ) ) {
			rnd = rsServerConfig.Event_WhiteDay;			//레벨차 많이 나서
		}

		if ( rnd<rsServerConfig.Event_WhiteDay ) {
			dwCode = 0;
			rnd = rand()%10;
			if ( rnd<7 ) {
				//초콜렛 
				dwCode = (sinCH1|sin03);
			}
			else {
				//초콜렛 
				dwCode = (sinCH1|sin04);
			}

			if ( dwCode ) {
				//아이템 나오기
				for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
					if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
						CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
						return TRUE;
					}
				}
			}
		}
	}

	//////////////////// 퍼즐 맞추기 이벤트 ///////////////////////
	if ( rsServerConfig.Event_Puzzle && (rand()%10000)<rsServerConfig.Event_Puzzle ) {

		//퍼즐 아이템 생성 유무
		dwCode = rsOpenEventPuzzleItem( lpPlayInfo , lpChar );

		if ( dwCode ) {
			//아이템 나오기
			for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
				if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
					CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
					return TRUE;
				}
			}
		}
	}
//////////////////// 구미호 이벤트 ///////////////////////
	if ( rsServerConfig.Event_NineFox ) {

		rnd = rand()%10000;
		cnt = abs(lpPlayInfo->smCharInfo.Level-lpChar->smCharInfo.Level);
		cnt2 = rsServerConfig.Event_NineFox;

		if ( cnt>15 || (lpChar->smCharInfo.Level<20 && cnt>10 ) ) {
			rnd = cnt2;			//레벨차 많이 나서
		}
		else {
			if ( lpPlayInfo->smCharInfo.Level<20 ) {			//레벨 이하 드롭 확률 낮게
				cnt2=(rsServerConfig.Event_NineFox*40)/100;
			}
			else if ( lpPlayInfo->smCharInfo.Level<40 ) {		//레벨 이하 드롭 확률 낮게
				cnt2=(rsServerConfig.Event_NineFox*60)/100;
			}
			else if ( lpPlayInfo->smCharInfo.Level<60 ) {		//레벨 이하 드롭 확률 낮게
				cnt2=(rsServerConfig.Event_NineFox*80)/100;
			}
		}

		if ( rnd<cnt2 ) {
			//구미호목걸이 아이템 생성 유무
			if ( (rand()%2)==0 )
				dwCode = (sinGF1|sin03);
			else
				dwCode = (sinGF1|sin04);

			if ( dwCode ) {
				//아이템 나오기
				for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
					if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
						CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
						return TRUE;
					}
				}
			}
		}
	}
	//////////////////////////////////////크리스마스
	if ( rsServerConfig.EVENT_Christmas ) {
		
		rnd = rand()%10000;
		cnt = abs(lpPlayInfo->smCharInfo.Level-lpChar->smCharInfo.Level);
		cnt2 = rsServerConfig.EVENT_Christmas;

		if(cnt < 10 ) {
			cnt2 = rsServerConfig.EVENT_Christmas;
		}
		
		if ( cnt< 10 ) {			//렙차 10 이하일때 확률 보정 
				cnt2 = (rsServerConfig.EVENT_Christmas*30)/100;
		}

		if ( rnd<cnt2 ) {
			//빛나는 가루 생성여부 
				dwCode = (sinGF1|sin05);
			if( cnt > 10){dwCode = 0;}	//렙차가 10이상일때  패쓰

			if ( dwCode ) {
				//아이템 나오기
				for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
					if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
						CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
						return TRUE;
					}
				}
			}
		}	
	}

	// pluto 선물상자
	if( rsServerConfig.Event_GiftBox )
	{
		rnd = rand()%10000;
		cnt = abs(lpPlayInfo->smCharInfo.Level - lpChar->smCharInfo.Level);

		if ( cnt>15 || (lpChar->smCharInfo.Level<20 && cnt>8 ) )
		{
			rnd = rsServerConfig.Event_GiftBox;			//레벨차 많이 나서
		}

		if ( rnd<rsServerConfig.Event_GiftBox )
		{
			dwCode = 0;
			if( lpChar->smCharInfo.Level >= 1 && lpChar->smCharInfo.Level < 20 )
			{
				dwCode = (sinSP1|sin10);			// pluto 선물상자 6등급 
			}
			else if( lpChar->smCharInfo.Level >= 20 && lpChar->smCharInfo.Level < 40 )
			{
				dwCode = (sinSP1|sin09);			// pluto 선물상자 5등급 
			}
			else if( lpChar->smCharInfo.Level >= 40 && lpChar->smCharInfo.Level < 60 )
			{
				dwCode = (sinSP1|sin08);			// pluto 선물상자 4등급 
			}
			else if( lpChar->smCharInfo.Level >= 60 && lpChar->smCharInfo.Level < 80 )
			{
				dwCode = (sinSP1|sin07);			// pluto 선물상자 3등급 
			}
			else if( lpChar->smCharInfo.Level >= 80 && lpChar->smCharInfo.Level < 100 )
			{
				dwCode = (sinSP1|sin06);			// pluto 선물상자 2등급 
			}
			else if( lpChar->smCharInfo.Level >= 100 )
			{
				dwCode = (sinSP1|sin05);			// pluto 선물상자 1등급 
			}

			if ( dwCode )
			{
				//아이템 나오기
				for(cnt2=0;cnt2<DefaultItemCount;cnt2++)
				{
					if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem )
					{
						CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
						return TRUE;
					}
				}
			}
		}
	}
	////////////////// 횡스크롤필드 ////////////////////////////
	if ( lpPlayInfo->Position.Area==rsACTION_FIELD )
	{
		rnd = rand()%10000;

		if ( rnd<150 ) {
			dwCode = (sinGF1|sin02);		//역겨운 진액
			//아이템 나오기
			for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
				if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
					CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
					return TRUE;
				}
			}
		}
	}


	/////////////////////////////////////////////////////////////////

	//저 레벨용 아이템 우연히 자동 생성하기
	dwCode = rsLowLevelItem( lpPlayInfo , lpChar );
	if ( dwCode ) {
		//아이템 나오기
		for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
			if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
				CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] , lpPlayInfo->smCharInfo.JOB_CODE );
				return TRUE;
			}
		}
	}


	//rnd = (rand()%lpMonInfo->FallItemPerMax);
	rnd = (rand()<<7)|((GetCurrentTime()>>2)&0x7F);
	rnd = rnd%lpMonInfo->FallItemPerMax;

	if ( !rsServerConfig.AreaServer.IP_Count ) {		//1개짜리 서버인경우 아이템 수치 조정 (1%)
		if ( !lpMonInfo->FallItems[0].dwItemCode && (rand()%1000)<10 ) return FALSE;
	}

	rcnt = 0;
	for(cnt=0;cnt<lpMonInfo->FallItemCount;cnt++) {
		if ( rnd>=rcnt && rnd<(rcnt+lpMonInfo->FallItems[cnt].Percentage) ) {
			if ( !lpMonInfo->FallItems[cnt].dwItemCode ) return FALSE;			//안 나온다

			if ( lpMonInfo->FallItems[cnt].dwItemCode==(sinGG1|sin01) ) {			//돈 나온다
				rnd = GetRandomPos( lpMonInfo->FallItems[cnt].sPrice[0] , lpMonInfo->FallItems[cnt].sPrice[1] );
				lpsItem->ItemInfo.CODE = sinGG1|sin01;			//돈이다
				wsprintf( lpsItem->ItemInfo.ItemName , sinGold , rnd );
				lpsItem->ItemInfo.Money = rnd;
				ReformItem( &lpsItem->ItemInfo );						//아이템 인증
				rsMoneyTotalCount += rnd;								//돈 발생 금액 기록
				return TRUE;
			}

			dwCode = lpMonInfo->FallItems[cnt].dwItemCode;

			//아이템 나오기
			for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
				if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {

					/////////////////////// 모리프 아이템 ///////////////////////
					if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_NPC_MORIF && ( (dwCode&sinITEM_MASK2)==sinOS1 || (dwCode&sinITEM_MASK2)==sinFO1 )) {
						//모리프 아이템 필드별 발생제한
						if ( srCheckMorifItemField( dwCode , (STG_AREA *)lpChar->lpExt1 )==FALSE )
							return FALSE;
					}
					if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_NPC_MOLLYWOLF && (dwCode&sinITEM_MASK2)==sinFO1 ) {
						//모리프울프 ( 숲 필드에서는 포스 안나오게 )
						lpStgArea = (STG_AREA *)lpChar->lpExt1;
						if ( lpStgArea->lpField && lpStgArea->lpField->State==FIELD_STATE_FOREST )
							return FALSE;
					}
					/////////////////////////////////////////////////////////////

					if ( DefaultItems[cnt2].sGenDay[0]>0 ) {
						//하루 발생할수 있는 아이템 제한확인
						if ( DefaultItems[cnt2].sGenDay[0]<=DefaultItems[cnt2].sGenDay[1] ) {
							return FALSE;
						}
						else {
							DefaultItems[cnt2].sGenDay[1]++;		//아이템 발생 카운터 증가
						}
					}
					CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );

					//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
					rsSaveCreateItemToHDD( lpsItem );
					rsItemOpenCount ++;					//아이템 발생 기록
					return TRUE;
				}
			}
			return FALSE;
		}
		rcnt += lpMonInfo->FallItems[cnt].Percentage;
	}

	return FALSE;
}





DWORD ObjectSerialCnt = 0x2000;

//캐릭터 고유 코드를 생성
DWORD GetNewObjectSerial()
{
	DWORD	code;

	code = (ObjectSerialCnt&0x0FFFFFFF)|(rsServerConfig.ServerCode<<28);

	ObjectSerialCnt++;

	return code;
}


//랜덤으로 몬스터 설정해줌
smCHAR_INFO *SetMonsterModelRandom( smCHAR_INFO *lpCharInfo )
{
	smCHAR_INFO *lpInfo;

	lpInfo = &chrMonsterList[(rand()%chrMonsterCnt)];
	memcpy( lpCharInfo , lpInfo  , sizeof( smCHAR_INFO ) );

	return lpInfo;
}








STG_AREA	*StageArea;				//Stg_Area 선언


/////////////////////////////////// 이벤트 ////////////////////////////////////////

//이벤트 몬스터 변환
int OpenEventMonster( smCHAR_INFO *lpCharInfo , STG_AREA *lpStgArea )
{
	int cnt;
	int MonCnt;

	//킹호피 이벤트
	if (lpCharInfo->dwCharSoundCode==snCHAR_SOUND_HOPT ) {
		if ( (rand()%100)>30 ) return FALSE;

		MonCnt = 0;
		for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpStgArea->lpCharMonster[cnt] ) {
				if ( lpStgArea->lpCharMonster[cnt]->smCharInfo.dwCharSoundCode==snCHAR_SOUND_HOPYKING ) {
					MonCnt++;
				}
			}
		}
		if ( MonCnt>=40 ) return FALSE;			//호피가 40마리 이상 출현 중

		for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
			if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_HOPYKING ) {
				memcpy( lpCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) );
				break;
			}
		}
	}


	return TRUE;
}

//몬스터 크리스탈로 몬스터 출현 시킴
int	OpenMonsterFromCristal( DWORD dwItemCode , int x, int y, int z , rsPLAYINFO *lpPlayInfo )
{
#ifdef _W_SERVER

	STG_AREA	*lpStgArea;
	STG_CHAR_INFO StgCharInfo;
	smCHAR	*lpChar;
	srCRISTAL_MONSTER	*lpCristalMonster;
	int cnt,cnt2;
	int height,dx,dy,dz,ta;
	int	CodeCount;
	int	RndCnt,RndNum;
	int	ClanCnt;
	TRANS_CHATMESSAGE	TransChatMessage;
	int	sx,sy,sz,dist;
	int	MyMonFlag;
	int CastleFlag = 0;
	int	BlessSolderCnt[3];
	int BlessCristalCode;
	int	BillingCrystalFlag = 0;

	CodeCount = ((dwItemCode&0xFFFF)>>8)-1;

	if ( CodeCount==srCRISTAL_RANDOM ) {
		//랜덤 크리스탈
		CodeCount = 0;

		RndNum = rand()%100;
		RndCnt = 0;
		for( cnt=0;cnt<srCRISTAL_RANDOM;cnt++ ) {
			if ( srCristalMonster[CodeCount].RndCount ) {
				RndCnt += srCristalMonster[cnt].RndCount;
				if ( RndNum<RndCnt ) {
					CodeCount = cnt;
					break;
				}
			}
		}
	}

	// pluto 마벨 크리스탈
	if( CodeCount == srCRISTAL_MARVEL_RANDOM )
	{
		CodeCount = 0;
		RndNum = rand()%100;
		RndCnt = 0;
		for( cnt = 0; cnt < MARVELCRISTAL_MAX; cnt++ )
		{
			if( srMarvelCristalMonster[CodeCount].RndCount )
			{
				RndCnt += srMarvelCristalMonster[cnt].RndCount;
				if( RndNum < RndCnt )
				{
					CodeCount = cnt;
					break;
				}
			}
		}
	}

	if ( rsCristalEvent )
		lpCristalMonster = &srCristalMonsterBoss[CodeCount];
	else if( srCRISTAL_MARVEL_RANDOM == ((dwItemCode&0xFFFF)>>8)-1 )		// pluto 마벨 크리스탈
	{
		lpCristalMonster = &srMarvelCristalMonster[CodeCount];
	}
	else if( ((dwItemCode&0xFFFF)>>8)-1 == srCRISTAL_G_DIVINE_CLAN )			// pluto 가디안 디바인
	{
		lpCristalMonster = &srMarvelCristalMonster[srCRISTAL_MAX-1];
	}
	else
		lpCristalMonster = &srCristalMonster[CodeCount];

	//빌링용 크리스탈
	switch( CodeCount ) {
		case srCRISTAL_SKELETON:
			lpCristalMonster = &srBillingCrystalMonster[(rand()%srBC_MONSTER_MAX)];
			BillingCrystalFlag = TRUE;
			break;
		case srCRISTAL_KAOS:
			lpCristalMonster = &srBillingCrystalMonster[(rand()%srBC_MONSTER_MAX)+srBC_MONSTER_MAX];
			BillingCrystalFlag = TRUE;
			break;
		case srCRISTAL_IMPERNA:
			lpCristalMonster = &srBillingCrystalMonster[(rand()%srBC_MONSTER_MAX)+srBC_MONSTER_MAX*2];
			BillingCrystalFlag = TRUE;
			break;
		case srCRISTAL_EXTREME:		// pluto 익스트림 크리스탈
			int code = 12;
			RndNum = rand()%100;
			RndCnt = 0;
			for( cnt=srBC_MONSTER_MAX*3;cnt<srBC_MONSTER_MAX*3+4;cnt++ )
			{
				if ( srBillingCrystalMonster[code].RndCount )
				{
					RndCnt += srBillingCrystalMonster[cnt].RndCount;
					if ( RndNum<RndCnt )
					{
						code = cnt;
						break;
					}
				}
			}
			lpCristalMonster = &srBillingCrystalMonster[code];
			BillingCrystalFlag = TRUE;
			break;
	}

	if ( !lpCristalMonster->lpCharInfo ) return FALSE;

	lpStgArea = FindStageField( x, z );
	if ( lpStgArea ) {
		if ( lpStgArea->lpField->State==FIELD_STATE_VILLAGE ) return FALSE;
		if ( CodeCount>=srCRISTAL_CASTLE_START && CodeCount<srCRISTAL_CASTLE_END) {
			//블레스 캐슬
			if ( !rsBlessCastle.CastleMode || !lpPlayInfo->dwClanCode || lpPlayInfo->dwClanCode!=rsBlessCastle.dwMasterClan || lpPlayInfo->Position.Area!=rsCASTLE_FIELD ) {
				//성주 클랜이 아니거나 사용할수 없는 위치
				TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lstrcpy( TransChatMessage.szMessage , srMsg_202 );
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);

				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				return -1;
			}

			ClanCnt = 0;
			MyMonFlag = 0;
			BlessSolderCnt[0] = 0;
			BlessSolderCnt[1] = 0;
			BlessSolderCnt[2] = 0;
			for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
				if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]->dwClanCode==lpPlayInfo->dwClanCode ) {
					if ( lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0]>0 && lpStgArea->lpCharMonster[cnt]->smCharInfo.Next_Exp ) {
						ClanCnt++;
						if ( lpStgArea->lpCharMonster[cnt]->smCharInfo.Next_Exp==lpPlayInfo->dwObjectSerial ) 
							MyMonFlag++;
						switch( lpStgArea->lpCharMonster[cnt]->smCharInfo.dwCharSoundCode ) {
						case snCHAR_SOUND_CASTLE_SOLDER_A:
							BlessSolderCnt[0]++;
							break;
						case snCHAR_SOUND_CASTLE_SOLDER_B:
							BlessSolderCnt[1]++;
							break;
						case snCHAR_SOUND_CASTLE_SOLDER_C:
							BlessSolderCnt[2]++;
							break;

						}
					}
				}
			}

			BlessCristalCode = 0;

			switch( dwItemCode ) {
				case sinGP1|sin14:	
					BlessCristalCode = 0;
					break;
				case sinGP1|sin15:	
					BlessCristalCode = 1;
					break;
				case sinGP1|sin16:	
					BlessCristalCode = 2;
					break;
			}


			if ( ClanCnt>=srCASLTE_SOLDER_CLAN_MAX || MyMonFlag>=srCASLTE_SOLDER_MAX || BlessSolderCnt[BlessCristalCode]>=srCASLTE_SOLDER_KIND_MAX ) {
				//최대 개수 초과
				TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lstrcpy( TransChatMessage.szMessage , srMsg_200 );
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);

				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				return -1;
			}

			CastleFlag = TRUE;
		}

		if ( CodeCount==srCRISTAL_CLAN ) {
			if ( !lpPlayInfo->smCharInfo.ClassClan ) return FALSE;		//클랜 크리스탈 ( 클랜원 전용 )
			ClanCnt = 0;
			MyMonFlag = 0;
			for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
				if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]->smCharInfo.ClassClan==lpPlayInfo->smCharInfo.ClassClan ) {
					sx = ( lpPlayInfo->Position.x - lpStgArea->lpCharMonster[cnt]->pX )>>FLOATNS;
					sy = ( lpPlayInfo->Position.y - lpStgArea->lpCharMonster[cnt]->pY )>>FLOATNS;
					sz = ( lpPlayInfo->Position.z - lpStgArea->lpCharMonster[cnt]->pZ )>>FLOATNS;
					dist = sx*sx+sy*sy+sz*sz;
					if ( dist<DIST_TRANSLEVEL_LOW )	ClanCnt++;
					if ( lpStgArea->lpCharMonster[cnt]->smCharInfo.Next_Exp==lpPlayInfo->dwObjectSerial ) 
						MyMonFlag++;
				}
			}

			if ( ClanCnt>(srCLAN_MONSTER_MAX-1) ) {
				TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lstrcpy( TransChatMessage.szMessage , srMsg_200 );
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);

				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				return -1;
			}

			if ( MyMonFlag ) {
				TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lstrcpy( TransChatMessage.szMessage , srMsg_201 );
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);

				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				return -1;
			}
		}

		for(cnt=0;cnt<8;cnt++) {
			cnt2 = rand()%8;
			dx = x+(ptItemSettingPosi[ cnt2&7 ].x<<(FLOATNS+1));
			dz = z+(ptItemSettingPosi[ cnt2&7 ].y<<(FLOATNS+1));
			dy = y;
			cnt2++;

			//현재 위치에서의 바닥 높이를 구한다
			height = lpStgArea->lpStage->GetFloorHeight( dx, dy , dz , 32*fONE );
			if ( height!=CLIP_OUT ) {
				//이미 위치에 존재함
				ta = abs( height - dy );
				if ( ta<32*fONE ) {
					break;
				}
			}
		}
		if ( cnt<8 ) {
			x = dx;
			z = dz;
			y = height;
		}

		StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;

		memcpy(	&StgCharInfo.smCharInfo , lpCristalMonster->lpCharInfo , sizeof( smCHAR_INFO ) ); 

		lpStgArea->EvnMonster = TRUE;
		lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
		if ( lpChar ) {
			lpChar->pX = x;
			lpChar->pY = y;
			lpChar->pZ = z;
			lpChar->DistAroundDbl = 0;
			lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
			lpChar->TargetMoveCount = 0;
			if ( lpPlayInfo ) {
				lstrcpy( lpChar->smCharInfo.szModelName2+1 , lpPlayInfo->smCharInfo.szName );	//주인 이름
				lpChar->smCharInfo.Next_Exp = lpPlayInfo->dwObjectSerial;						//주인 시리얼 코드 저장

				if ( CastleFlag ) {
					//용병 (물약 최대치)
					lpChar->smMonsterInfo.PotionCount = StgCharInfo.smCharInfo.lpMonInfo->PotionCount;
					lpChar->dwClanCode = rsBlessCastle.dwMasterClan;	//클랜 설정
				}
				else {
					lpChar->lpMasterPlayInfo = lpPlayInfo;
					lpChar->smMonsterInfo.dwAutoCharCode = 0;
					lpChar->dwUpdateCharInfoTime = dwPlayServTime+4*60*1000;						//4분후 제거
					lpChar->smCharInfo.Brood = smCHAR_MONSTER_USER;		//몬스터 종족 (유저편)

					if ( lpPlayInfo->smCharInfo.Level>0 && lpPlayInfo->smCharInfo.Level<100 ) {
						//레벨 비례 몬스터 시간,체력 강화
						lpChar->dwUpdateCharInfoTime+=lpPlayInfo->smCharInfo.Level*1000*2;
						lpChar->smCharInfo.Life[1] += lpPlayInfo->smCharInfo.Level*3;
						lpChar->smCharInfo.Life[0] = lpChar->smCharInfo.Life[1];
					}

					if ( CodeCount==srCRISTAL_CLAN )
						lpChar->smCharInfo.ClassClan = lpPlayInfo->smCharInfo.ClassClan ;	//클랜 설정

					lpChar->Clan_CastleMasterFlag = BillingCrystalFlag;
				}

				smTRANS_COMMAND_EX	TransCommandEx;

				ZeroMemory( &TransCommandEx , sizeof(smTRANS_COMMAND_EX) );
				TransCommandEx.WParam = smCOMMNAD_USER_WARP;
				TransCommandEx.LParam = x;
				TransCommandEx.SParam = y;
				TransCommandEx.EParam = z;
				rsSendCommandUser( lpPlayInfo , &TransCommandEx );			//이펙트 호출
			}

			return TRUE;
		}
	}
#endif
	return FALSE;
}

/*
#define	srSKILL_MONSTER_MAX		3
//스킬소환 몬스터
srCRISTAL_MONSTER	srSkillMonster[srSKILL_MONSTER_MAX] = {
*/


smCHAR *rsGetLinkChar( smCHAR *lpMasterChar )
{
	int cnt;

	//이미 소환된 몹 있으면 제거
	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag && 
			lpMasterChar!=&chrAutoPlayer[cnt] &&
			chrAutoPlayer[cnt].lpLinkChar==lpMasterChar &&
			chrAutoPlayer[cnt].smCharInfo.Life[0]>0	) {

				if ( !lpMasterChar->lpLinkPlayInfo || lpMasterChar->lpLinkPlayInfo==chrAutoPlayer[cnt].lpLinkPlayInfo )
					return &chrAutoPlayer[cnt];
			}
	}

	return NULL;
}

//스킬 소환몬스터 출현 시킴
smCHAR *OpenMonsterFromSkill( DWORD SkillCode , int x, int y, int z , rsPLAYINFO *lpPlayInfo , smCHAR *lpEnemyChar )
{
#ifdef _W_SERVER

	STG_AREA	*lpStgArea;
	STG_CHAR_INFO StgCharInfo;
	smCHAR	*lpChar;
	srCRISTAL_MONSTER	*lpCristalMonster=0;
	int cnt,cnt2;
	int height,dx,dy,dz,ta;

	switch( SkillCode ) {
		case SKILL_PLAY_METAL_GOLEM:
			lpCristalMonster = &srSkillMonster[0];
			break;
		case SKILL_PLAY_RECALL_WOLVERIN:
			lpCristalMonster = &srSkillMonster[1];
			break;
		case SKILL_PLAY_FIRE_ELEMENTAL:
			lpCristalMonster = &srSkillMonster[2];
			break;
	}

	if ( !lpCristalMonster->lpCharInfo ) return NULL;

	if ( lpPlayInfo ) {
		//이미 소환된 몹 있으면 제거
		for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
			if ( chrAutoPlayer[cnt].Flag && 
				chrAutoPlayer[cnt].lpMasterPlayInfo==lpPlayInfo && 
				chrAutoPlayer[cnt].HoSkillCode==SkillCode && 
				chrAutoPlayer[cnt].smCharInfo.Life[0]>0	) {

					chrAutoPlayer[cnt].smCharInfo.Life[0]=0;
					chrAutoPlayer[cnt].HoSkillCode = 0;
					chrAutoPlayer[cnt].SetMotionFromCode( CHRMOTION_STATE_DEAD );
			}
		}
	}

	lpStgArea = FindStageField( x, z );
	if ( lpStgArea ) {
		if ( lpStgArea->lpField->State==FIELD_STATE_VILLAGE ) return NULL;

		for(cnt=0;cnt<8;cnt++) {
			cnt2 = rand()%8;
			dx = x+(ptItemSettingPosi[ cnt2&7 ].x<<(FLOATNS+1));
			dz = z+(ptItemSettingPosi[ cnt2&7 ].y<<(FLOATNS+1));
			dy = y;
			cnt2++;

			//현재 위치에서의 바닥 높이를 구한다
			height = lpStgArea->lpStage->GetFloorHeight( dx, dy , dz , 32*fONE );
			if ( height!=CLIP_OUT ) {
				//이미 위치에 존재함
				ta = abs( height - dy );
				if ( ta<32*fONE ) {
					break;
				}
			}
		}
		if ( cnt<8 ) {
			x = dx;
			z = dz;
			y = height;
		}

		StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;

		memcpy(	&StgCharInfo.smCharInfo , lpCristalMonster->lpCharInfo , sizeof( smCHAR_INFO ) ); 

		lpStgArea->EvnMonster = TRUE;
		lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
		if ( lpChar ) {
			lpChar->pX = x;
			lpChar->pY = y;
			lpChar->pZ = z;
			lpChar->DistAroundDbl = 0;
			lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
			lpChar->TargetMoveCount = 0;

			smTRANS_COMMAND_EX	TransCommandEx;

			ZeroMemory( &TransCommandEx , sizeof(smTRANS_COMMAND_EX) );
			TransCommandEx.WParam = smCOMMNAD_USER_WARP;
			TransCommandEx.LParam = x;
			TransCommandEx.SParam = y;
			TransCommandEx.EParam = z;

			if ( lpPlayInfo && !lpEnemyChar ) {
				lpChar->lpMasterPlayInfo = lpPlayInfo;
				lpChar->smMonsterInfo.dwAutoCharCode = 0;
				lpChar->HoSkillCode = SkillCode;
				lpChar->HoSkillMode = 0;							//스킬공격모드 수동 기본옵션
				//lstrcat( lpChar->smCharInfo.szName , "[/]" );		//이름에 표시를..
				lpChar->smCharInfo.Brood = smCHAR_MONSTER_USER;		//몬스터 종족 (유저편)
				lstrcpy( lpChar->smCharInfo.szModelName2+1 , lpPlayInfo->smCharInfo.szName );	//주인 이름
				lpChar->smCharInfo.Next_Exp = lpPlayInfo->dwObjectSerial;						//주인 시리얼 코드 저장
				lpChar->dwUpdateCharInfoTime = dwPlayServTime+4*60*1000;						//4분후 제거

				lpPlayInfo->lpLinkChar = lpChar;							//소환 캐릭 포인터 코드 저장
				lpPlayInfo->dwLinkCharCode = lpChar->dwObjectSerial;

				rsSendCommandUser( lpPlayInfo , &TransCommandEx );			//이펙트 호출
			}

			if  ( lpEnemyChar && lpEnemyChar->lpLinkPlayInfo ) {
				lpChar->lpLinkPlayInfo=lpEnemyChar->lpLinkPlayInfo;
				lpChar->dwLinkObjectCode=lpEnemyChar->dwLinkObjectCode;
				lpChar->lpLinkChar = lpEnemyChar;
				lpChar->dwUpdateCharInfoTime = dwPlayServTime+5*60*1000;				//5 분후 제거

				if ( lpEnemyChar->lpLinkPlayInfo->lpsmSock )
					lpEnemyChar->lpLinkPlayInfo->lpsmSock->Send2( (char *)&TransCommandEx , TransCommandEx.size , TRUE );						//이펙트 호출
			}

			return lpChar;
		}
	}
#endif
	return NULL;
}

//퀘스트 대전 몬스터 출현 시킴
smCHAR *OpenMonster_QuestArena( rsPLAYINFO *lpPlayInfo , DWORD dwQuestCode , int Param=0 )
{
	STG_AREA	*lpStgArea;
	STG_CHAR_INFO StgCharInfo;
	int	len,cnt,pow;
	smCHAR	*lpChar;
	DWORD	dwSndCode;
	int		OpenLevel = 0;


	switch( dwQuestCode ) {
		case SIN_QUEST_CODE_CHANGEJOB4:
			if ( lpPlayInfo->smCharInfo.JOB_CODE<=4 )
				dwSndCode = snCHAR_SOUND_NPC_SKILLMASTER;
			else
				dwSndCode = snCHAR_SOUND_NPC_MAGICMASTER;
			break;

		case HAQUEST_CODE_FURYOFPHANTOM:
			dwSndCode = snCHAR_SOUND_FURY;
			switch( Param )
			{
			case 1:
				OpenLevel = 118; break;
			case 2:
				OpenLevel = 119; break;
			case 3:
				OpenLevel = 120; break;
			}
	}

	//이미 소환된 몹 있으면 제거
	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag && 
			chrAutoPlayer[cnt].lpLinkPlayInfo==lpPlayInfo && 
			chrAutoPlayer[cnt].dwLinkObjectCode==lpPlayInfo->dwObjectSerial ) {

				chrAutoPlayer[cnt].Close();
				((STG_AREA *)chrAutoPlayer[cnt].lpExt1)->MonsterCount--;
				((STG_AREA *)chrAutoPlayer[cnt].lpExt1)->DeleteMonTable( &chrAutoPlayer[cnt] );
		}
	}

	lpStgArea = &StageArea[QUEST_ARENA_FIELD];
	if ( lpStgArea ) {
		len = 0;

		StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;

		//특정 몬스터 호출
		for(cnt=0;cnt<chrMonsterCnt;cnt++) {
			if ( chrMonsterList[cnt].dwCharSoundCode==dwSndCode && (OpenLevel==0 || OpenLevel==chrMonsterList[cnt].Level) ) {
				memcpy(	&StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) ); 
				len++;
				break;
			}
		}

		if ( len ) {
			lpStgArea->EvnMonster = TRUE;
			lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
			if ( lpChar ) {
				lpChar->SetPosi( QUEST_ARENA_NPC_POS_X, 0, QUEST_ARENA_NPC_POS_Z , 0,0,0 );
				lpChar->DistAroundDbl = 0;
				lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
				lpChar->TargetMoveCount = 0;
				lpChar->lpLinkPlayInfo=lpPlayInfo;
				lpChar->dwLinkObjectCode=lpPlayInfo->dwObjectSerial;
				lpChar->dwUpdateCharInfoTime = dwPlayServTime+30*60*1000;						//30분후 제거

				//상대 레벨에 따라 더욱 강화
				pow = lpPlayInfo->smCharInfo.Level-60;
				if ( pow<0 ) pow=0;
				pow+=pow/2;

				lpChar->smCharInfo.Life[0] += (lpChar->smCharInfo.Life[0]*pow)/100;
				if ( lpChar->smCharInfo.Life[0]<0 || lpChar->smCharInfo.Life[0]>30000 ) lpChar->smCharInfo.Life[0]=30000;
				lpChar->smCharInfo.Life[1] = lpChar->smCharInfo.Life[0];

				lpChar->smCharInfo.Attack_Damage[0] += (lpChar->smCharInfo.Attack_Damage[0]*pow)/100;
				lpChar->smCharInfo.Attack_Damage[1] += (lpChar->smCharInfo.Attack_Damage[1]*pow)/100;

				lpChar->smMonsterInfo.SkillDamage[0] += (lpChar->smMonsterInfo.SkillDamage[0]*pow)/100;
				lpChar->smMonsterInfo.SkillDamage[1] += (lpChar->smMonsterInfo.SkillDamage[1]*pow)/100;

				lpChar->smMonsterInfo.PotionCount += 3;		//물약 더욱 3개 추가

				return lpChar;
			}
		}
	}

	return NULL;
}



//특정위치에 몬스터 강제 출현 시킴
smCHAR *OpenMonsterFromName( char *szName , int x, int y, int z , rsPLAYINFO *lpPlayInfo=0 )
{
	STG_AREA	*lpStgArea;
	STG_CHAR_INFO StgCharInfo;
	int	len,cnt;//,rnd;
	smCHAR	*lpChar;

	lpStgArea = FindStageField( x, z );
	if ( lpStgArea ) {
		len = 0;

		StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;
/*
		if ( lpStgArea->rsMonsterList.Counter ) {
			//몬스터 설정이 있을경우
			rnd = (rand()%lpStgArea->rsMonsterList.PecetageCount);
			for( cnt=0;cnt<lpStgArea->rsMonsterList.Counter;cnt++ ) {
				if ( lpStgArea->rsMonsterList.rsMonster[cnt].NumOpenStart>rnd ) break;
			}
			memcpy( &StgCharInfo.smCharInfo , lpStgArea->rsMonsterList.rsMonster[cnt-1].lpCharInfo , sizeof( smCHAR_INFO ) );
			len++;
		}
*/
		if ( szName && szName[0] ) {
			//특정 몬스터 호출
			for(cnt=0;cnt<chrMonsterCnt;cnt++) {
				if ( lstrcmp(chrMonsterList[cnt].szName , szName )==0 ) {
					memcpy(	&StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) ); 
					len++;
					break;
				}
			}
		}

		if ( len ) {
			lpStgArea->EvnMonster = TRUE;
			lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
			if ( lpChar ) {
				lpChar->pX = x;
				lpChar->pY = y;
				lpChar->pZ = z;
				lpChar->DistAroundDbl = 0;
				lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
				lpChar->TargetMoveCount = 0;
				if ( lpPlayInfo ) {
					lpChar->lpMasterPlayInfo = lpPlayInfo;
					lpChar->smMonsterInfo.dwAutoCharCode = 0;
					//lstrcat( lpChar->smCharInfo.szName , "[/]" );		//이름에 표시를..
					lpChar->smCharInfo.Brood = smCHAR_MONSTER_USER;		//몬스터 종족 (유저편)
					lstrcpy( lpChar->smCharInfo.szModelName2+1 , lpPlayInfo->smCharInfo.szName );	//주인 이름
					lpChar->smCharInfo.Next_Exp = lpPlayInfo->dwObjectSerial;						//주인 시리얼 코드 저장
					lpChar->dwUpdateCharInfoTime = dwPlayServTime+4*60*1000;						//4분후 제거
				}

				return lpChar;
			}
		}
	}

	return FALSE;
}

//해당 몬스터 출신 깃발 의 활성화 몬스터 수
int rsGetMonCountFlag( smCHAR *lpChar )
{
	STG_AREA	*lpStgArea;
	if ( !lpChar->lpExt1 ) return -1;

	lpStgArea = (STG_AREA *)lpChar->lpExt1;

	return lpStgArea->StartPointMonCount[lpChar->OpenStartPostion];
}

//특정위치에 보조몬스터 강제 출현 시킴
smCHAR *rsOpenSubMonster( smCHAR *lpMainChar , DWORD dwCharSoundCode , int x, int y, int z , int MaxFlag )
{
	STG_AREA	*lpStgArea;
	STG_CHAR_INFO StgCharInfo;
	int	len,cnt;//,rnd;
	smCHAR	*lpChar;
	smCHAR_INFO	*lpCharInfo;


	if ( !lpMainChar->lpExt1 ) return FALSE;

	lpStgArea = (STG_AREA *)lpMainChar->lpExt1;

	//시작 깃발의 발생수 기록
	if ( lpStgArea->StartPointMonCount[lpMainChar->OpenStartPostion]>=MaxFlag ) return FALSE;

	/*	안쓴다넹~
	if( dwCharSoundCode != snCHAR_SOUND_DEADHOPT )	// pluto 데드 킹호피 변신 할때 데드 호피 한마리 더 나오게 할려고
	{
		if ( lpStgArea->StartPointMonCount[lpMainChar->OpenStartPostion]>=MaxFlag ) return FALSE;
	}
	*/


	if ( lpStgArea ) {
		len = 0;

		StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;

		lpCharInfo = 0;

		//특정 몬스터 호출
		for(cnt=0;cnt<chrMonsterCnt;cnt++) {
			if ( chrMonsterList[cnt].dwCharSoundCode==dwCharSoundCode ) {
				memcpy(	&StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) ); 
				len++;
				break;
			}
		}

		if ( len ) {


			//빈캐릭터를 찾는다 
			lpChar = srFindEmptyChar();
			if ( !lpChar ) return NULL;


			lpChar->Init();
			lpChar->lpStage = lpMainChar->lpStage;
			lpChar->SetPosi( x, y, z ,lpMainChar->Angle.x ,lpMainChar->Angle.y,lpMainChar->Angle.z );

			lpChar->PosiAround.x = x;
			lpChar->PosiAround.y = lpChar->pY;
			lpChar->PosiAround.z = y;
			lpChar->DistAroundDbl =  DIST_AROUND_MIDDLE;

			lpChar->OpenStartPostion = lpMainChar->OpenStartPostion;


			lpStgArea->MonsterCount++;
			lpChar->lpExt1 = lpStgArea;
			lpChar->dwObjectSerial = GetNewObjectSerial();
			lpChar->ActionPattern = 5;
			memcpy( &lpChar->smCharInfo , &StgCharInfo.smCharInfo , sizeof( smCHAR_INFO ) );
			memcpy( &lpChar->smMonsterInfo , StgCharInfo.smCharInfo.lpMonInfo , sizeof( smCHAR_MONSTER_INFO ) );
			lpChar->SetLoadPattern( lpChar->smCharInfo.szModelName );

			//구분 코드를 StatePoint 에 설정
			lpChar->smCharInfo.StatePoint = StgCharInfo.smCharInfo.lpMonInfo->ClassCode;

			lpChar->DistAroundDbl =  0;
			lpChar->AttackUserFlag = 0;
			lpChar->lpExt2 = 0;


			//경험치 배분 유저 기억 정보
			lpChar->lpExpAttackPlayInfo = 0;
			lpChar->ExpAttackLife = 0;

			lpStgArea->AddMonTable( lpChar );
			lpChar->ReopenCount	= REOPEN_COUNT_NUM;			//슬립모드시 재시작 시간 카운터
			lpChar->dwLastTransTime = dwPlayServTime;		//최근 활성화된 시간

			//물약 갯수 등록
			if ( lpChar->smMonsterInfo.PotionCount ) {
				if ( (rand()%100)<lpChar->smMonsterInfo.PotionPercent ) {
					lpChar->smMonsterInfo.PotionCount = (rand()%lpChar->smMonsterInfo.PotionCount)+1;
				}
				else {
					lpChar->smMonsterInfo.PotionCount = 0;
				}
			}

#ifndef	_LANGUAGE_PHILIPIN
			if ( rsDamgeOffEvent )
			{
				//공격력 할인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*ATTACK_RATE)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*ATTACK_RATE)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] )
				{
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*ATTACK_RATE)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*ATTACK_RATE)/100;
				}
			}
#else
//해외(필리핀)/////////////////////////////////////////////////////////////
			if ( rsDamgeOffEvent1 )
			{
				//공격력 할인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*75)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*75)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] )
				{
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*75)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*75)/100;
				}
			}

			if ( rsDamgeOffEvent2 )
			{
				//공격력 할인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*50)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*50)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] )
				{
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*50)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*50)/100;
				}
			}
#endif
////////////////////////////////////////////////////////////////////////////////////
			//해외버전용
			if( rsDefenseOffEvent )
			{
				//몬스터 방어력 할인 이벤트
				lpChar->smCharInfo.Defence = (lpChar->smCharInfo.Defence*DEFENSE_RATE)/100;
			}
			rsMonOpenCount++;			//몬스터 발생 기록

			lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
			lpChar->TargetMoveCount = 0;

			return lpChar;
		}
	}

	return FALSE;
}


/////////////하드코어 이벤트 좌표 설정/////////////////
//////////// Field 9번 네비스코 마을 //////////////////
/*
//몬스터 출현 좌표 라인
POINT3D	rsHardCoreEventOpenPos[4] = {
	{	21589 , 950 , 750 },
	{	22113 , 950 , 150 },
	{	21589 , 950 , 750 },
	{	22113 , 950 , 150 }
};
*/


POINT3D	rsHardCoreEventOpenPos[7][3] = {
	{	//경기장 1
		{ 18967,  1154,	3055 },
		{ 19995,  1154,	2134 },
		{ 19485,  1154,	2615 }			//중앙
	},
	{	//경기장 2
		{ 20838,  1154,	3024 },
		{ 21671,  1154,	2193 },
		{ 21255,  1154,	2615 }			//중앙
	},
	{	//경기장 3
		{ 22478,  1154,	3049 },
		{ 23437,  1154,	2135 },
		{ 22948,  1154,	2615 }			//중앙
	},
	{	//경기장 4
		{ 24204,  1154,	3094 },
		{ 25173,  1154,	2135 },
		{ 24674,  1154,	2615 }			//중앙
	},
	///////////////////////////
	{	//경기장 5
		{ 20509,  1621,	5284 },
		{ 21544,  1621,	4261 },
		{ 21012,  1621,	4773 }			//중앙
	},
	{	//경기장 6
		{ 22575,  1621,	5253 },
		{ 23610,  1621,	4230 },
		{ 23077,  1621,	4742 }			//중앙
	},
	/////////////////////////////
	{	//경기장 7
		{ 21538,  1638,	7057 },
		{ 22527,  1638,	6079 },
		{ 22018,  1638,	6569 }			//중앙
	}
};

//경기 단계별 경기장
int	rsSod_RoundTable[8][2] = {
	{	0,	4	},		//1
	{	0,	4	},		//2
	{	0,	4	},		//3
	{	4,	6	},		//4
	{	4,	6	},		//5
	{	4,	6	},		//6
	{	6,	7	},		//7
	{	6,	7	}		//8
};

//경기 입장팀 유저별 경기장
int	rsSod_RoundRoomTable[4][8] = {
	{	0,	0,	0,	4,	4,	4,	6,	6	},
	{	1,	1,	1,	4,	4,	4,	6,	6	},
	{	2,	2,	2,	5,	5,	5,	6,	6	},
	{	3,	3,	3,	5,	5,	5,	6,	6	}
};



//int rsHardCoreEventArea[4] = { 21000 , 23000, -60 , 1100 };
int rsHardCoreEventArea[4] = { 18516 , 25715, 1541 , 7178 };

/*
//플레이어 시작 위치
POINT3D	rsHardCoreEventStartPos = {	21856*fONE , 950*fONE , -640*fONE };
POINT3D	rsHardCoreEvent_Center = {	21856*fONE , 950*fONE , 600*fONE };
*/

int	rsHardCoreEventInterLineZ = -32*fONE;
int	rsHardCoreEventInterLineZ2 = -64*fONE;
int	rsHardCoreEventPosY = (950-32)*fONE;
int	rsHardCoreEventOutLineZ = -600*fONE;		//-760*fONE;
int	rsHardCoreEvent_TicketHour = 4;

DWORD	dwHardCoreEvent_OutTime;

int	rsEventTicketCount;
int	rsEventTicketLevel[4];

int	rsHardCoreEventMode = 0;			//시간별 SOD 가능유무
int	rsHardCoreEventTimeOver = 0;		//시간종료 유무

#define	rsEVENT_TICKET_LEVEL_TOTAL		549


struct	sSOD_USER {
	rsPLAYINFO	*lpPlayInfo;
	DWORD		dwConnCode;
	DWORD		Temp[4];
};

#define	rsSOD_USER_MAX	120
#define	rsSOD_UPDATE_TIME	6000

sSOD_USER	rsSodUser[ rsSOD_USER_MAX ];		//Sod 유저 포인터 정보
int	rsSodUserCount;
DWORD	rsTransSodTime =0;
DWORD	dwSoD_DelayTime = 0;			//SoD 각 라운드별 대기 시간 (각각의 연출대기)

int	rsSodTeamScore[4];		//Sod 팀 득점값
int	rsSodTeamRank[4];		//Sod 팀 순위

#ifdef	_W_SERVER

// pluto 보안 깨진거 같다고 이사님이 수정
#define XOR_ITEM_SeCode_0	0x536c56ba
#define XOR_ITEM_SeCode_1	0x9ab536cd
#define XOR_ITEM_SeCode_2	0xc6abce56

DWORD rsITEM_SecCode_Xor[16] = {
	0x6794bca6 ,		//0
		0x78645fe3 ,		//1
		0xcea82934 ,		//2
		0x56fdca87 ,		//3
		0x357d3653 ,		//4
		0xf3487eba ,		//5
		0x3478978f ,		//6
		0x6793fbc2 ,		//7
		0x5842eec6 ,		//8
		0x257ecdb5 ,		//9
		0x579cbec5 ,		//A
		0x985612ab ,		//B
		0x5487cc56 ,		//C
		0xba7d4553 ,		//D
		0xeca53b96 ,		//E
		0xb5c549ce			//F
};

//#define rsRegist_EnterKey( _dwCode , _dwAdd )  rsITEM_SecCode_Xor[(_dwCode+_dwAdd)&0xF]
DWORD rsRegist_EnterKey( DWORD _dwCode , DWORD _dwAdd ) 
{
	return rsITEM_SecCode_Xor[ ( _dwCode + _dwAdd )&0xF ];
}

#define	SOD_DEFAULT_DELAY	5


sHCORE_MONSTER	sHCoreEvent1[] = {
	{ { "비독" , 0, 40 }			, { "코크리스", 0, 40 }		, { "디코이", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 6 , 0 , 40 , SOD_DEFAULT_DELAY },
	{ { "바곤" , 0, 35 }		, { "스켈레톤아처", 0, 20 }		, { "크립트", 0, 45 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 8 , 0 , 40 , SOD_DEFAULT_DELAY },
	{ { "싸이클롭스 나이트" , 0, 35 }		, { "스켈레톤아처", 0, 30 }		, { "스켈레톤워리어", 0, 35 }		, { "", 0, 0 }		, { "언홀리 나이트", 0, 0 }		, 100 , 10 , 0 , 40 , SOD_DEFAULT_DELAY },
	{ { "헤드커터" , 0, 45 }		, { "스켈레톤레인저", 0, 25 }	, { "이블 메이플", 0, 20 }	, { "웹", 0, 10 }	, { "", 0, 0 }		, 100 , 12 , 0 , 35 , SOD_DEFAULT_DELAY*2 },
	{ { "일루젼나이트" , 0, 30 }			, { "파이곤", 0, 20 }	, { "둠 가드", 0, 40 }		, { "그리븐", 0, 10 }	, { "", 0, 0 }		, 100 , 15 , 0 , 30 , SOD_DEFAULT_DELAY},
	{ { "헐크" , 0, 20 }			, { "파이곤", 0, 20 }	, { "슬러터", 0, 40 }		, { "쉐도우", 0, 20 }	, { "베르문 악타룬", 0, 0 }		, 100 , 18 , 0 , 25, SOD_DEFAULT_DELAY },
	{ { "오미크론" , 0, 30 }			, { "스티지언", 0, 40 }		, { "헐크", 0, 20 } 	, { "둠 가드", 0, 10 }	, { "", 0, 0 }		, 100 , 21 , 0 , 20, SOD_DEFAULT_DELAY*3 },
	{ { "아이언 가드" , 0, 20 }			, { "킹호피", 0, 30 }		, { "인큐버스", 0, 30 }		, { "하이퍼 머신", 0, 20 }	, { "둠 로드", 0, 0 }		, 100 , 0 , 50000 , 15 , SOD_DEFAULT_DELAY },
	{ { "" , 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 		, { "", 0, 0 }		, 0 , 3 , 0 , 0}
};

sHCORE_MONSTER	sHCoreEvent2[] = {
	{ { "메핏" , 0, 40 }		, { "노쓰고블린", 0, 40 }		, { "데벌리쉬 트리", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 6 , 0 , 40	,	SOD_DEFAULT_DELAY	},
	{ { "바곤" , 0, 25 }		, { "메핏", 0, 40 }		, { "부마", 0, 35 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 8 , 0 , 40	,	SOD_DEFAULT_DELAY	},
	{ { "싸이클롭스 나이트" , 0, 30 }			, { "스켈레톤아처", 0, 30 }		, { "스켈레톤워리어", 0, 40 }		, { "", 0, 0 }		, { "언홀리 나이트", 0, 0 }		, 100 , 10 , 0 , 40,	SOD_DEFAULT_DELAY	},
	{ { "스켈레톤나이트" , 0, 45 }		, { "스켈레톤레인저", 0, 25 }	, { "마이어 키퍼", 0, 20 }	, { "웹", 0, 10 }	, { "", 0, 0 }		, 100 , 12 , 0 , 35,	SOD_DEFAULT_DELAY*2	},
	{ { "슬러터" , 0, 30 }	, { "파이곤", 0, 20 }		, { "다크 나이트", 0, 40 }		, { "그리븐", 0, 10 }	, { "", 0, 0 }		, 100 , 15 , 0 , 30,	SOD_DEFAULT_DELAY	},
	{ { "헐크", 0, 20 }		, { "슬리버", 0, 20 }	, { "아벨리스크-L", 0, 40 }	, { "쉐도우" , 0, 20 }	, { "베르문 악타룬", 0, 0 }		, 100 , 18 , 0 , 25,	SOD_DEFAULT_DELAY },
	{ { "다우린" , 0, 30 }			, { "스티지언", 0, 40 }	, { "헐크", 0, 20 }	, { "둠 가드", 0, 10 }	, { "", 0, 0 }		, 100 , 21 , 0 , 20,	SOD_DEFAULT_DELAY*3	},
	{ { "아이언 가드" , 0, 20}			, { "킹호피", 0, 30 }	, { "아벨리스크 로드", 0, 30 }	, { "하이퍼 머신", 0, 20 }	, { "둠 로드", 0, 0 }		, 100 , 0 , 50000 , 15,	SOD_DEFAULT_DELAY	},
	{ { "" , 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 		, { "", 0, 0 }		, 0 , 3 , 0 , 0}
};


sHCORE_MONSTER	sHCoreEvent3[] = {
	{ { "메핏" , 0, 40 }		, { "좀비", 0, 40 }		, { "홉고블린 칩", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 6 , 0 , 40,	SOD_DEFAULT_DELAY},
	{ { "구울" , 0, 25 }			, { "스켈레톤아처", 0, 40 }		, { "싸이클롭스", 0, 35 }	, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 8 , 0 , 40,	SOD_DEFAULT_DELAY},
	{ { "마이티고블린" , 0, 30 }		, { "스켈레톤아처", 0, 30 }		, { "아머드 비틀", 0, 40 }		, { "", 0, 0 }		, { "언홀리 나이트", 0, 0 }		, 100 , 10 , 0 , 40,	SOD_DEFAULT_DELAY},
	{ { "타이탄" , 0, 45 }		, { "스켈레톤레인저", 0, 25 }		, { "머디 고렘", 0, 20 }	, { "웹", 0, 10 }	, { "", 0, 0 }		, 100 , 12 , 0 , 35,	SOD_DEFAULT_DELAY*2},
	{ { "나이트메어" , 0, 30 }		, { "파이곤", 0, 20 }		, { "비블", 0, 40 }		, { "그리븐", 0, 10 }	, { "", 0, 0 }		, 100 , 15 , 0 , 30,	SOD_DEFAULT_DELAY},
	{ { "헐크", 0, 20 }		, { "슬리버", 0, 20 }	, { "아벨리스크-L", 0, 40 }	, { "쉐도우" , 0, 20 }	, { "베르문 악타룬", 0, 0 }		, 100 , 18 , 0 , 25,	SOD_DEFAULT_DELAY},
	{ { "오미크론" , 0, 30 }			, { "스티지언", 0, 40 }		, { "헐크", 0, 20 }	, { "둠 가드", 0, 10 }	, { "", 0, 0 }		, 100 , 21 , 0 , 20,	SOD_DEFAULT_DELAY*3},
	{ { "아이언 가드" , 0, 20 }			, { "체인 고렘", 0, 30 }	, { "위치", 0, 30 }		, { "하이퍼 머신", 0, 20 }	, { "둠 로드", 0, 0 }		, 100 , 0 , 50000 , 15,	SOD_DEFAULT_DELAY},
	{ { "" , 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 		, { "", 0, 0 }		, 0 , 3 , 0 , 0}
};





/*
sHCORE_MONSTER	sHCoreEvent1[] = {
	{ { "도랄" , 0, 50 }			, { "임프", 0, 30 }		, { "미니그", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 6 , 0 , 50 , SOD_DEFAULT_DELAY },
	{ { "나무괴물" , 0, 60 }		, { "메핏", 0, 20 }		, { "스켈레톤", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 8 , 0 , 50 , SOD_DEFAULT_DELAY },
	{ { "스콜피온" , 0, 60 }		, { "코크리스", 0, 20 }		, { "좀비", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 10 , 0 , 50 , SOD_DEFAULT_DELAY },
	{ { "싸이클롭스" , 0, 50 }		, { "스켈레톤아처", 0, 20 }	, { "뮤턴트 트리", 0, 10 }	, { "디코이", 0, 20 }	, { "", 0, 0 }		, 100 , 12 , 0 , 40 , SOD_DEFAULT_DELAY*2 },
	{ { "크립트" , 0, 35 }			, { "마이티고블린", 0, 30 }	, { "바곤", 0, 20 }		, { "부마", 0, 15 }	, { "", 0, 0 }		, 100 , 15 , 0 , 40 , SOD_DEFAULT_DELAY},
	{ { "그리븐" , 0, 30 }			, { "스켈레톤레인저", 0, 20 }	, { "샌드램", 0, 25 }		, { "헤드커터", 0, 15 }	, { "", 0, 0 }		, 100 , 18 , 0 , 35, SOD_DEFAULT_DELAY },
	{ { "슬러터" , 0, 45 }			, { "파이곤", 0, 20 }		, { "스톤자이언트", 0, 25 } 	, { "슬리버", 0, 10 }	, { "", 0, 0 }		, 100 , 21 , 0 , 30, SOD_DEFAULT_DELAY*3 },
	{ { "킹호피" , 0, 10 }			, { "머미", 0, 55 }		, { "웹", 0, 20 }		, { "다우린", 0, 15 }	, { "헬싱", 0, 0 }		, 100 , 0 , 50000 , 25 , SOD_DEFAULT_DELAY },

	{ { "" , 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 		, { "", 0, 0 }		, 0 , 3 , 0 , 0}
};

sHCORE_MONSTER	sHCoreEvent2[] = {
	{ { "홉고블린" , 0, 50 }		, { "임프", 0, 30 }		, { "변이식물", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 6 , 0 , 50	,	SOD_DEFAULT_DELAY	},
	{ { "스켈레톤" , 0, 60 }		, { "메핏", 0, 20 }		, { "플랜티", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 8 , 0 , 50	,	SOD_DEFAULT_DELAY	},
	{ { "구울" , 0, 60 }			, { "코크리스", 0, 20 }		, { "스콜피온", 0, 20 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 10 , 0 , 50,	SOD_DEFAULT_DELAY	},
	{ { "스켈레톤아처" , 0, 25 }		, { "마이티고블린", 0, 30 }	, { "싸이클롭스", 0, 25 }	, { "디코이", 0, 20 }	, { "", 0, 0 }		, 100 , 12 , 0 , 40,	SOD_DEFAULT_DELAY*2	},
	{ { "싸이클롭스 나이트" , 0, 25 }	, { "그리븐", 0, 25 }		, { "부마", 0, 25 }		, { "바곤", 0, 25 }	, { "", 0, 0 }		, 100 , 15 , 0 , 40,	SOD_DEFAULT_DELAY	},
	{ { "마이티고블린", 0, 20 }		, { "스켈레톤워리어", 0, 30 }	, { "스켈레톤레인저", 0, 20 }	, { "타이탄" , 0, 30 }	, { "", 0, 0 }		, 100 , 18 , 0 , 35,	SOD_DEFAULT_DELAY },
	{ { "웹" , 0, 15 }			, { "일루젼나이트", 0, 45 }	, { "스켈레톤나이트", 0, 20 }	, { "나즈", 0, 20 }	, { "", 0, 0 }		, 100 , 21 , 0 , 30,	SOD_DEFAULT_DELAY*3	},
	{ { "킹호피" , 0, 10 }			, { "아벨리스크-L", 0, 35 }	, { "아벨리스크-s", 0, 35 }	, { "파이곤", 0, 20 }	, { "베르문 악타룬", 0, 0 }		, 100 , 0 , 50000 , 25,	SOD_DEFAULT_DELAY	},

	{ { "" , 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 		, { "", 0, 0 }		, 0 , 3 , 0 , 0}
};


sHCORE_MONSTER	sHCoreEvent3[] = {
	{ { "노쓰고블린" , 0, 60 }		, { "이간", 0, 30 }		, { "래비", 0, 10 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 6 , 0 , 50,	SOD_DEFAULT_DELAY},
	{ { "커럽트" , 0, 60 }			, { "비독", 0, 20 }		, { "뮤턴트 래비", 0, 20 }	, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 8 , 0 , 50,	SOD_DEFAULT_DELAY},
	{ { "데벌리쉬 트리" , 0, 60 }		, { "메핏", 0, 25 }		, { "좀비", 0, 15 }		, { "", 0, 0 }		, { "", 0, 0 }		, 100 , 10 , 0 , 50,	SOD_DEFAULT_DELAY},
	{ { "스켈레톤아처" , 0, 25 }		, { "바곤", 0, 35 }		, { "싸이클롭스", 0, 20 }	, { "리치", 0, 20 }	, { "", 0, 0 }		, 100 , 12 , 0 , 40,	SOD_DEFAULT_DELAY*2},
	{ { "스켈레톤워리어" , 0, 25 }		, { "샌드램", 0, 20 }		, { "부마", 0, 30 }		, { "디코이", 0, 15 }	, { "", 0, 0 }		, 100 , 15 , 0 , 40,	SOD_DEFAULT_DELAY},
	{ { "마이티고블린", 0, 20 }		, { "아벨리스크-S", 0, 30 }	, { "스켈레톤레인저", 0, 20 }	, { "타이탄" , 0, 30 }	, { "", 0, 0 }		, 100 , 18 , 0 , 35,	SOD_DEFAULT_DELAY},
	{ { "웹" , 0, 15 }			, { "헤드커터", 0, 55 }		, { "아벨리스크 로드", 0, 20 }	, { "다우린", 0, 10 }	, { "", 0, 0 }		, 100 , 21 , 0 , 30,	SOD_DEFAULT_DELAY*3},
	{ { "킹호피" , 0, 15 }			, { "일루젼나이트", 0, 55 }	, { "나즈", 0, 25 }		, { "헐크", 0, 5 }	, { "블러디 로즈", 0, 0 }		, 100 , 0 , 50000 , 25,	SOD_DEFAULT_DELAY},

	{ { "" , 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 			, { "", 0, 0 } 		, { "", 0, 0 }		, 0 , 3 , 0 , 0}
};
*/

sHCORE_MONSTER	sHCoreEvent_Bellatra[3][hCORE_ROUND_MAX];
sHCORE_MONSTER	*sHCoreEvent = sHCoreEvent2;

_sHCORE_MONSTER	hCoreMonsters[5];

TRANS_SOD_RESULT	TransSodResult;
TRANS_SOD_RESULT	TransSodResult_RealTime[5];
TRANS_SOD_RESULT	TransSodResult_Round;

int	rsHardCoreEvent_Count;
int rsHardCoreEvent_MonsterMax;

smCHAR_INFO	*rsHardCoreBoss;
int rsHardCoreEvent_OpenBoss[8];
int rsHardCoreEvent_OpenCount[8];

int	rsHardCoreEvent_TotalUser;
int	rsSoD_StartCode;
int	rsSOD_Tax = 5;		//세율(기본 5%)
char rsSOD_Text[256] = { 0, };		//SOD 몬스터 배치 설명서

#ifdef _LANGUAGE_ENGLISH

#ifdef _BELLATRA_OLD_VERSION
int	rsSOD_ScoreDiv = 35;			//SOD 점수 경험치를 나누는 값 (기본 18 - 숫자가 작을수로 점수 높음)
#else
int	rsSOD_ScoreDiv = 30;			//SOD 점수 경험치를 나누는 값 (기본 18 - 숫자가 작을수로 점수 높음)
#endif

#else

#ifdef _BELLATRA_OLD_VERSION
int	rsSOD_ScoreDiv = 18;			//SOD 점수 경험치를 나누는 값 (기본 18 - 숫자가 작을수로 점수 높음)
#else
int	rsSOD_ScoreDiv = 15;			//SOD 점수 경험치를 나누는 값 (기본 18 - 숫자가 작을수로 점수 높음)
#endif

#endif

//char	szHardCoreEvent_Course

//제일 근접한 시작 좌표를 얻는다 
//int sFIELD::GetStartPoint( int x, int z , int *mx , int *mz )








//하드코어 이벤트 초기화
int	rsInitHardCoreEvent()
{
	int cnt,cnt2;
	int total;

	rsHardCoreEvent_Count = 0;
	rsHardCoreEvent_TotalUser = 0;


	sHCoreEvent = sHCoreEvent1;
	cnt = 0;
	while(1) {
		if ( sHCoreEvent[cnt].hCoreMonster1.szName[0]==0 ) break;

		total = 0;

		//몬스터 캐릭터 정보 저장
		for( cnt2=0;cnt2<chrMonsterCnt;cnt2++ ) {
			if ( !sHCoreEvent[cnt].hCoreMonster1.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster1.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster1.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster2.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster2.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster2.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster3.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster3.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster3.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster4.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster4.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster4.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonsterBoss.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonsterBoss.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonsterBoss.lpCharInfo = &chrMonsterList[cnt2];
			}
		}

		if ( sHCoreEvent[cnt].hCoreMonster2.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster2.perCount += sHCoreEvent[cnt].hCoreMonster1.perCount;
		if ( sHCoreEvent[cnt].hCoreMonster3.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster3.perCount += sHCoreEvent[cnt].hCoreMonster2.perCount;
		if ( sHCoreEvent[cnt].hCoreMonster4.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster4.perCount += sHCoreEvent[cnt].hCoreMonster3.perCount;


		cnt++;
	}

	sHCoreEvent = sHCoreEvent2;
	cnt = 0;
	while(1) {
		if ( sHCoreEvent[cnt].hCoreMonster1.szName[0]==0 ) break;

		total = 0;

		//몬스터 캐릭터 정보 저장
		for( cnt2=0;cnt2<chrMonsterCnt;cnt2++ ) {
			if ( !sHCoreEvent[cnt].hCoreMonster1.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster1.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster1.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster2.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster2.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster2.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster3.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster3.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster3.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster4.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster4.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster4.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonsterBoss.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonsterBoss.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonsterBoss.lpCharInfo = &chrMonsterList[cnt2];
			}
		}

		if ( sHCoreEvent[cnt].hCoreMonster2.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster2.perCount += sHCoreEvent[cnt].hCoreMonster1.perCount;
		if ( sHCoreEvent[cnt].hCoreMonster3.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster3.perCount += sHCoreEvent[cnt].hCoreMonster2.perCount;
		if ( sHCoreEvent[cnt].hCoreMonster4.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster4.perCount += sHCoreEvent[cnt].hCoreMonster3.perCount;

		cnt++;
	}

	sHCoreEvent = sHCoreEvent3;
	cnt = 0;
	while(1) {
		if ( sHCoreEvent[cnt].hCoreMonster1.szName[0]==0 ) break;

		total = 0;

		//몬스터 캐릭터 정보 저장
		for( cnt2=0;cnt2<chrMonsterCnt;cnt2++ ) {
			if ( !sHCoreEvent[cnt].hCoreMonster1.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster1.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster1.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster2.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster2.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster2.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster3.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster3.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster3.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster4.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster4.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster4.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonsterBoss.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonsterBoss.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonsterBoss.lpCharInfo = &chrMonsterList[cnt2];
			}
		}

		if ( sHCoreEvent[cnt].hCoreMonster2.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster2.perCount += sHCoreEvent[cnt].hCoreMonster1.perCount;
		if ( sHCoreEvent[cnt].hCoreMonster3.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster3.perCount += sHCoreEvent[cnt].hCoreMonster2.perCount;
		if ( sHCoreEvent[cnt].hCoreMonster4.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster4.perCount += sHCoreEvent[cnt].hCoreMonster3.perCount;

		cnt++;
	}

	memcpy( sHCoreEvent_Bellatra[0] , sHCoreEvent1 , sizeof(sHCORE_MONSTER)*hCORE_ROUND_MAX );
	memcpy( sHCoreEvent_Bellatra[1] , sHCoreEvent2 , sizeof(sHCORE_MONSTER)*hCORE_ROUND_MAX );
	memcpy( sHCoreEvent_Bellatra[2] , sHCoreEvent3 , sizeof(sHCORE_MONSTER)*hCORE_ROUND_MAX );

	memcpy( &hCoreMonsters[0] , &sHCoreEvent[0].hCoreMonster1 , sizeof(_sHCORE_MONSTER) );
	memcpy( &hCoreMonsters[1] , &sHCoreEvent[0].hCoreMonster2 , sizeof(_sHCORE_MONSTER) );
	memcpy( &hCoreMonsters[2] , &sHCoreEvent[0].hCoreMonster3 , sizeof(_sHCORE_MONSTER) );
	memcpy( &hCoreMonsters[3] , &sHCoreEvent[0].hCoreMonster4 , sizeof(_sHCORE_MONSTER) );
	memcpy( &hCoreMonsters[4] , &sHCoreEvent[0].hCoreMonsterBoss , sizeof(_sHCORE_MONSTER) );
	rsEventTicketCount = 0;

	rsEventTicketLevel[0] = 0;
	rsEventTicketLevel[1] = 0;
	rsEventTicketLevel[2] = 0;
	rsEventTicketLevel[3] = 0;

	rsHardCoreEvent_MonsterMax = 40;

	rsSoD_StartCode = (ServerNameCode<<24)|((tServerTime)&0xFFFFFF);		//SoD 고유번호 생성

	ZeroMemory( &TransSodResult , sizeof(TRANS_SOD_RESULT) );
	ZeroMemory( &TransSodResult_RealTime[0] , sizeof(TRANS_SOD_RESULT) );
	ZeroMemory( &TransSodResult_RealTime[1] , sizeof(TRANS_SOD_RESULT) );
	ZeroMemory( &TransSodResult_RealTime[2] , sizeof(TRANS_SOD_RESULT) );
	ZeroMemory( &TransSodResult_RealTime[3] , sizeof(TRANS_SOD_RESULT) );
	ZeroMemory( &TransSodResult_RealTime[4] , sizeof(TRANS_SOD_RESULT) );
	ZeroMemory( &TransSodResult_Round , sizeof(TRANS_SOD_RESULT) );

	ZeroMemory( rsSodTeamScore , sizeof(int)*4 );
	ZeroMemory( rsSodUser , sizeof(sSOD_USER)*rsSOD_USER_MAX );
	rsSodUserCount = 0;


	return TRUE;
}

//SOD 몬스터 배치 불러와서 적용
int	rsOpen_SODConfig()
{

	int cnt,cnt2;

	if ( Open_SODConfig( "Bellatra\\bellatra.ini" , sHCoreEvent_Bellatra[0] , &rsSOD_Tax , rsSOD_Text , &rsSOD_ScoreDiv )==0 ) {
		memcpy( sHCoreEvent_Bellatra[0] , sHCoreEvent1 , sizeof(sHCORE_MONSTER)*hCORE_ROUND_MAX );
		memcpy( sHCoreEvent_Bellatra[1] , sHCoreEvent2 , sizeof(sHCORE_MONSTER)*hCORE_ROUND_MAX );
		memcpy( sHCoreEvent_Bellatra[2] , sHCoreEvent3 , sizeof(sHCORE_MONSTER)*hCORE_ROUND_MAX );
		return FALSE;
	}


	sHCoreEvent = sHCoreEvent_Bellatra[0];
	cnt = 0;
	while(1) {
		if ( sHCoreEvent[cnt].hCoreMonster1.szName[0]==0 ) break;
		if ( cnt>=rsHARDCORE_COUNT_END ) break;

		//몬스터 캐릭터 정보 저장
		for( cnt2=0;cnt2<chrMonsterCnt;cnt2++ ) {
			if ( !sHCoreEvent[cnt].hCoreMonster1.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster1.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster1.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster2.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster2.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster2.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster3.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster3.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster3.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonster4.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonster4.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonster4.lpCharInfo = &chrMonsterList[cnt2];
			}
			if ( !sHCoreEvent[cnt].hCoreMonsterBoss.lpCharInfo &&
				lstrcmpi( sHCoreEvent[cnt].hCoreMonsterBoss.szName , chrMonsterList[cnt2].szName )==0 ) {
					sHCoreEvent[cnt].hCoreMonsterBoss.lpCharInfo = &chrMonsterList[cnt2];
			}
		}

		if ( sHCoreEvent[cnt].hCoreMonster2.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster2.perCount += sHCoreEvent[cnt].hCoreMonster1.perCount;
		if ( sHCoreEvent[cnt].hCoreMonster3.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster3.perCount += sHCoreEvent[cnt].hCoreMonster2.perCount;
		if ( sHCoreEvent[cnt].hCoreMonster4.lpCharInfo )
			sHCoreEvent[cnt].hCoreMonster4.perCount += sHCoreEvent[cnt].hCoreMonster3.perCount;


		cnt++;
	}

	memcpy( sHCoreEvent_Bellatra[1] , sHCoreEvent , sizeof(sHCORE_MONSTER)*hCORE_ROUND_MAX );
	memcpy( sHCoreEvent_Bellatra[2] , sHCoreEvent , sizeof(sHCORE_MONSTER)*hCORE_ROUND_MAX );

	return TRUE;
}

/*
//SOD벨라트라 몬스터 설정 불러오기
int	Open_SODConfig( sHCORE_MONSTER *lpSod_Monster1 , sHCORE_MONSTER *lpSod_Monster2, sHCORE_MONSTER *lpSod_Monster3, int *SodTax , char *szSodText );
*/

//몬스터 출현 위치 설정
int	rsGetHardCoreEventOpenMonsterPos( int *mx , int *my, int *mz , int Room )
{
	int x,y,z;
	int cx,cz;

	x = rsHardCoreEventOpenPos[Room][0].x;
	y = rsHardCoreEventOpenPos[Room][0].y;
	z = rsHardCoreEventOpenPos[Room][0].z;

	cx = rsHardCoreEventOpenPos[Room][1].x-x;
	cz = z-rsHardCoreEventOpenPos[Room][1].z;

	cx = rand()%cx;
	cz = rand()%cz;

	*mx = (x+cx)*fONE;
	*mz = (z-cz)*fONE;
	*my = y*fONE;

	return TRUE;
}

//Sod 팀순위 설정
int rsSetSodTeamRank()
{
	int cnt,cnt1;
	int r1,r2;

	rsSodTeamRank[0] = 0;
	rsSodTeamRank[1] = 1;
	rsSodTeamRank[2] = 2;
	rsSodTeamRank[3] = 3;

	for( cnt=0;cnt<4;cnt++) {
		for(cnt1=cnt;cnt1<4;cnt1++) {
			r1 = rsSodTeamRank[cnt];
			r2 = rsSodTeamRank[cnt1];

			if ( rsSodTeamScore[r1]<rsSodTeamScore[r2] ) {
				rsSodTeamRank[cnt] = r2;
				rsSodTeamRank[cnt1] = r1;
			}
		}
	}

	return TRUE;
}

int rsHardCoreEvent_OpenMonster( STG_AREA *lpStgArea , STG_CHAR_INFO *lpStgCharInfo )
{

	STG_CHAR_INFO		 StgCharInfo;
	//TRANS_ITEMINFO		TransItemInfo;
	TRANS_CHATMESSAGE	TransChatMessage;
	TRANS_CHATMESSAGE	TransChatMessage2;
	smTRANS_COMMAND		smTransCommand;
	smTRANS_COMMAND		smTransCommand2;

	smCHAR	*lpChar;
	int x,y,z;
	int total;
	int	total2;
	int totalScore;

	int cnt,mcnt;
	int	rnk;
	int	money;

	if ( rsHardCoreEventTimeOver ) {
		if ( rsHardCoreEventMode )
			rsHardCoreEventTimeOver = FALSE;		//시간이 됐음 해제
		else
			return TRUE;							//게임 시간이 아님
	}

	if ( dwServ_GameTimeHour==sHCoreEvent[rsHardCoreEvent_Count].StartHour ) {

		if ( rsHardCoreEvent_Count==0 )			//SOD 몬스터 배치 불러와서 적용
			rsOpen_SODConfig();


		for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpStgArea->lpCharMonster[cnt] ) {
				if ( lpStgArea->lpCharMonster[cnt]->Flag && lpStgArea->lpCharMonster[cnt]->PartyFlag==rsHARDCORE_EVENT_FLAG &&
					lpStgArea->lpCharMonster[cnt]->MotionInfo->State!=CHRMOTION_STATE_DEAD ) {
					lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0] = 0;
					lpStgArea->lpCharMonster[cnt]->SetMotionFromCode(CHRMOTION_STATE_DEAD);

					if ( !sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster1.szName[0] ) {		//마지막 판 물약세팅
						/*
						switch( rand()%2 ) {
							case 0:
								lpStgArea->lpCharMonster[cnt]->PartyParam = (sinPM1|sin04);		//기력약 신
								break;
							case 1:
								lpStgArea->lpCharMonster[cnt]->PartyParam = (sinPM1|sin04);		//기력약 신
								break;

						}
						*/
						lpStgArea->lpCharMonster[cnt]->PartyParam = (sinPM1|sin04);		//기력약 신

						//몬스터 사냥정보 보관 ( SOD2 물약 선물 )
						if ( rsPushKillMonster( lpStgArea->lpCharMonster[cnt] , 0 , ((STG_AREA *)lpStgArea->lpCharMonster[cnt]->lpExt1) )==FALSE ) {
							CreatePresentItem( lpStgArea->lpCharMonster[cnt]->PartyParam , ((STG_AREA *)lpStgArea->lpCharMonster[cnt]->lpExt1) , lpStgArea->lpCharMonster[cnt]->pX, lpStgArea->lpCharMonster[cnt]->pY, lpStgArea->lpCharMonster[cnt]->pZ, 3 );
						}
					}

				}
			}
		}

		if ( sHCoreEvent[rsHardCoreEvent_Count].State>0 ) {
			total = 0;
			for(cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG ) {
					if ( rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x , rsPlayInfo[cnt].Position.y , rsPlayInfo[cnt].Position.z )==TRUE ) {
						if ( total<rsPlayInfo[cnt].EventScore ) 
							total = rsPlayInfo[cnt].EventScore;
					}
				}
			}
			if ( total<sHCoreEvent[rsHardCoreEvent_Count].State ) {
				rsHardCoreEvent_Count++;							//스킵 제한 점수를 넘지 못해서 최종판은 넘어간다
			}
		}

		if ( !sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster1.szName[0] ) {


			switch( rand()%3 ) {
				case 0:
					sHCoreEvent = sHCoreEvent_Bellatra[0];
					break;
				case 1:
					sHCoreEvent = sHCoreEvent_Bellatra[1];
					break;
				case 2:
					sHCoreEvent = sHCoreEvent_Bellatra[2];
					break;
			}

			rsHardCoreEvent_Count = 0;
			memcpy( &hCoreMonsters[0] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster1 , sizeof(_sHCORE_MONSTER) );
			memcpy( &hCoreMonsters[1] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster2 , sizeof(_sHCORE_MONSTER) );
			memcpy( &hCoreMonsters[2] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster3 , sizeof(_sHCORE_MONSTER) );
			memcpy( &hCoreMonsters[3] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster4 , sizeof(_sHCORE_MONSTER) );
			memcpy( &hCoreMonsters[4] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonsterBoss , sizeof(_sHCORE_MONSTER) );

			rsHardCoreEvent_MonsterMax = sHCoreEvent[rsHardCoreEvent_Count].MaxMonster;
			ZeroMemory( rsHardCoreEvent_OpenBoss , sizeof( int )*8 );
			ZeroMemory( rsHardCoreEvent_OpenCount , sizeof( int )*8 );
			rsHardCoreBoss = sHCoreEvent[rsHardCoreEvent_Count].hCoreMonsterBoss.lpCharInfo;

			dwHardCoreEvent_OutTime = dwPlayServTime+30000;
			rsEventTicketCount = 0;
			rsEventTicketLevel[0] = 0;
			rsEventTicketLevel[1] = 0;
			rsEventTicketLevel[2] = 0;
			rsEventTicketLevel[3] = 0;

			TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;

			//rsHardCoreEvent_TotalUser
			total2 = 0;
			totalScore = 0;
			for(cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG ) {
					if ( rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x , rsPlayInfo[cnt].Position.y , rsPlayInfo[cnt].Position.z )==TRUE ) {
						totalScore += rsPlayInfo[cnt].EventScore;
						total2++;
					}
				}
			}

			ZeroMemory( &TransSodResult , sizeof(TRANS_SOD_RESULT) );

			for(cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG ) {
					if ( rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x , rsPlayInfo[cnt].Position.y , rsPlayInfo[cnt].Position.z )==TRUE ) {

						money = rsPlayInfo[cnt].EventScore-((rsPlayInfo[cnt].EventScore*rsSOD_Tax)/100);		//세금떼고 상금
/*
						wsprintf( TransChatMessage.szMessage , srMsg_104 , money );
						TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
						rsPlayInfo[cnt].lpsmSock->Send2( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
*/
						//모두 클리어한 내용 패킷전송
						ZeroMemory( &smTransCommand , sizeof( smTRANS_COMMAND ) );
						smTransCommand.code = smTRANSCODE_SOD_INFOMATION;
						smTransCommand.size = sizeof( smTRANS_COMMAND );
						smTransCommand.WParam = 4;
						smTransCommand.LParam = rsHardCoreEvent_Count;
						smTransCommand.SParam = 100;
						smTransCommand.EParam = money;
						rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

						//정보 기록 ( 순위 출력 용 )
						if ( TransSodResult.ResultCount<SOD_RESULT_MAX && !rsPlayInfo[cnt].HideMode ) {
							TransSodResult.Result[ TransSodResult.ResultCount ].lpPlayInfo = &rsPlayInfo[cnt];
							lstrcpy( TransSodResult.Result[ TransSodResult.ResultCount ].szName , rsPlayInfo[cnt].smCharInfo.szName );
							TransSodResult.Result[ TransSodResult.ResultCount ].Class = rsPlayInfo[cnt].smCharInfo.ClassClan;
							TransSodResult.Result[ TransSodResult.ResultCount ].JobCode = rsPlayInfo[cnt].smCharInfo.JOB_CODE;
							TransSodResult.Result[ TransSodResult.ResultCount ].Score = rsPlayInfo[cnt].EventScore;
							TransSodResult.Result[ TransSodResult.ResultCount ].Monster = rsPlayInfo[cnt].EventCount;
							TransSodResult.ResultCount++;
						}

						mcnt = money;

						//지역서버 경우
						if ( dwSerToSerIP ) {
							if ( rsSendMoneyToSystemLine( &rsPlayInfo[cnt] , mcnt )==TRUE ) {		//메인서버로 돈을 경유해서 보낸다
								mcnt = 0;
							}
						}

						if ( mcnt ) {

							//돈을 유저에게 보낸다
							rsSendMoneyToUser( &rsPlayInfo[cnt] , mcnt );

							/*
							//성공 점수를 돈으로 환산하여 준다
							ZeroMemory( &TransItemInfo , sizeof( TRANS_ITEMINFO ) );

							//if ( mcnt>200000 ) mcnt=200000;


							TransItemInfo.code = smTRANSCODE_PUTITEM;
							TransItemInfo.size = sizeof(TRANS_ITEMINFO);
							TransItemInfo.Item.CODE = ( sinGG1|sin01 );
							TransItemInfo.Item.Money = mcnt;
							wsprintf( TransItemInfo.Item.ItemName , sinGold , mcnt );
							ReformItem( &TransItemInfo.Item );

							rsPlayInfo[cnt].spMoney_Out += TransItemInfo.Item.Money;						//출금 기록
							TransItemInfo.x = dwPlayServTime;												//해독 키
							TransItemInfo.y = TransItemInfo.Item.ItemHeader.dwChkSum;						//해독 키2
							TransItemInfo.z = rsPlayInfo[cnt].spMoney_Out^(TransItemInfo.x+TransItemInfo.y);	//토탈 기록 전송

							rsRegist_ItemSecCode( &rsPlayInfo[cnt] , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )

							rsPlayInfo[cnt].lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
							*/
						}


						//SOD 결과를 데이타 서버로 보냄
						rsSend_ResultSOD( &rsPlayInfo[cnt] , rsPlayInfo[cnt].EventScore , rsPlayInfo[cnt].EventCount , totalScore , total2, rsHardCoreEvent_TotalUser , rsSoD_StartCode );

						if ( rsPlayInfo[cnt].EventScore>=400000 ) {
							//40만 이상 점수 획득한 경우 로그인서버에 로그 보냄

							smTransCommand.size = sizeof(smTRANS_COMMAND);
							smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
							smTransCommand.WParam = 21000;
							smTransCommand.SParam = rsPlayInfo[cnt].EventMode;
							smTransCommand.LParam = rsPlayInfo[cnt].EventScore;
							rsSendDataServer( rsPlayInfo[cnt].lpsmSock , &smTransCommand );

						}

					}
					else {
						//SOD 결과를 데이타 서버로 보냄
						rsSend_ResultSOD( &rsPlayInfo[cnt] , 0 , rsPlayInfo[cnt].EventCount , 0 , 0, rsHardCoreEvent_TotalUser , rsSoD_StartCode );
					}
				}
			}

			//SoD 기록을 집계하여 게임한 유저한테 정보 보냄
			TransSodResult.code = smTRANSCODE_SOD_RESULT;
			TransSodResult.size = sizeof(TRANS_SOD_RESULT)-((SOD_RESULT_MAX-TransSodResult.ResultCount)*sizeof(_SOD_RESULT));
			TransSodResult.dwGameCode = rsSoD_StartCode;
			TransSodResult.dwGameTime = (DWORD)tServerTime;
			TransSodResult.dwDisplayMode = TRUE;

			for( cnt=0;cnt<TransSodResult.ResultCount;cnt++ ) {
				if ( TransSodResult.Result[cnt].lpPlayInfo && TransSodResult.Result[cnt].lpPlayInfo->lpsmSock ) {
					TransSodResult.Result[cnt].lpPlayInfo->lpsmSock->Send2( (char *)&TransSodResult , TransSodResult.size , TRUE );
				}
			}
			TransSodResult.dwDisplayMode = FALSE;

			return TRUE;
		}


		memcpy( &hCoreMonsters[0] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster1 , sizeof(_sHCORE_MONSTER) );
		memcpy( &hCoreMonsters[1] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster2 , sizeof(_sHCORE_MONSTER) );
		memcpy( &hCoreMonsters[2] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster3 , sizeof(_sHCORE_MONSTER) );
		memcpy( &hCoreMonsters[3] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonster4 , sizeof(_sHCORE_MONSTER) );
		memcpy( &hCoreMonsters[4] , &sHCoreEvent[rsHardCoreEvent_Count].hCoreMonsterBoss , sizeof(_sHCORE_MONSTER) );

		rsHardCoreEvent_MonsterMax = sHCoreEvent[rsHardCoreEvent_Count].MaxMonster;
		ZeroMemory( rsHardCoreEvent_OpenBoss , sizeof( int )*8 );
		ZeroMemory( rsHardCoreEvent_OpenCount , sizeof( int )*8 );
		rsHardCoreBoss = sHCoreEvent[rsHardCoreEvent_Count].hCoreMonsterBoss.lpCharInfo;

		if ( hCoreMonsters[0].lpCharInfo ) {

			dwSoD_DelayTime = dwPlayServTime+sHCoreEvent[rsHardCoreEvent_Count].DelayTime*1000;		//몬스터 출현 대기시간 설정
/*
			wsprintf( TransChatMessage.szMessage , srMsg_103 , rsHardCoreEvent_Count+1 );
			TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
*/
			//성공팀 패킷
			ZeroMemory( &smTransCommand2 , sizeof( smTRANS_COMMAND ) );
			smTransCommand2.code = smTRANSCODE_SOD_INFOMATION;
			smTransCommand2.size = sizeof( smTRANS_COMMAND );
			smTransCommand2.WParam = 1;
			smTransCommand2.LParam = rsHardCoreEvent_Count;
			smTransCommand2.SParam = -1;

			//실패팀 패킷
			ZeroMemory( &smTransCommand , sizeof( smTRANS_COMMAND ) );
			smTransCommand.code = smTRANSCODE_SOD_INFOMATION;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = 3;
			smTransCommand.LParam = rsHardCoreEvent_Count;
			smTransCommand.SParam = -1;


			rsSetSodTeamRank();		//팀순위 설정

			if ( rsHardCoreEvent_Count==3 || rsHardCoreEvent_Count==6 ) {
				//위치변경
				for(cnt=0;cnt<CONNECTMAX;cnt++) {
					if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG ) {
						if ( rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x , rsPlayInfo[cnt].Position.y , rsPlayInfo[cnt].Position.z )==TRUE ) {

							if ( rsPlayInfo[cnt].sEventParam[0]==rsSodTeamRank[0] || ( rsPlayInfo[cnt].sEventParam[0]==rsSodTeamRank[1] && rsHardCoreEvent_Count==3 ) ) {
								/*
								//성공팀
								smTransCommand.WParam = rsSOD_FIELD;
								smTransCommand.code = smTRANSCODE_WARPFIELD;
								smTransCommand.size = sizeof( smTRANS_COMMAND );

								if ( rsPlayInfo[cnt].sEventParam[0]==rsSodTeamRank[0] ) {
									smTransCommand.SParam = 
										rsHardCoreEventOpenPos[rsSod_RoundRoomTable[0][rsHardCoreEvent_Count]][2].x*fONE;
									smTransCommand.LParam = 
										rsHardCoreEventOpenPos[rsSod_RoundRoomTable[0][rsHardCoreEvent_Count]][2].z*fONE;
								}
								else {
									smTransCommand.SParam = 
										rsHardCoreEventOpenPos[rsSod_RoundRoomTable[2][rsHardCoreEvent_Count]][2].x*fONE;
									smTransCommand.LParam = 
										rsHardCoreEventOpenPos[rsSod_RoundRoomTable[2][rsHardCoreEvent_Count]][2].z*fONE;
								}
								rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
								*/

								if ( rsPlayInfo[cnt].sEventParam[0]==rsSodTeamRank[0] )
									smTransCommand2.SParam = rsSod_RoundRoomTable[0][rsHardCoreEvent_Count];
								else
									smTransCommand2.SParam = rsSod_RoundRoomTable[2][rsHardCoreEvent_Count];

								rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand2 , smTransCommand2.size , TRUE );

							}
							else {
								//탈락팀
								/*
								smTransCommand.WParam = rsSOD_VILLAGE;
								smTransCommand.code = smTRANSCODE_WARPFIELD;
								smTransCommand.size = sizeof( smTRANS_COMMAND );
								smTransCommand.SParam = StageArea[rsSOD_VILLAGE].lpField->cX*fONE;
								smTransCommand.LParam = StageArea[rsSOD_VILLAGE].lpField->cZ*fONE;
								*/
								rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

								//SOD 결과를 데이타 서버로 보냄/탈락
								rsSend_ResultSOD( &rsPlayInfo[cnt] , -rsPlayInfo[cnt].EventScore , rsPlayInfo[cnt].EventCount , 0 , 0, rsHardCoreEvent_TotalUser , rsSoD_StartCode );

#ifdef _BELLATRA_OLD_VERSION_NOMOEY
								money = 0;
#else
								money = rsPlayInfo[cnt].EventScore-((rsPlayInfo[cnt].EventScore*rsSOD_Tax)/100);		//세금떼고 상금

								//지역서버 경우
								if ( dwSerToSerIP && rsSendMoneyToSystemLine( &rsPlayInfo[cnt] , money )==TRUE ) {

								}
								else {
									//돈을 유저에게 직접 보낸다
									rsSendMoneyToUser( &rsPlayInfo[cnt] , money );
								}
#endif
								rsPlayInfo[cnt].EventMode=0;
								rsPlayInfo[cnt].EventScore=0;
								rsPlayInfo[cnt].EventCount=0;

								rnk = 1;
								if ( rsPlayInfo[cnt].sEventParam[0]==rsSodTeamRank[1] ) rnk=2;
								if ( rsPlayInfo[cnt].sEventParam[0]==rsSodTeamRank[2] ) rnk=3;
								if ( rsPlayInfo[cnt].sEventParam[0]==rsSodTeamRank[3] ) rnk=4;

								//당신의 팀은 탈락했습니다 (점수)(순위)
								//wsprintf( TransChatMessage2.szMessage , srMsg_110 , rsSodTeamScore[rsPlayInfo[cnt].sEventParam[0]] , rnk );
								//당신의 팀은 탈락했습니다(%d위)  %d원을 획득했습니다
								wsprintf( TransChatMessage2.szMessage , srMsg_110 , rnk , money );
								TransChatMessage2.code = smTRANSCODE_MESSAGEBOX;
								TransChatMessage2.size = 32+lstrlen(TransChatMessage2.szMessage);
								TransChatMessage2.dwIP = 0;
								TransChatMessage2.dwObjectSerial = 0;

								rsPlayInfo[cnt].lpsmSock->Send2( (char *)&TransChatMessage2 , TransChatMessage2.size , TRUE );

							}
						}
					}
				}
				smTransCommand2.size = 0;
			}
		}

		total = 0;
		for(cnt=0;cnt<CONNECTMAX;cnt++) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG ) {
				if ( rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x , rsPlayInfo[cnt].Position.y , rsPlayInfo[cnt].Position.z )==TRUE ) {
					//rsPlayInfo[cnt].lpsmSock->Send2( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
					if ( smTransCommand2.size )
						rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand2 , smTransCommand2.size , TRUE );
					total++;
/*
						//성공 점수를 돈으로 환산하여 준다
						ZeroMemory( &TransItemInfo , sizeof( TRANS_ITEMINFO ) );

						TransItemInfo.code = smTRANSCODE_PUTITEM;
						TransItemInfo.size = sizeof(TRANS_ITEMINFO);
						TransItemInfo.Item.CODE = ( sinGG1|sin01 );
						TransItemInfo.Item.Money = rsPlayInfo[cnt].EventScore;
						wsprintf( TransItemInfo.Item.ItemName , sinGold , rsPlayInfo[cnt].EventScore );
						ReformItem( &TransItemInfo.Item );

						rsPlayInfo[cnt].spMoney_Out += TransItemInfo.Item.Money;				//출금 기록
						TransItemInfo.x = dwPlayServTime;											//해독 키
						TransItemInfo.y = TransItemInfo.Item.ItemHeader.dwChkSum;					//해독 키2
						TransItemInfo.z = rsPlayInfo[cnt].spMoney_Out^(TransItemInfo.x+TransItemInfo.y);	//토탈 기록 전송

						rsPlayInfo[cnt].lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
*/
				}
				else {
					rsPlayInfo[cnt].EventMode=0;
					//SOD 결과를 데이타 서버로 보냄
					rsSend_ResultSOD( &rsPlayInfo[cnt] , 0 , rsPlayInfo[cnt].EventCount , 0 , 0, rsHardCoreEvent_TotalUser , rsSoD_StartCode );
				}

			}
		}

		rsHardCoreEvent_Count++;

		return FALSE;
	}

	if ( !rsHardCoreEvent_Count ) {

		if ( dwHardCoreEvent_OutTime && dwHardCoreEvent_OutTime<dwPlayServTime ) {
			for(cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG ) {
					rsPlayInfo[cnt].EventMode=0;
					rsPlayInfo[cnt].EventScore=0;
					rsPlayInfo[cnt].EventCount=0;

					if ( rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x , rsPlayInfo[cnt].Position.y , rsPlayInfo[cnt].Position.z )==TRUE ) {
						smTransCommand.WParam = rsSOD_VILLAGE;
						smTransCommand.code = smTRANSCODE_WARPFIELD;
						smTransCommand.size = sizeof( smTRANS_COMMAND );
						smTransCommand.SParam = StageArea[rsSOD_VILLAGE].lpField->cX*fONE;
						smTransCommand.LParam = StageArea[rsSOD_VILLAGE].lpField->cZ*fONE;
						rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
					}

				}
			}
			rsHardCoreEvent_TotalUser = 0;
			dwHardCoreEvent_OutTime = 0;
			if ( !rsHardCoreEventMode ) rsHardCoreEventTimeOver = TRUE;		//게임 종료
			//rsSoD_StartCode = (ServerNameCode<<16)|(((GetCurrentTime()>>8))&0xFFFF);		//SoD 고유번호 생성
			rsSoD_StartCode = (ServerNameCode<<24)|((tServerTime)&0xFFFFFF);		//SoD 고유번호 생성
			ZeroMemory( rsSodTeamScore , sizeof(int)*4 );		//팀 득점 초기화

			ZeroMemory( rsSodUser , sizeof(sSOD_USER)*rsSOD_USER_MAX );
			rsSodUserCount = 0;

		}

		return FALSE;
	}

	if ( rsTransSodTime<dwPlayServTime ) {
		rsTransUpdateSod( 0 );				//Sod 사용자 전체 점수 출력
		rsTransSodTime = dwPlayServTime+rsSOD_UPDATE_TIME;
	}

	int	RndCnt;
	int	MonMax[8];
	int	SodRoundCount = rsHardCoreEvent_Count-1;

	if ( SodRoundCount<0 || SodRoundCount>=8 || dwSoD_DelayTime>dwPlayServTime  ) 
		return FALSE; 

	ZeroMemory( MonMax , sizeof(int)*8 );

	for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
		if ( lpStgArea->lpCharMonster[cnt] ) {
			if ( lpStgArea->lpCharMonster[cnt]->Flag && lpStgArea->lpCharMonster[cnt]->PartyFlag==rsHARDCORE_EVENT_FLAG &&
				lpStgArea->lpCharMonster[cnt]->MotionInfo->State!=CHRMOTION_STATE_DEAD ) {

					if ( lpStgArea->lpCharMonster[cnt]->PartyParam>=0 && lpStgArea->lpCharMonster[cnt]->PartyParam<8 ) {
						MonMax[lpStgArea->lpCharMonster[cnt]->PartyParam]++;
					}
			}
		}
	}

	for( RndCnt=rsSod_RoundTable[SodRoundCount][0] ; RndCnt<rsSod_RoundTable[SodRoundCount][1] ; RndCnt++ ) {

		mcnt = MonMax[RndCnt];

		if ( mcnt>rsHardCoreEvent_MonsterMax ) {
			continue;
		}

		if ( rsHardCoreBoss && !rsHardCoreEvent_OpenBoss[RndCnt] && rsHardCoreEvent_OpenCount[RndCnt]>(rsHardCoreEvent_MonsterMax-10) ) {
			//보스 몹 출현
			memcpy( &lpStgCharInfo->smCharInfo ,  rsHardCoreBoss , sizeof( smCHAR_INFO ) );
			rsHardCoreEvent_OpenBoss[RndCnt] ++;
		}
		else {
			cnt = rand()%100;
			if ( hCoreMonsters[0].lpCharInfo && cnt<=hCoreMonsters[0].perCount ) {
				memcpy( &lpStgCharInfo->smCharInfo ,  hCoreMonsters[0].lpCharInfo , sizeof( smCHAR_INFO ) );
			}
			else if ( hCoreMonsters[1].lpCharInfo && cnt<=hCoreMonsters[1].perCount ) {
				memcpy( &lpStgCharInfo->smCharInfo ,  hCoreMonsters[1].lpCharInfo , sizeof( smCHAR_INFO ) );
			}
			else if ( hCoreMonsters[2].lpCharInfo && cnt<=hCoreMonsters[2].perCount ) {
				memcpy( &lpStgCharInfo->smCharInfo ,  hCoreMonsters[2].lpCharInfo , sizeof( smCHAR_INFO ) );
			}
			else if ( hCoreMonsters[3].lpCharInfo && cnt<=hCoreMonsters[3].perCount ) {
				memcpy( &lpStgCharInfo->smCharInfo ,  hCoreMonsters[3].lpCharInfo , sizeof( smCHAR_INFO ) );
			}
		}

		rsGetHardCoreEventOpenMonsterPos( &x,&y,&z , RndCnt );

		StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;

		lpStgArea->EvnMonster = TRUE;
		lpChar = lpStgArea->OpenMonster( lpStgCharInfo , 0 );
		if ( lpChar ) {
			lpChar->pX = x;
			lpChar->pY = y;
			lpChar->pZ = z;
			lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
			lpChar->TargetMoveCount = 0;
			lpChar->PartyFlag = rsHARDCORE_EVENT_FLAG;
			lpChar->PartyParam = RndCnt;

			lpChar->PosiAround.x = rsHardCoreEventOpenPos[RndCnt][2].x*fONE;
			lpChar->PosiAround.y = rsHardCoreEventOpenPos[RndCnt][2].y*fONE;
			lpChar->PosiAround.z = rsHardCoreEventOpenPos[RndCnt][2].z*fONE;
			lpChar->DistAroundDbl =  (12*64 * 12*64);

			lpChar->smCharInfo.Sight = 800*800;			//시야 조정

			rsHardCoreEvent_OpenCount[RndCnt]++;		//몬스터 오픈 카운터

			continue;
		}
	}

	return FALSE;
}

DWORD	dwSodRealScore_Time[5] = { 0,0,0,0,0 };

//SoD 진행 상황 출력
TRANS_SOD_RESULT *rsSod_GetRealTimeScore( rsPLAYINFO *lpPlayInfo , int TeamNum )
{
	int cnt,rc;
	int	Team;

	Team = TeamNum;
	if ( Team>4 || Team<0 ) Team = 0;

	if ( (dwSodRealScore_Time[Team]+10000)<dwPlayServTime ) {

		ZeroMemory( &TransSodResult_RealTime[Team] , sizeof(TRANS_SOD_RESULT) );

		for(cnt=0;cnt<CONNECTMAX;cnt++) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG && ( Team==0 || (rsPlayInfo[cnt].sEventParam[0]+1)==Team) ) {
				if ( !rsPlayInfo[cnt].HideMode && rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x , rsPlayInfo[cnt].Position.y , rsPlayInfo[cnt].Position.z )==TRUE ) {
					//정보 기록 ( 순위 출력 용 )
					if ( TransSodResult_RealTime[Team].ResultCount<SOD_RESULT_MAX ) {
						rc = TransSodResult_RealTime[Team].ResultCount;
						TransSodResult_RealTime[Team].Result[ rc ].lpPlayInfo = &rsPlayInfo[cnt];
						lstrcpy( TransSodResult_RealTime[Team].Result[ rc ].szName , rsPlayInfo[cnt].smCharInfo.szName );
						TransSodResult_RealTime[Team].Result[ rc ].Class = rsPlayInfo[cnt].smCharInfo.ClassClan;
						TransSodResult_RealTime[Team].Result[ rc ].JobCode = rsPlayInfo[cnt].smCharInfo.JOB_CODE;
						TransSodResult_RealTime[Team].Result[ rc ].Score = rsPlayInfo[cnt].EventScore;
						TransSodResult_RealTime[Team].Result[ rc ].Monster = rsPlayInfo[cnt].EventCount;
						TransSodResult_RealTime[Team].ResultCount++;
					}
				}
			}
		}

		dwSodRealScore_Time[Team] = dwPlayServTime;
	}

	if ( TransSodResult_RealTime[Team].ResultCount==0 ) return NULL;

	TransSodResult_RealTime[Team].code = smTRANSCODE_SOD_RESULT2;
	TransSodResult_RealTime[Team].size = sizeof(TRANS_SOD_RESULT)-((SOD_RESULT_MAX-TransSodResult_RealTime[Team].ResultCount)*sizeof(_SOD_RESULT));
	TransSodResult_RealTime[Team].dwGameCode = rsSoD_StartCode;
	TransSodResult_RealTime[Team].dwGameTime = (DWORD)tServerTime;
	TransSodResult_RealTime[Team].dwDisplayMode = TRUE;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) 
		lpPlayInfo->lpsmSock->Send2( (char *)&TransSodResult_RealTime[Team] , TransSodResult_RealTime[Team].size , TRUE );


	return &TransSodResult_RealTime[Team];
}


/*
	ZeroMemory( &TransSodResult , sizeof(TRANS_SOD_RESULT) );
	ZeroMemory( &TransSodResult_RealTime , sizeof(TRANS_SOD_RESULT) );
	ZeroMemory( &TransSodResult_Round , sizeof(TRANS_SOD_RESULT) );
*/

//Sod 점수 업그레이드
int	rsTransUpdateSod( rsPLAYINFO *lpPlayInfo )
{

	int cnt,SndCount;
	smTRANS_COMMAND_SOD	smTransCommand;

	ZeroMemory( &smTransCommand , sizeof(smTRANS_COMMAND_SOD) );
	smTransCommand.smTransCommand.size = sizeof(smTRANS_COMMAND_SOD);
	smTransCommand.smTransCommand.code = smTRANSCODE_SOD_INFOMATION;
	smTransCommand.smTransCommand.WParam = 2;

	smTransCommand.smTransCommand.SParam = rsHardCoreEvent_Count;		//Round


	smTransCommand.TeamScore[0] = rsSodTeamScore[0];
	smTransCommand.TeamScore[1] = rsSodTeamScore[1];
	smTransCommand.TeamScore[2] = rsSodTeamScore[2];
	smTransCommand.TeamScore[3] = rsSodTeamScore[3];

	SndCount = 0;

	if ( lpPlayInfo ) {
		//특정 유저만
		if ( lpPlayInfo->lpsmSock && lpPlayInfo->EventMode==rsHARDCORE_EVENT_FLAG ) {
			smTransCommand.MyScore = lpPlayInfo->EventScore;
			smTransCommand.MyTeam = lpPlayInfo->sEventParam[0];
			smTransCommand.smTransCommand.LParam = 1;

			lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.smTransCommand.size , TRUE );
			SndCount++;
		}
	}
	else {
		//전체 
		for(cnt=0;cnt<rsSodUserCount;cnt++) {
			if ( rsSodUser[cnt].lpPlayInfo && rsSodUser[cnt].lpPlayInfo->lpsmSock &&
				rsSodUser[cnt].lpPlayInfo->EventMode==rsHARDCORE_EVENT_FLAG &&
				rsSodUser[cnt].lpPlayInfo->dwConnectCount==rsSodUser[cnt].dwConnCode ) {

					smTransCommand.MyScore = rsSodUser[cnt].lpPlayInfo->EventScore;
					smTransCommand.MyTeam = rsSodUser[cnt].lpPlayInfo->sEventParam[0];
					rsSodUser[cnt].lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.smTransCommand.size , TRUE );
					SndCount++;
				}
		}
	}


	return SndCount;
}

//득점 상황 표시
int rsShowHardCoreEventScore( rsPLAYINFO *lpPlayInfo )		
{

//	TRANS_CHATMESSAGE	TransChatMessage;

	if ( (lpPlayInfo->dwEventTime+500)>dwPlayServTime ) return FALSE;		//이벤트 메세지 시간차 조절

	lpPlayInfo->dwEventTime = dwPlayServTime;
/*
	wsprintf( TransChatMessage.szMessage , srMsg_105 , lpPlayInfo->EventScore );
	TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
	TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
	TransChatMessage.dwIP = 0;
	TransChatMessage.dwObjectSerial = 0;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}
*/
	rsTransUpdateSod( lpPlayInfo );

	return TRUE;
}

//득점 상황 표시
int rsShowHardCoreEventScore2( rsPLAYINFO *lpPlayInfo , smCHAR *lpChar , int Score )		
{
	TRANS_CHATMESSAGE	TransChatMessage;

	wsprintf( TransChatMessage.szMessage , srMsg_111 , lpChar->smCharInfo.szName , Score );
	TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
	TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
	TransChatMessage.dwIP = 3;
	TransChatMessage.dwObjectSerial = 0;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}

	return TRUE;
}

//////////////////////////////////// SOD 아이템 적용 파트 ///////////////////////////////////
//폭탄 아이템 적용
int rsSoD_CatchItem_SD201( rsPLAYINFO *lpPlayInfo , int StagePos , STG_AREA	*lpStgArea )
{
	int cnt;
	int	Damage;
	int x,z;

	for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
		if ( lpStgArea->lpCharMonster[cnt] ) {
			if ( lpStgArea->lpCharMonster[cnt]->Flag && lpStgArea->lpCharMonster[cnt]->PartyFlag==rsHARDCORE_EVENT_FLAG &&
				lpStgArea->lpCharMonster[cnt]->MotionInfo->State!=CHRMOTION_STATE_DEAD &&
				lpStgArea->lpCharMonster[cnt]->smCharInfo.wPlayClass[0]!=MONSTER_CLASS_BOSS ) 
			{

					x = lpStgArea->lpCharMonster[cnt]->pX>>FLOATNS;
					z = lpStgArea->lpCharMonster[cnt]->pZ>>FLOATNS;

					if ( x>rsHardCoreEventOpenPos[StagePos][0].x && x<rsHardCoreEventOpenPos[StagePos][1].x &&
						z>rsHardCoreEventOpenPos[StagePos][1].z && z<rsHardCoreEventOpenPos[StagePos][0].z ) {

							Damage = lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[1]/3;

							lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0]-=Damage;
							if ( lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0]<=0 ) {
								lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0] = 1;
							}
							/*
								lpStgArea->lpCharMonster[cnt]->SetMotionFromCode(CHRMOTION_STATE_DEAD);
							}
							else {
							*/
							lpStgArea->lpCharMonster[cnt]->SetMotionFromCode(CHRMOTION_STATE_DAMAGE);
						}
			}
		}
	}


	return TRUE;
}

//시계 아이템 적용
int rsSoD_CatchItem_SD202( rsPLAYINFO *lpPlayInfo , int StagePos , STG_AREA	*lpStgArea )
{
	int cnt;
	int x,z;

	for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
		if ( lpStgArea->lpCharMonster[cnt] ) {
			if ( lpStgArea->lpCharMonster[cnt]->Flag && lpStgArea->lpCharMonster[cnt]->PartyFlag==rsHARDCORE_EVENT_FLAG &&
				lpStgArea->lpCharMonster[cnt]->MotionInfo->State!=CHRMOTION_STATE_DEAD ) {

					x = lpStgArea->lpCharMonster[cnt]->pX>>FLOATNS;
					z = lpStgArea->lpCharMonster[cnt]->pZ>>FLOATNS;

					if ( x>rsHardCoreEventOpenPos[StagePos][0].x && x<rsHardCoreEventOpenPos[StagePos][1].x &&
						z>rsHardCoreEventOpenPos[StagePos][1].z && z<rsHardCoreEventOpenPos[StagePos][0].z ) {

							lpStgArea->lpCharMonster[cnt]->SetMotionFromCode(CHRMOTION_STATE_DAMAGE);
							lpStgArea->lpCharMonster[cnt]->PlayStunCount = 16*10;		//10초간 멈춘다
						}
			}
		}
	}


	return TRUE;
}

//얼음보송이 아이템 적용
int rsSoD_CatchItem_SD203( rsPLAYINFO *lpPlayInfo , int StagePos , STG_AREA	*lpStgArea )
{
	int cnt;
	int x,z;

	for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
		if ( lpStgArea->lpCharMonster[cnt] ) {
			if ( lpStgArea->lpCharMonster[cnt]->Flag && lpStgArea->lpCharMonster[cnt]->PartyFlag==rsHARDCORE_EVENT_FLAG &&
				lpStgArea->lpCharMonster[cnt]->MotionInfo->State!=CHRMOTION_STATE_DEAD ) {

					x = lpStgArea->lpCharMonster[cnt]->pX>>FLOATNS;
					z = lpStgArea->lpCharMonster[cnt]->pZ>>FLOATNS;

					if ( x>rsHardCoreEventOpenPos[StagePos][0].x && x<rsHardCoreEventOpenPos[StagePos][1].x &&
						z>rsHardCoreEventOpenPos[StagePos][1].z && z<rsHardCoreEventOpenPos[StagePos][0].z ) {

							lpStgArea->lpCharMonster[cnt]->SetMotionFromCode(CHRMOTION_STATE_DAMAGE);
							lpStgArea->lpCharMonster[cnt]->PlaySlowCount = 16*15;		//15초간 얼린다
							lpStgArea->lpCharMonster[cnt]->PlaySlowSpeed = 0;
						}
			}
		}
	}


	return TRUE;
}


//토끼인형 아이템 적용
int rsSoD_CatchItem_SD204( rsPLAYINFO *lpPlayInfo , int StagePos , STG_AREA	*lpStgArea )
{
	int cnt;
	int x,z;
	int RndCnt = -1;
	smCHAR_INFO	*lpCharInfo=0;
	smCHAR_MONSTER_INFO	*lpMonInfo;

	smCHAR_INFO	*lpCharInfoBoss=0;
	smCHAR_MONSTER_INFO	*lpMonInfoBoss;

	int Param;

	//래비 변신
	for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {

		if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_RABIE && chrMonsterList[cnt].szName[0]!=' ' ) {
			if ( !lpCharInfo ) {
				lpCharInfo = &chrMonsterList[cnt];
				lpMonInfo = &chrMonInfoList[cnt];
			}
		}

		if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_MUTANTRABIE && chrMonsterList[cnt].wPlayClass[0]==MONSTER_CLASS_BOSS ) {
			if ( !lpCharInfoBoss && chrMonsterList[cnt].wPlayClass[0]==MONSTER_CLASS_BOSS ) {
				lpCharInfoBoss = &chrMonsterList[cnt];
				lpMonInfoBoss = &chrMonInfoList[cnt];
			}
		}

	}

	if ( !lpCharInfo ) return FALSE;


	for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
		if ( lpStgArea->lpCharMonster[cnt] ) {
			if ( lpStgArea->lpCharMonster[cnt]->Flag && lpStgArea->lpCharMonster[cnt]->PartyFlag==rsHARDCORE_EVENT_FLAG &&
				lpStgArea->lpCharMonster[cnt]->MotionInfo->State!=CHRMOTION_STATE_DEAD && 
				lpStgArea->lpCharMonster[cnt]->smCharInfo.wPlayClass[0]!=MONSTER_CLASS_BOSS ) {

					x = lpStgArea->lpCharMonster[cnt]->pX>>FLOATNS;
					z = lpStgArea->lpCharMonster[cnt]->pZ>>FLOATNS;

					if ( x>rsHardCoreEventOpenPos[StagePos][0].x && x<rsHardCoreEventOpenPos[StagePos][1].x &&
						z>rsHardCoreEventOpenPos[StagePos][1].z && z<rsHardCoreEventOpenPos[StagePos][0].z ) {

							RndCnt = lpStgArea->lpCharMonster[cnt]->PartyParam;

							if ( (rand()%2)==0 ) {
								Param = lpStgArea->lpCharMonster[cnt]->PartyParam;
								rsCharChanger( lpStgArea->lpCharMonster[cnt] , lpCharInfo , lpMonInfo );

								lpStgArea->lpCharMonster[cnt]->PartyFlag = rsHARDCORE_EVENT_FLAG;
								lpStgArea->lpCharMonster[cnt]->PartyParam = Param;

								lpStgArea->lpCharMonster[cnt]->DistAroundDbl =  (12*64 * 12*64);
								lpStgArea->lpCharMonster[cnt]->smCharInfo.Sight = 800*800;			//시야 조정
							}

						}
				}
		}
	}

	if ( lpCharInfoBoss || RndCnt<0 ) {

		STG_CHAR_INFO		 StgCharInfo;
		smCHAR				*lpChar;
		smTRANS_COMMAND_EX	TransCommandEx;

		StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;

		memcpy(	&StgCharInfo.smCharInfo , lpCharInfoBoss  , sizeof( smCHAR_INFO ) ); 

		lpStgArea->EvnMonster = TRUE;
		lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
		if ( lpChar ) {
			lpChar->pX = rsHardCoreEventOpenPos[RndCnt][2].x*fONE;
			lpChar->pY = rsHardCoreEventOpenPos[RndCnt][2].y*fONE;
			lpChar->pZ = rsHardCoreEventOpenPos[RndCnt][2].z*fONE;

			lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
			lpChar->TargetMoveCount = 0;
			lpChar->PartyFlag = rsHARDCORE_EVENT_FLAG;
			lpChar->PartyParam = RndCnt;

			lpChar->PosiAround.x = rsHardCoreEventOpenPos[RndCnt][2].x*fONE;
			lpChar->PosiAround.y = rsHardCoreEventOpenPos[RndCnt][2].y*fONE;
			lpChar->PosiAround.z = rsHardCoreEventOpenPos[RndCnt][2].z*fONE;
			lpChar->DistAroundDbl =  (12*64 * 12*64);

			lpChar->smCharInfo.Sight = 800*800;			//시야 조정

			ZeroMemory( &TransCommandEx , sizeof(smTRANS_COMMAND_EX) );
			TransCommandEx.WParam = smCOMMNAD_USER_WARP;
			TransCommandEx.LParam = lpChar->pX;
			TransCommandEx.SParam = lpChar->pY;
			TransCommandEx.EParam = lpChar->pZ;
			rsSendCommandUser( lpPlayInfo , &TransCommandEx );			//이펙트 호출

		}

	}
	

	return TRUE;
}

//몬스터 소환 적용
int rsSoD_CatchItem_SD205( rsPLAYINFO *lpPlayInfo , int StagePos , STG_AREA	*lpStgArea , DWORD MonSndCode , int Level )
{
	int cnt;
	int x,y,z;
	smCHAR_INFO	*lpCharInfo=0;
	smCHAR_MONSTER_INFO	*lpMonInfo;


	for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {

		if ( chrMonsterList[cnt].dwCharSoundCode==MonSndCode && ( Level==0 || chrMonsterList[cnt].Level==Level ) ) {
			if ( !lpCharInfo ) {
				lpCharInfo = &chrMonsterList[cnt];
				lpMonInfo = &chrMonInfoList[cnt];
				break;
			}
		}
	}

	if ( !lpCharInfo || StagePos<0 ) return FALSE;


	STG_CHAR_INFO		 StgCharInfo;
	smCHAR				*lpChar;
	smTRANS_COMMAND_EX	TransCommandEx;

	StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
	StgCharInfo.smCharInfo.Life[0] = 100;
	StgCharInfo.smCharInfo.Mana[0] = 100;
	StgCharInfo.smCharInfo.Life[1] = 100;
	StgCharInfo.smCharInfo.State = TRUE;

	x = rsHardCoreEventOpenPos[StagePos][2].x*fONE;
	y = rsHardCoreEventOpenPos[StagePos][2].y*fONE;
	z = rsHardCoreEventOpenPos[StagePos][2].z*fONE;

	lpStgArea->EvnMonster = TRUE;
	memcpy(	&StgCharInfo.smCharInfo , lpCharInfo  , sizeof( smCHAR_INFO ) ); 

	lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
	if ( lpChar ) {
		lpChar->lpMasterPlayInfo = lpPlayInfo;
		lpChar->smMonsterInfo.dwAutoCharCode = 0;
		lpChar->smCharInfo.Brood = smCHAR_MONSTER_USER;						//몬스터 종족 (유저편)
		lstrcpy( lpChar->smCharInfo.szModelName2+1 , lpPlayInfo->smCharInfo.szName );	//주인 이름
		lpChar->smCharInfo.Next_Exp = lpPlayInfo->dwObjectSerial;						//주인 시리얼 코드 저장
		lpChar->dwUpdateCharInfoTime = dwPlayServTime+4*60*1000;						//4분후 제거

		lpChar->pX = x;
		lpChar->pY = y;
		lpChar->pZ = z;

		ZeroMemory( &TransCommandEx , sizeof(smTRANS_COMMAND_EX) );
		TransCommandEx.WParam = smCOMMNAD_USER_WARP;
		TransCommandEx.LParam = x;
		TransCommandEx.SParam = y;
		TransCommandEx.EParam = z;
		rsSendCommandUser( lpPlayInfo , &TransCommandEx );			//이펙트 호출

	}

	return TRUE;
}



//점수 주머니 아이템 적용
int rsSoD_CatchItem_SD207( rsPLAYINFO *lpPlayInfo , int StagePos , STG_AREA	*lpStgArea )
{
	//int cnt;
	//int SndCnt = 0;
	int team = lpPlayInfo->sEventParam[0];

	if ( team<0 || team>=4 ) return FALSE;
/*
	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial) {

			if ( rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG &&
				rsPlayInfo[cnt].sEventParam[0]==team &&
				rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x, rsPlayInfo[cnt].Position.y, rsPlayInfo[cnt].Position.z )==TRUE ) {

					rsPlayInfo[cnt].EventScore += 5000;
					rsSodTeamScore[ team ] +=5000;		//팀득점에 추가

					//Sod 점수 업그레이드
					rsTransUpdateSod( &rsPlayInfo[cnt] );
				}
		}
	}
*/

	if ( lpPlayInfo->EventMode==rsHARDCORE_EVENT_FLAG && rsCheckHardCoreEventArea( lpPlayInfo->Position.x, lpPlayInfo->Position.y, lpPlayInfo->Position.z )==TRUE ) {

		lpPlayInfo->EventScore += 5000;
		rsSodTeamScore[ team ] +=5000;		//팀득점에 추가

		//Sod 점수 업그레이드
		rsTransUpdateSod( lpPlayInfo );
	}

	return TRUE;
}

//SoD 유저에게 명령 전송
int	rsSendCommandSodUserTeam( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND	*lpTransCommandEx )
{
	int cnt;
	int SndCnt = 0;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial) {

			if ( rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG &&
				rsPlayInfo[cnt].sEventParam[0]==lpPlayInfo->sEventParam[0] &&
				rsCheckHardCoreEventArea( rsPlayInfo[cnt].Position.x, rsPlayInfo[cnt].Position.y, rsPlayInfo[cnt].Position.z )==TRUE ) {

					rsPlayInfo[cnt].lpsmSock->Send2( (char *)lpTransCommandEx , lpTransCommandEx->size , TRUE );
					SndCnt++;
				}
		}
	}

	return TRUE;
}



//SOD 아이템 잡다 / 적용시키기
int	rsSoD_CatchItem( DWORD dwItemCode , rsPLAYINFO *lpPlayInfo )
{

	int	StagePos;
	int cnt;
	STG_AREA	*lpStgArea;
	int x,z;
	smTRANS_COMMAND	smTransCommand;

	StagePos = -1;

	x = lpPlayInfo->Position.x>>FLOATNS;
	z = lpPlayInfo->Position.z>>FLOATNS;

	for(cnt=0;cnt<7;cnt++) {
		if ( x>rsHardCoreEventOpenPos[cnt][0].x && x<rsHardCoreEventOpenPos[cnt][1].x &&
			z>rsHardCoreEventOpenPos[cnt][1].z && z<rsHardCoreEventOpenPos[cnt][0].z ) {

				StagePos = cnt;
				break;
			}
	}


	lpStgArea = &StageArea[rsSOD_FIELD];
	if ( !lpStgArea->lpStage ) return FALSE;

	smTransCommand.code = smTRANSCODE_PROCESS_SKILL;;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam = SKILL_PLAY_SOD_ITEM;
	smTransCommand.LParam = lpPlayInfo->dwObjectSerial;

	if ( StagePos>=0 && lpStgArea ) {
		switch( dwItemCode ) {
			case (sinSD2|sin01):
				rsSoD_CatchItem_SD201( lpPlayInfo , StagePos , lpStgArea );		//폭탄

				smTransCommand.SParam = 1;
				smTransCommand.EParam = 0;
				rsSendCommandSodUserTeam( lpPlayInfo , &smTransCommand );
				break;

			case (sinSD2|sin02):
				rsSoD_CatchItem_SD202( lpPlayInfo , StagePos , lpStgArea );		//시계

				smTransCommand.SParam = 2;
				smTransCommand.EParam = 0;
				rsSendCommandSodUserTeam( lpPlayInfo , &smTransCommand );
				break;

			case (sinSD2|sin03):
				rsSoD_CatchItem_SD203( lpPlayInfo , StagePos , lpStgArea );		//얼음보송이

				smTransCommand.SParam = 3;
				smTransCommand.EParam = 0;
				rsSendCommandSodUserTeam( lpPlayInfo , &smTransCommand );
				break;

			case (sinSD2|sin04):
				rsSoD_CatchItem_SD204( lpPlayInfo , StagePos , lpStgArea );		//토끼인형

				smTransCommand.SParam = 4;
				smTransCommand.EParam = 0;
				rsSendCommandSodUserTeam( lpPlayInfo , &smTransCommand );
				break;

			case (sinSD2|sin05):
				rsSoD_CatchItem_SD205( lpPlayInfo , StagePos , lpStgArea , snCHAR_SOUND_STYGIANLORD , 85 );		//스티지언

				smTransCommand.SParam = 5;
				smTransCommand.EParam = 0;
				rsSendCommandSodUserTeam( lpPlayInfo , &smTransCommand );
				break;

			case (sinSD2|sin06):
				rsSoD_CatchItem_SD205( lpPlayInfo , StagePos , lpStgArea , snCHAR_SOUND_GUARDIAN_SAINT , 0 );	//가디안

				smTransCommand.SParam = 6;
				smTransCommand.EParam = 0;
				rsSendCommandSodUserTeam( lpPlayInfo , &smTransCommand );
				break;

			case (sinSD2|sin07):
				rsSoD_CatchItem_SD207( lpPlayInfo , StagePos , lpStgArea  );	//점수 5000 업

				smTransCommand.SParam = 7;
				smTransCommand.EParam = 0;

				lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
				//rsSendCommandSodUserTeam( lpPlayInfo , &smTransCommand );
				break;

		}
	}

	return TRUE;
}



////////////////////////////////////////////////////////////////////////////////////////////


//이벤트 NPC
int SendOpenEvent( smCHAR *lpChar , rsPLAYINFO *lpPlayInfo , int EventFlag )
{
	TRANS_CHATMESSAGE	TransChatMessage;
	smWINSOCK *lpsmSock;
	int	NpcTeam;
	int	MsgNum = -1;
	int MsgCnt = lpChar->smMonsterInfo.NpcMsgCount;


	NpcTeam = lpChar->smMonsterInfo.EventNPC;
	if ( NpcTeam<=0 || NpcTeam>4 ) return FALSE;

	lpPlayInfo->sEventParam[0] = NpcTeam-1;

	lpsmSock = lpPlayInfo->lpsmSock;

	TransChatMessage.szMessage[0] = 0;
	TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
	TransChatMessage.dwIP = 0;
	TransChatMessage.dwObjectSerial = lpChar->dwObjectSerial;


	if ( !rsServerConfig.Event_HardCore ) return FALSE;			//서버에서 이벤트 하지 않음

	if ( !rsHardCoreEventMode ) {
		//응답 메세지 보냄 ( 입장 시간이 아님 )
		if ( MsgCnt ) {
			lstrcpy( TransChatMessage.szMessage , lpChar->smMonsterInfo.lpNpcMessage[ 5+rand()%3 ] );
		}
		else
			lstrcpy( TransChatMessage.szMessage , srMsg_108 );

		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		return TRUE;
	}

	if ( lpPlayInfo->smCharInfo.Level< 40  ) {			//벨라트라 렙제 확인 (성근수정)
		//응답 메세지 보냄
		//응답 메세지 보냄 ( 입장 시간이 아님 )
		if ( MsgCnt ) {
			lstrcpy( TransChatMessage.szMessage , lpChar->smMonsterInfo.lpNpcMessage[ 8 ] );
		}
		else
			lstrcpy( TransChatMessage.szMessage , srMsg_107 );

		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsSod_GetRealTimeScore( lpPlayInfo , NpcTeam );		//SoD 진행 상황 출력
		if ( lpPlayInfo->EventMode==0 )	lpPlayInfo->sEventParam[0] = NpcTeam-1;

		return TRUE;
	}

	if ( (rsHardCoreEvent_TicketHour!=dwServ_GameTimeHour && (rsHardCoreEvent_TicketHour+1)!=dwServ_GameTimeHour) ||
		rsEventTicketLevel[NpcTeam-1]>rsEVENT_TICKET_LEVEL_TOTAL ) {

		if ( MsgCnt ) {
			lstrcpy( TransChatMessage.szMessage , lpChar->smMonsterInfo.lpNpcMessage[ 2+rand()%3 ] );
		}
		else {
			if ( (dwServ_GameTimeHour&1)==0 )
				lstrcpy( TransChatMessage.szMessage , srMsg_100 );
			else
				lstrcpy( TransChatMessage.szMessage , srMsg_101 );
		}

		//응답 메세지 보냄
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsSod_GetRealTimeScore( lpPlayInfo , NpcTeam );		//SoD 진행 상황 출력
		if ( lpPlayInfo->EventMode==0 )	lpPlayInfo->sEventParam[0] = NpcTeam-1;

		return TRUE;
	}

	if ( MsgCnt ) {
		lstrcpy( TransChatMessage.szMessage , lpChar->smMonsterInfo.lpNpcMessage[ 0 ] );
	}
	else {
		lstrcpy( TransChatMessage.szMessage , srMsg_102 );
	}

	//응답 메세지 보냄
	TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
	lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	lpPlayInfo->EventMode = EventFlag;

	//불우이웃돕기 모금 NPC
	SendOpenCollectMoney( lpsmSock );

	return TRUE;
}

//이벤트 입장
int rsEnterHardCoreEvent( rsPLAYINFO *lpPlayInfo , int Money )
{
	int cnt;
	//TRANS_ITEMINFO	TransItemInfo;
	TRANS_CHATMESSAGE	TransChatMessage;
	smTRANS_COMMAND		smTransCommand;

	if ( lpPlayInfo->sEventParam[0]<0 || lpPlayInfo->sEventParam[0]>=4 ) return FALSE;

	if ( lpPlayInfo->AdminMode && Money==-1 ) goto skip_enterSOD;

	if ( rsEventTicketLevel[lpPlayInfo->sEventParam[0]]>rsEVENT_TICKET_LEVEL_TOTAL ||
		(DWORD)rsHardCoreEvent_TicketHour>dwServ_GameTimeHour ||
		((DWORD)rsHardCoreEvent_TicketHour+2)<dwServ_GameTimeHour ) {

		//실패 돈을 돌려 준다
/*
		ZeroMemory( &TransItemInfo , sizeof( TRANS_ITEMINFO ) );

		TransItemInfo.code = smTRANSCODE_PUTITEM;
		TransItemInfo.size = sizeof(TRANS_ITEMINFO);

		TransItemInfo.Item.CODE = ( sinGG1|sin01 );
		TransItemInfo.Item.Money = Money;
		wsprintf( TransItemInfo.Item.ItemName , sinGold , Money );
		ReformItem( &TransItemInfo.Item );

		lpPlayInfo->spMoney_Out += TransItemInfo.Item.Money;				//출금 기록
		TransItemInfo.x = dwPlayServTime;											//해독 키
		TransItemInfo.y = TransItemInfo.Item.ItemHeader.dwChkSum;					//해독 키2
		TransItemInfo.z = lpPlayInfo->spMoney_Out^(TransItemInfo.x+TransItemInfo.y);	//토탈 기록 전송
		rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
		lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
*/


		//지역서버 경우
		if ( dwSerToSerIP )
			rsSendMoneyToSystemLine( lpPlayInfo , Money );
		else	//돈을 유저에게 직접 보낸다
			rsSendMoneyToUser( lpPlayInfo , Money );


		lstrcpy( TransChatMessage.szMessage , srMsg_106 );
		TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send2( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return FALSE;
	}

skip_enterSOD:
	//int	GateNum = rand()%4;		//입장 일단은 랜덤

	for( cnt=0;cnt<STAGE_AREA_MAX;cnt++) {
		if ( StageArea[cnt].lpStage && StageArea[cnt].lpField->FieldCode==rsSOD_FIELD ) {
			smTransCommand.WParam = StageArea[cnt].lpField->FieldCode;
			smTransCommand.code = smTRANSCODE_WARPFIELD;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.SParam = rsHardCoreEventOpenPos[lpPlayInfo->sEventParam[0]][2].x*fONE;
			smTransCommand.LParam = rsHardCoreEventOpenPos[lpPlayInfo->sEventParam[0]][2].z*fONE;
			lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
			rsEventTicketCount++;
			rsEventTicketLevel[lpPlayInfo->sEventParam[0]] += lpPlayInfo->smCharInfo.Level;
			lpPlayInfo->EventMode = rsHARDCORE_EVENT_FLAG;
			lpPlayInfo->EventScore = 0;
			lpPlayInfo->EventCount = 0;
			lpPlayInfo->dwEventTime = dwPlayServTime;
			//lpPlayInfo->sEventParam[0] = GateNum;
			lpPlayInfo->sEventParam[1] = 0;

			lpPlayInfo->Position.x = smTransCommand.SParam;
			lpPlayInfo->Position.z = smTransCommand.LParam;

			rsHardCoreEvent_TotalUser ++;

			//입장유저 리스트 제작
			if ( rsSodUserCount<rsSOD_USER_MAX ) {
				rsSodUser[rsSodUserCount].lpPlayInfo = lpPlayInfo;
				rsSodUser[rsSodUserCount].dwConnCode = lpPlayInfo->dwConnectCount;
				rsSodUserCount++;
			}

		}
	}

	return TRUE;
}


#else
///////////////// 클라이언트 모드 //////////////////
//하드코어 이벤트 초기화
int	rsInitHardCoreEvent()
{
	return TRUE;
}
int rsHardCoreEvent_OpenMonster( STG_AREA *lpStgArea , STG_CHAR_INFO *lpStgCharInfo )
{
	return TRUE;
}
//득점 상황 표시
int rsShowHardCoreEventScore( rsPLAYINFO *lpPlayInfo )		
{
	return TRUE;
}

#endif

//이벤트 지역인지 첵크
int rsCheckHardCoreEventArea( int x, int y, int z ) 
{
	int mx,my,mz;

	mx = x>>FLOATNS;
	my = y>>FLOATNS;
	mz = z>>FLOATNS;

	if ( y>=rsHardCoreEventOpenPos[0][0].y-32 ) {
		
		if ( rsHardCoreEventArea[0]<mx && rsHardCoreEventArea[1]>mx &&
			rsHardCoreEventArea[2]<mz && rsHardCoreEventArea[3]>mz ) {


				return TRUE;
			}
	}

	return FALSE;
}

//SOD 지역번호 구하기
int rsGetSoD_AreaCode( int x, int y, int z ) 
{
	int mx,my,mz;
	int cnt;


	mx = x>>FLOATNS;
	my = y>>FLOATNS;
	mz = z>>FLOATNS;

	if ( y>=rsHardCoreEventOpenPos[0][0].y-32 ) {

		if ( rsHardCoreEventArea[0]<mx && rsHardCoreEventArea[1]>mx &&
			rsHardCoreEventArea[2]<mz && rsHardCoreEventArea[3]>mz ) {

				for(cnt=0;cnt<7;cnt++) {

					if ( mx>rsHardCoreEventOpenPos[cnt][0].x && mx<rsHardCoreEventOpenPos[cnt][1].x &&
						mz>rsHardCoreEventOpenPos[cnt][1].z && mz<rsHardCoreEventOpenPos[cnt][0].z ) {

							return cnt;
						}
				}

			}
	}

	return -1;
}




WORD	wLastCheckDay =0;
WORD	wLastCheckHour = 0;
WORD	wLastCheckMin = 0;
static	int EventBossMonsterFlag = 0;
DWORD	dwEventBossMonterTime = 0;
int		OpenBossTimeMin = 1;			//보스 몬스터 출현 분


//이벤트 몬스터 시간 구하기
int EventMonsterTime()
{
	SYSTEMTIME	st;

	int cnt,cnt2,cnt3;

	GetLocalTime( &st );

	EventMonster = FALSE;

	if ( wLastCheckHour!=st.wHour && st.wHour==rsBLESSCASTLE_TAX_TIME ) {
		rsBlessCastle.Tax = rsBlessCastle.NextTax;		//세율 미리 적용 (디버깅용)
		rsBlessCastle.SelectedSkill = rsBlessCastle.BlessCastleSetup.ClanSkill;	//선택된 스킬 적용
	}

	//공성전 시작 시간 확인 ( 요일 , 시간 일치시 )
	if ( rsServerConfig.sBlessCastle_StartTime[0] && rsServerConfig.sBlessCastle_StartTime[1] ) {
		if ( rsServerConfig.BlessCastleMode ) {
			if ( !rsBlessCastle.CastleMode && wLastCheckHour!=st.wHour &&
				st.wDayOfWeek==rsServerConfig.sBlessCastle_StartTime[0] && 
				st.wHour==rsServerConfig.sBlessCastle_StartTime[1] ) 
			{
				rsStart_CombatCastle();			//공성전 시작
			}
		}

		if ( wLastCheckMin==29 && st.wMinute==30 &&
			st.wDayOfWeek==rsServerConfig.sBlessCastle_StartTime[0] && 
			st.wHour==rsServerConfig.sBlessCastle_StartTime[1]-1 ) 
		{	//미리 공지 (30분전)
			//공지사항을 설정한다
			rsSetNoticeMessage( srBlessCastle_LeagueMsg_04 );		//공성전 준비 메세지
		}
		if ( wLastCheckHour==rsServerConfig.sBlessCastle_StartTime[1]-2 &&
			st.wDayOfWeek==rsServerConfig.sBlessCastle_StartTime[0] && 
			st.wHour==rsServerConfig.sBlessCastle_StartTime[1]-1 ) 
		{	//미리 공지 (1시간전)
			//공지사항을 설정한다
			rsSetNoticeMessage( srBlessCastle_LeagueMsg_05 );		//공성전 준비 메세지
		}
	}



	//서버이블 오어 다이 시간대별 게임모드
	if ( rsServerConfig.Event_HardCore==2 ) {
		rsHardCoreEventMode = TRUE;						//풀터임 ( 언제나 )
	}
	else {
		rsHardCoreEventMode = FALSE;
#ifndef		_LANGUAGE_ENGLISH
#ifdef	_LANGUAGE_JAPANESE		//0x57
		if ( st.wDayOfWeek==0 || st.wDayOfWeek==6 )
		{
			rsHardCoreEventMode = TRUE;					//주말 , 일요일을 제한 없이 사용
		}
		else {
			if ( st.wHour>=14 || st.wHour<2 ) {			//평일 14~2 시까지
			//if ( st.wHour>=16 || st.wHour<1 ) {			//평일 16~1 시까지
				rsHardCoreEventMode = TRUE;					//주말 , 일요일을 제한 없이 사용
			}
		}
#else
#ifdef _LANGUAGE_CHINESE
		if ( st.wDayOfWeek >= 0 && st.wDayOfWeek <= 6 )	//월화수목금토일
		{
			if ( st.wHour >= 20 && st.wHour < 22 )		// pm8시-pm10시까지
			{
				rsHardCoreEventMode = TRUE;
			}
			else
			{
				rsHardCoreEventMode = FALSE;			// 이외는 안돼
			}
		}
		else											// 이외는 안돼
		{
			rsHardCoreEventMode = FALSE;
		}

#else
#ifdef _LANGUAGE_VEITNAM
		if ( st.wDayOfWeek==0 || st.wDayOfWeek==6 ) 
		{
			if ( st.wHour>=7 || st.wHour<3 )
				rsHardCoreEventMode = TRUE;	
			
		}
		else {

			if ( st.wHour>=8 || st.wHour<2 )
				rsHardCoreEventMode = TRUE;					//주말 , 일요일을 제한 없이 사용			
		}
#else
#ifdef _LANGUAGE_BRAZIL
		if ( st.wDayOfWeek==0 || st.wDayOfWeek==6 ) //주말에는 하루종일
		{
				rsHardCoreEventMode = TRUE;	
		}
		else {
			if ( st.wHour>=14 || st.wHour<4 )//평일에는 오후2시~오전4시
				rsHardCoreEventMode = TRUE;
		}
#else

		if ( st.wHour>=0 && st.wHour<6 ) {			//평일 16~1 시까지

			rsHardCoreEventMode = TRUE;					//주말 , 일요일을 제한 없이 사용
		}
		else if ( st.wHour>=12 && st.wHour<18 ) {			//평일 16~1 시까지

			rsHardCoreEventMode = TRUE;					//주말 , 일요일을 제한 없이 사용
		}
#endif
#endif
#endif
#endif
#else
#ifdef _LANGUAGE_PHILIPIN
		if ( st.wHour>=20 || st.wHour<2 )	rsHardCoreEventMode = TRUE;	
		else if ( st.wHour>=13 && st.wHour<19 )		rsHardCoreEventMode = TRUE;					//주말 , 일요일을 제한 없이 사용
#else

		if ( st.wHour>=0 && st.wHour<6 ) {			//평일 16~1 시까지

			rsHardCoreEventMode = TRUE;					//주말 , 일요일을 제한 없이 사용
		}
		else if ( st.wHour>=12 && st.wHour<18 ) {			//평일 16~1 시까지

			rsHardCoreEventMode = TRUE;					//주말 , 일요일을 제한 없이 사용
		}
#endif
#endif
	}


#ifdef _LANGUAGE_JAPANESE
	//공격력 활인 이벤트
	if ( rsServerConfig.Event_DamageOff ) {
		if ( (st.wHour>=10 && st.wHour<14) || st.wHour>=22 || st.wHour<2 ) {	//오후 12~1 8~10 시 이벤트 진행
			rsDamgeOffEvent = TRUE;
		}
		else {
			rsDamgeOffEvent = FALSE;
		}
	}
	//일본 3차 스킬 관련 이벤트 변경 요청에 의한 .............
#else
#ifdef _LANGUAGE_PHILIPIN
	//공격력 활인 이벤트
// 필리핀은 1, 2로 적용해서 임시로 주석처리
//	if ( rsServerConfig.Event_DamageOff ) rsDamgeOffEvent = TRUE;
//	else  rsDamgeOffEvent = FALSE;

	if ( rsServerConfig.Event_DamageOff1 ) rsDamgeOffEvent1 = TRUE;
	else  rsDamgeOffEvent1 = FALSE;

	if ( rsServerConfig.Event_DamageOff2 ) rsDamgeOffEvent2 = TRUE;
	else  rsDamgeOffEvent2 = FALSE;
#else
	//공격력 활인 이벤트
	if ( rsServerConfig.Event_DamageOff ) 
	{
		if ( (st.wHour>=0 && st.wHour<6) || st.wHour>=12 && st.wHour<18 )
		{	//오후 12~1 8~10 시 이벤트 진행
			rsDamgeOffEvent = TRUE;
		}
		else
		{
			rsDamgeOffEvent = FALSE;
		}
	}
#endif
#endif
	//만약 2값이 들어오게 되면 TRUE 값을 준다
	if ( rsServerConfig.Event_DamageOff == 2) rsDamgeOffEvent = TRUE;

//#ifdef _LANGUAGE_PHILIPIN //(필리핀 추가부분)
	if ( rsServerConfig.Event_DamageOff1 == 2) rsDamgeOffEvent1 = TRUE;
	if ( rsServerConfig.Event_DamageOff2 == 2) rsDamgeOffEvent2 = TRUE;
//#endif

//★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★//
//(해외)몬스터 방어력 약화 이벤트
	if( rsServerConfig.Event_DefenseOff)
	{
		if((st.wHour >= 0 && st.wHour < 6) || st.wHour >= 12 && st.wHour < 18)
		{
			rsDefenseOffEvent = TRUE;
		}
		else
		{
			rsDefenseOffEvent = FALSE;
		}
	}
	if( rsServerConfig.Event_DefenseOff == 2) rsDefenseOffEvent = TRUE;
//★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★//
/*
	//몬스터 크리스탈 이벤트(원본)
	if ( rsServerConfig.Event_Cristal ) {
		if ( (st.wHour>=12 && st.wHour<14) || (st.wHour>=20 && st.wHour<22) || rsServerConfig.Event_Cristal==2 ) {	//오후 12~1 8~10 시 이벤트 진행
			rsCristalEvent = TRUE;
		}
		else {
			rsCristalEvent = FALSE;
		}
	}
	else
		rsCristalEvent = FALSE;
*/
	//몬스터 크리스탈 이벤트
	if ( rsServerConfig.Event_Cristal )
	{
		if(st.wDayOfWeek != 0 || st.wDayOfWeek != 6)
		{
			if ( (st.wHour>=12 && st.wHour<=23) || rsServerConfig.Event_Cristal==2 )	//오후 12 - 24 시 이벤트 진행(국문용)
			{
				rsCristalEvent = TRUE;
			}
			else
			{
				rsCristalEvent = FALSE; // 혹시 몰라서 넣는다.
			}
		}
		else if(st.wDayOfWeek == 0 || st.wDayOfWeek == 6)	// 주말이면 24시간 돌린다. 0:일요일 6:토요일
		{
			rsCristalEvent = TRUE;
		}
		else
		{
			rsCristalEvent = FALSE;
		}
	}
	else
		rsCristalEvent = FALSE;
/*
#ifdef _LANGUAGE_TAIWAN
	if ( st.wMonth==8 && ( st.wDay>=29 && st.wDay<=31 ) ) {			//8월 29~31일
		if ( st.wHour>=19 && st.wHour<=23 )	{	//오후 7시~12시
			EventMonster = TRUE;
		}
	}

	if ( st.wMonth==9 && st.wDay==1) {			//9월 1일
		if ( st.wHour>=19 && st.wHour<=23 )	{	//오후 7시~12시
			EventMonster = TRUE;
		}
	}
#endif
*/
	if ( wLastCheckDay!=st.wDay ) {
		//날짜 바뀜 감지
		//아이템 날짜별 생성 카운터 초기화
		for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
			if ( DefaultItems[cnt2].sGenDay[0] ) {
				DefaultItems[cnt2].sGenDay[1] = 0;
			}
		}
		wLastCheckDay = st.wDay;
		OpenBossTimeMin = (rand()%45)+1;		//1~46분 중 하나선택

		//경험치 시간분배 (베트남) 날짜전환 초기화
		if ( rsServerConfig.ExpGameTimeMode ) {
			for(cnt=0;cnt<CONNECTMAX;cnt++) 
			{
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwExpGameTime )
					rsPlayInfo[cnt].dwExpGameTime = 0;
			}
		}

	}


	//보스급 몬스터 출현 ( 1시간 마다 확인 )
	if ( !EventBossMonsterFlag && st.wMinute==OpenBossTimeMin && (dwEventBossMonterTime+60*1000*10)<dwPlayServTime ) {
		for( cnt=0;cnt<STAGE_AREA_MAX;cnt++) {
			if ( StageArea[cnt].lpStage ) {
				if ( StageArea[cnt].rsMonsterList.BossMonsterCount>0 ) {
					for( cnt2=0;cnt2<StageArea[cnt].rsMonsterList.BossMonsterCount;cnt2++ ) {
						for(cnt3=0;cnt3<StageArea[cnt].rsMonsterList.sBossMonsters[cnt2].OpenTimeCount;cnt3++ ) {
							if ( st.wHour==StageArea[cnt].rsMonsterList.sBossMonsters[cnt2].bOpenTime[cnt3] ) {

								//보스 몬스터세트 생성
								rsOpenBossMonster( &StageArea[cnt] , &StageArea[cnt].rsMonsterList.sBossMonsters[cnt2] );
								break;
							}
						}
					}
				}
			}
		}
		EventBossMonsterFlag = TRUE;
		dwEventBossMonterTime = dwPlayServTime;
	}
	else {
		if ( EventBossMonsterFlag && st.wMinute!=OpenBossTimeMin ) {
			EventBossMonsterFlag = 0;
		}
	}

	wLastCheckHour = st.wHour;
	wLastCheckMin = st.wMinute;

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////////////





STG_AREA::STG_AREA()
{
	ZeroMemory( &Head , sizeof( STG_AREA ) );
}
/*
STG_AREA::~STG_AREA()
{

}
*/
//클래스 닫기
int STG_AREA::Close()
{
	if ( lpStageCharInfo ) { delete lpStageCharInfo;lpStageCharInfo=0; }
	if ( lpStage ) { delete lpStage;lpStage=0; }

	return TRUE;
}


//고정 캐릭터 정보 찾기
smTRNAS_PLAYERINFO *STG_AREA::FindCharInfoFixed( smTRNAS_PLAYERINFO *lpTransPlayerInfo )
{
	int cnt;

	if ( lpTransPlayerInfo ) {
		for( cnt=0;cnt<FIX_CHAR_MAX;cnt++) {
			if ( TransCharFixed[cnt].code &&
				TransCharFixed[cnt].dwObjectSerial==lpTransPlayerInfo->dwObjectSerial ) 
				return &TransCharFixed[cnt];
		}
	}
	else {
		for( cnt=0;cnt<FIX_CHAR_MAX;cnt++) {
			if ( TransCharFixed[cnt].code==0 ) return &TransCharFixed[cnt];
		}
	}

	return NULL;
}


//고정 캐릭터 정보 추가
int STG_AREA::AddCharInfoFixed( smTRNAS_PLAYERINFO *lpTransPlayerInfo )
{
	smTRNAS_PLAYERINFO	*lpFindPlayerInfo;

	lpFindPlayerInfo = FindCharInfoFixed( lpTransPlayerInfo );
	if ( lpFindPlayerInfo ) return FALSE;

	lpFindPlayerInfo = FindCharInfoFixed( 0 );
	if ( lpFindPlayerInfo ) {
		rsOpenNPC_RandomPos = -1;
		memcpy( lpFindPlayerInfo , lpTransPlayerInfo , sizeof( smTRNAS_PLAYERINFO ) );
		OpenNpc( lpFindPlayerInfo );
		SaveCharInfoFixed( szCharFixedFile );
		return TRUE;
	}

	return FALSE;
}

//고정 캐릭터 정보 제거
int STG_AREA::DeleteCharInfoFixed( smTRNAS_PLAYERINFO *lpTransPlayerInfo )
{
	smTRNAS_PLAYERINFO	*lpFindPlayerInfo;
	smCHAR	*lpChar;

	lpFindPlayerInfo = FindCharInfoFixed( lpTransPlayerInfo );
	if ( lpFindPlayerInfo ) {
		lpFindPlayerInfo->code = 0;
		//캐릭터를 찾는다 ( 나중에 빨리 칮을수 있게 코드화 시켜 바꿔 줘야 함 )
		lpChar = srFindCharFromSerial( lpTransPlayerInfo->dwObjectSerial );
		if ( lpChar ) {
			lpChar->Close();
		}
		SaveCharInfoFixed( szCharFixedFile );
		return TRUE;
	}

	return FALSE;
}


//고정 캐릭터 정보 읽어오기
int STG_AREA::LoadCharInfoFixed( char *szFile )
{
	FILE *fp;

	fp = fopen( szFile , "rb" );
	if ( fp ) {
		fread( TransCharFixed , sizeof(smTRNAS_PLAYERINFO)*FIX_CHAR_MAX , 1, fp );
		fclose(fp);
		return TRUE;
	}
	return FALSE;
}

//고정 캐릭터 정보 저장
int STG_AREA::SaveCharInfoFixed( char *szFile )
{
	FILE *fp;

	fp = fopen( szFile , "wb" );
	if ( fp ) {
		fwrite( TransCharFixed , sizeof(smTRNAS_PLAYERINFO)*FIX_CHAR_MAX , 1, fp );
		fclose(fp);
	}

	return TRUE;
}



//NPC 캐릭터 출현
int STG_AREA::OpenNpc( smTRNAS_PLAYERINFO *lpTransPlayerInfo )
{

	smCHAR *lpChar;
	char *lpFileName;
	int dist,cnt;


	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag && 
			chrAutoPlayer[cnt].smCharInfo.State==smCHAR_STATE_NPC &&
			chrAutoPlayer[cnt].pX==lpTransPlayerInfo->x &&
			chrAutoPlayer[cnt].pY==lpTransPlayerInfo->y &&
			chrAutoPlayer[cnt].pZ==lpTransPlayerInfo->z ) {

				//같은자리에 이미 NPC가 서있는 경우 취소

				return FALSE;
			}			
	}


	//빈캐릭터를 찾는다 
	lpChar = srFindEmptyChar();
	if ( lpChar ) {
		lpChar->Init();

		lpTransPlayerInfo->dwObjectSerial = GetNewObjectSerial();
		lpChar->pX = lpTransPlayerInfo->x;
		lpChar->pY = lpTransPlayerInfo->y;
		lpChar->pZ = lpTransPlayerInfo->z;
		lpChar->Angle.x = lpTransPlayerInfo->ax;
		lpChar->Angle.y = lpTransPlayerInfo->ay;
		lpChar->Angle.z = lpTransPlayerInfo->az;

		lpChar->PosiAround.x = lpTransPlayerInfo->x;
		lpChar->PosiAround.y = lpTransPlayerInfo->y;
		lpChar->PosiAround.z = lpTransPlayerInfo->z;
		lpChar->DistAroundDbl =  DIST_AROUND_NEAR;


		lpChar->lpExt1 = (void *)&Head;
		lpChar->dwObjectSerial = lpTransPlayerInfo->dwObjectSerial;
		lpChar->ActionPattern = 12;
		memcpy( &lpChar->smCharInfo , &lpTransPlayerInfo->smCharInfo , sizeof( smCHAR_INFO ) );

		//확장자 변경 해서 찾음
		lpFileName = lpChar->smCharInfo.szModelName2;
		if ( lpFileName[0] ) {
			//채팅 메세지 불러옴
			lpChar->szChatMessage[0] = 0;
			ZeroMemory( &lpChar->smMonsterInfo , sizeof( smCHAR_MONSTER_INFO ) );
			smCharDecode( lpFileName , &lpChar->smCharInfo , &lpChar->smMonsterInfo, lpChar->szChatMessage );

			if ( rsOpenNPC_RandomPos!=-1 && lpChar->smMonsterInfo.OpenCount[1] ) {
				if ( (rsOpenNPC_RandomPos%lpChar->smMonsterInfo.OpenCount[1])!=lpChar->smMonsterInfo.OpenCount[0] ) {
					lpChar->Flag = 0;
					return FALSE;
				}
			}

			//보조 NPC 이름 ( 외국버전 ) 있는경우 보조 이름으로 적용
			if ( lpChar->smMonsterInfo.szName[0] ) {
				lstrcpy( lpChar->smCharInfo.szName , lpChar->smMonsterInfo.szName );
				lpChar->smMonsterInfo.szName[0] = 0;
			}
			srLinkNpcItem( lpChar );
			//이동범위 설정
			dist = lpChar->smMonsterInfo.MoveRange>>FLOATNS;
			lpChar->DistAroundDbl =  dist*dist;
		}

		lpChar->SetLoadPattern( lpChar->smCharInfo.szModelName );
		lpChar->lpStage = lpStage;

		if ( lpChar->FindMotionCountFromCode(CHRMOTION_STATE_WALK)==0 ) {
			//걷는 동작 없는 NPC
			lpChar->MoveSpeed = 0;
		}

		return TRUE;
	}

	return FALSE;
}

//아이템을 찾는다
STG_ITEMS *STG_AREA::FindItem( int x, int y, int z )
{
	int cnt;

	for( cnt=0;cnt<STG_ITEM_MAX;cnt++) {
		if ( StgItems[cnt].state && 
			StgItems[cnt].x==x && StgItems[cnt].y==y && StgItems[cnt].z==z ) {

			return	&StgItems[cnt];

		}
	}

	return NULL;
}

//아이템을 설치한다
STG_ITEMS *STG_AREA::AddItem( psITEM *lpItem , int x, int y, int z , int BeginMode )
{
	int cnt,cnt2;
	STG_ITEMS *lpStgItem;
	int height;
	int dx,dz,dy;
	int ta;
	DWORD dwItem;


	for(cnt=0;cnt<8;cnt++) {
		ItemSettingCount++;
		dx = x+ptItemSettingPosi[ ItemSettingCount&7 ].x;
		dz = z+ptItemSettingPosi[ ItemSettingCount&7 ].y;
		dy = y<<FLOATNS;

		//현재 위치에서의 바닥 높이를 구한다
		height = lpStage->GetFloorHeight( dx<<FLOATNS, dy , dz<<FLOATNS , 32*fONE );
		if ( height!=CLIP_OUT ) {
			//이미 위치에 존재함
			ta = abs( height - dy );
			if ( ta<32*fONE ) {
				lpStgItem = FindItem( x, y, z );
				if ( !lpStgItem ) break;
			}
		}
	}

	if ( cnt<8 ) {
		x = dx;
		z = dz;
		y = height>>FLOATNS;
	}

	for( cnt2=0;cnt2<2;cnt2++) {
		for( cnt=0;cnt<STG_ITEM_MAX;cnt++) {
			if ( !StgItems[cnt].state || ( cnt2 && StgItems[cnt].Level==0 ) ) {
				StgItems[cnt].x = x;
				StgItems[cnt].y = y;
				StgItems[cnt].z = z;
				StgItems[cnt].state = TRUE;
				memcpy( &StgItems[cnt].Item , lpItem , sizeof(psITEM) );

				StgItems[cnt].dwCreateTime = GetCurrentTime();
				StgItems[cnt].BeginMode = BeginMode;				//아이템 초기 생성인지 확인용

				dwItem = StgItems[cnt].Item.ItemInfo.CODE & sinITEM_MASK2;

				if ( dwItem==sinGG1 || dwItem==sinPL1 || dwItem==sinPS1 ) {
					//돈은 빨리 사라짐
					StgItems[cnt].dwLoseTime = StgItems[cnt].dwCreateTime+STG_ITEM_WAIT_TIME_LOW;
				}
				else {
					StgItems[cnt].dwLoseTime = StgItems[cnt].dwCreateTime+STG_ITEM_WAIT_TIME;
				}

				//우선 아이템 선별
				if ( dwItem!=sinPM1 && dwItem!=sinPL1 && dwItem!=sinPS1 && dwItem!=sinGG1 ) StgItems[cnt].Level = 1;
				else dwItem = 0;

				return	&StgItems[cnt];
			}
		}
		rsItemBuffOverCount ++;
	}

	return FALSE;
}

//해당 아이템을 제거함
int STG_AREA::DeleteItem( STG_ITEMS *lpStgItem )
{
	int cnt;
	int rx,rz,dist;
	smTRANS_ACITON_ITEM	TransActionItem;

	if ( lpStgItem ) {
		lpStgItem->state = NULL;

		TransActionItem.size = sizeof(smTRANS_ACITON_ITEM);
		TransActionItem.code = smTRANSCODE_DELITEM;
		TransActionItem.x = lpStgItem->x<<FLOATNS;
		TransActionItem.y = lpStgItem->y<<FLOATNS;
		TransActionItem.z = lpStgItem->z<<FLOATNS;
		TransActionItem.lpStgArea = (void *)this;

		for(cnt=0;cnt<CONNECTMAX;cnt++) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial) {

				rx = lpStgItem->x-(rsPlayInfo[cnt].Position.x>>FLOATNS);
				rz = lpStgItem->z-(rsPlayInfo[cnt].Position.z>>FLOATNS);
				dist = rx*rx+rz*rz;
				if ( dist<DIST_TRANSLEVEL_MHIGH && abs(rx)<TRANS_VIEW_LIMIT && abs(rz)<TRANS_VIEW_LIMIT ) {
					rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransActionItem , TransActionItem.size , TRUE );
				}
			}
		}
	}

	return TRUE;
}

//해당 위치의 아이템을 제거함
int STG_AREA::DeleteItem( int x, int y, int z )
{
	STG_ITEMS *lpStgItem;
	//이미 위치에 존재함
	lpStgItem = FindItem( x, y, z );

	if ( lpStgItem ) {
		return DeleteItem( lpStgItem );
	}

	return FALSE;
}



//아이템 정보 전송 
int STG_AREA::SendStgItem( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_ITEMS	TransItems;
	int cnt,scnt;
	int dx,dz,dist;
	DWORD	dwCode;

	cnt = 0;
	scnt = 0;

	while(1) {
		if ( scnt>=TRANS_ITEM_MAX ) break;
		if ( cnt>=STG_ITEM_MAX ) break;

		if ( StgItems[cnt].state && StgItems[cnt].Level && StgItems[cnt].dwCreateTime<dwPlayServTime && 
			(StgItems[cnt].dwLoseTime-10000)>dwPlayServTime ) {

			dx = StgItems[cnt].x - (lpPlayInfo->Position.x>>FLOATNS);
			dz = StgItems[cnt].z - (lpPlayInfo->Position.z>>FLOATNS);

			dist = dx*dx+dz*dz;

			if ( dist<DIST_TRANSLEVEL_MHIGH && abs(dx)<TRANS_VIEW_LIMIT && abs(dz)<TRANS_VIEW_LIMIT ) {
				dwCode = StgItems[cnt].Item.ItemInfo.CODE;

				TransItems.Items[scnt].state = StgItems[cnt].state;
				TransItems.Items[scnt].x = StgItems[cnt].x<<FLOATNS;
				TransItems.Items[scnt].y = StgItems[cnt].y<<FLOATNS;
				TransItems.Items[scnt].z = StgItems[cnt].z<<FLOATNS;
				TransItems.Items[scnt].ItemCode = dwCode;
				TransItems.Items[scnt].lpStgArea = (void *)this;

				dwCode = dwCode&sinITEM_MASK2;

				if ( StgItems[cnt].Item.ItemInfo.PotionCount>1 && (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
					wsprintf( TransItems.Items[scnt].szName , "%sx%d" , StgItems[cnt].Item.ItemInfo.ItemName , StgItems[cnt].Item.ItemInfo.PotionCount );
				}
				else 
					lstrcpy( TransItems.Items[scnt].szName , StgItems[cnt].Item.ItemInfo.ItemName );

				//복주머니 검사
				if ( dwCode==sinPZ1 || dwCode==sinPZ2 ) {
					if ( StgItems[cnt].Item.ItemInfo.PotionCount<2 ) {
						TransItems.Items[scnt].ItemCode = sinPZ1|sin00;
						lstrcpy( TransItems.Items[scnt].szName , srItem_BB );
					}
				}

				scnt++;
			}
		}
		cnt++;
	}

	cnt = 0;

	while(1) {
		if ( scnt>=TRANS_ITEM_MAX ) break;
		if ( cnt>=STG_ITEM_MAX ) break;

		if ( StgItems[cnt].state && !StgItems[cnt].Level && StgItems[cnt].dwCreateTime<dwPlayServTime && 
			(StgItems[cnt].dwLoseTime-10000)>dwPlayServTime ) {

			dx = StgItems[cnt].x - (lpPlayInfo->Position.x>>FLOATNS);
			dz = StgItems[cnt].z - (lpPlayInfo->Position.z>>FLOATNS);

			dist = dx*dx+dz*dz;

			if ( dist<DIST_TRANSLEVEL_MHIGH && abs(dx)<TRANS_VIEW_LIMIT && abs(dz)<TRANS_VIEW_LIMIT ) {
				dwCode = StgItems[cnt].Item.ItemInfo.CODE;

				TransItems.Items[scnt].state = StgItems[cnt].state;
				TransItems.Items[scnt].x = StgItems[cnt].x<<FLOATNS;
				TransItems.Items[scnt].y = StgItems[cnt].y<<FLOATNS;
				TransItems.Items[scnt].z = StgItems[cnt].z<<FLOATNS;
				TransItems.Items[scnt].ItemCode = dwCode;
				TransItems.Items[scnt].lpStgArea = (void *)this;

				dwCode = dwCode&sinITEM_MASK2;

				if ( StgItems[cnt].Item.ItemInfo.PotionCount>1 && (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
					wsprintf( TransItems.Items[scnt].szName , "%sx%d" , StgItems[cnt].Item.ItemInfo.ItemName , StgItems[cnt].Item.ItemInfo.PotionCount );
				}
				else
					lstrcpy( TransItems.Items[scnt].szName , StgItems[cnt].Item.ItemInfo.ItemName );

				//복주머니 검사
				if ( dwCode==sinPZ1 || dwCode==sinPZ2 ) {
					if ( StgItems[cnt].Item.ItemInfo.PotionCount<2 ) {
						TransItems.Items[scnt].ItemCode = sinPZ1|sin00;
						lstrcpy( TransItems.Items[scnt].szName , srItem_BB );
					}
				}

				scnt++;
			}
		}
		cnt++;
	}


	TransItems.code = smTRANSCODE_PLAYITEM;
	TransItems.size = sizeof( TRANS_ITEM )*scnt + 16;
	TransItems.state = 1;
	TransItems.Count = scnt;

	if ( scnt>0 && lpPlayInfo && lpPlayInfo->lpsmSock ) 
		return lpPlayInfo->lpsmSock->Send( (char *)&TransItems , TransItems.size , TRUE );

	return FALSE;
}

//아이템 정보 1개만 전송 
int STG_AREA::SendStgItem( rsPLAYINFO *lpPlayInfo , STG_ITEMS *lpStgItem )
{
	smTRANS_ITEMS	TransItems;
	DWORD	dwCode;

	if ( !lpStgItem->state ) return FALSE;


	dwCode = lpStgItem->Item.ItemInfo.CODE;

	TransItems.Items[0].state = lpStgItem->state;
	TransItems.Items[0].x = lpStgItem->x<<FLOATNS;
	TransItems.Items[0].y = lpStgItem->y<<FLOATNS;
	TransItems.Items[0].z = lpStgItem->z<<FLOATNS;
	TransItems.Items[0].ItemCode = dwCode;
	TransItems.Items[0].lpStgArea = (void *)this;

	dwCode = dwCode&sinITEM_MASK2;

	if ( lpStgItem->Item.ItemInfo.PotionCount>1 && (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
		wsprintf( TransItems.Items[0].szName , "%sx%d" , lpStgItem->Item.ItemInfo.ItemName , lpStgItem->Item.ItemInfo.PotionCount );
	}
	else
		lstrcpy( TransItems.Items[0].szName , lpStgItem->Item.ItemInfo.ItemName );


	//복주머니 검사
	if ( dwCode==sinPZ1 || dwCode==sinPZ2 ) {
		if ( lpStgItem->Item.ItemInfo.PotionCount<2 ) {
			TransItems.Items[0].ItemCode = sinPZ1|sin00;
			lstrcpy( TransItems.Items[0].szName , srItem_BB );
		}
	}


	TransItems.code = smTRANSCODE_PLAYITEM;
	TransItems.size = sizeof( TRANS_ITEM ) + 16;
	TransItems.state = 1;
	TransItems.Count = 1;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) 
		return lpPlayInfo->lpsmSock->Send( (char *)&TransItems , TransItems.size , TRUE );

	return FALSE;
}

//아이템 정보 1개를 근처의 유저들 한테 보냄 
int STG_AREA::SendStgItemToNearUsers( STG_ITEMS *lpStgItem )
{
	int cnt;
	int rx,rz,dist;
	smTRANS_ITEMS	TransItems;
	DWORD	dwCode;

	if ( lpStgItem ) {
		dwCode = lpStgItem->Item.ItemInfo.CODE;

		TransItems.Items[0].state = lpStgItem->state;
		TransItems.Items[0].x = lpStgItem->x<<FLOATNS;
		TransItems.Items[0].y = lpStgItem->y<<FLOATNS;
		TransItems.Items[0].z = lpStgItem->z<<FLOATNS;
		TransItems.Items[0].ItemCode = dwCode;
		TransItems.Items[0].lpStgArea = (void *)this;

		dwCode = dwCode&sinITEM_MASK2;

		if ( lpStgItem->Item.ItemInfo.PotionCount>1 && (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
			wsprintf( TransItems.Items[0].szName , "%sx%d" , lpStgItem->Item.ItemInfo.ItemName , lpStgItem->Item.ItemInfo.PotionCount );
		}
		else
			lstrcpy( TransItems.Items[0].szName , lpStgItem->Item.ItemInfo.ItemName );

		//복주머니 검사
		if ( dwCode==sinPZ1 || dwCode==sinPZ2 ) {
			if ( lpStgItem->Item.ItemInfo.PotionCount<2 ) {
				TransItems.Items[0].ItemCode = sinPZ1|sin00;
				lstrcpy( TransItems.Items[0].szName , srItem_BB );
			}
		}

		TransItems.code = smTRANSCODE_PLAYITEM;
		TransItems.size = sizeof( TRANS_ITEM ) + 16;
		TransItems.state = 1;
		TransItems.Count = 1;

		for(cnt=0;cnt<CONNECTMAX;cnt++) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial) {
				rx = lpStgItem->x-(rsPlayInfo[cnt].Position.x>>FLOATNS);
				rz = lpStgItem->z-(rsPlayInfo[cnt].Position.z>>FLOATNS);
				dist = rx*rx+rz*rz;

				if ( dist<DIST_TRANSLEVEL_HIGH && abs(rx)<TRANS_VIEW_LIMIT && abs(rz)<TRANS_VIEW_LIMIT ) {
					rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransItems , TransItems.size , TRUE );
				}
			}
		}
	}

	return TRUE;
}


//아이템 정보 1개를 근처의 파티유저들 한테 보냄 
int STG_AREA::SendStgItemToPartyUsers( rsPLAYINFO *lpPlayInfo , STG_ITEMS *lpStgItem )
{
	int cnt;
	int rx,rz,dist;
	smTRANS_ITEMS	TransItems;
	DWORD	dwCode;

	if ( lpStgItem && lpPlayInfo && lpPlayInfo->lpPartyMaster ) {
		dwCode = lpStgItem->Item.ItemInfo.CODE;

		TransItems.Items[0].state = lpStgItem->state;
		TransItems.Items[0].x = lpStgItem->x<<FLOATNS;
		TransItems.Items[0].y = lpStgItem->y<<FLOATNS;
		TransItems.Items[0].z = lpStgItem->z<<FLOATNS;
		TransItems.Items[0].ItemCode = dwCode;
		TransItems.Items[0].lpStgArea = (void *)this;

		dwCode = dwCode&sinITEM_MASK2;

		if ( lpStgItem->Item.ItemInfo.PotionCount>1 && (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
			wsprintf( TransItems.Items[0].szName , "%sx%d" , lpStgItem->Item.ItemInfo.ItemName , lpStgItem->Item.ItemInfo.PotionCount );
		}
		else
			lstrcpy( TransItems.Items[0].szName , lpStgItem->Item.ItemInfo.ItemName );

		//복주머니 검사
		if ( dwCode==sinPZ1 || dwCode==sinPZ2 ) {
			if ( lpStgItem->Item.ItemInfo.PotionCount<2 ) {
				TransItems.Items[0].ItemCode = sinPZ1|sin00;
				lstrcpy( TransItems.Items[0].szName , srItem_BB );
			}
		}

		TransItems.code = smTRANSCODE_PLAYITEM;
		TransItems.size = sizeof( TRANS_ITEM ) + 16;
		TransItems.state = 1;
		TransItems.Count = 1;

		for(cnt=0;cnt<CONNECTMAX;cnt++) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial && 
				rsPlayInfo[cnt].dwPartyInfo && lpPlayInfo->lpPartyMaster==rsPlayInfo[cnt].lpPartyMaster ) {

				rx = lpStgItem->x-(rsPlayInfo[cnt].Position.x>>FLOATNS);
				rz = lpStgItem->z-(rsPlayInfo[cnt].Position.z>>FLOATNS);
				dist = rx*rx+rz*rz;

				if ( dist<DIST_TRANSLEVEL_HIGH && abs(rx)<TRANS_VIEW_LIMIT && abs(rz)<TRANS_VIEW_LIMIT ) {
					rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransItems , TransItems.size , TRUE );
				}
			}
		}
	}

	return TRUE;
}


//아이템 정보를 각 유저들에게 전송
int STG_AREA::SendStgItems()
{
	int cnt;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial && (dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)<OVER_TRANS_TIME ) {
			//필드의 아이템 정보 전송 
			SendStgItem( &rsPlayInfo[cnt] );
		}
	}

	return TRUE;
}



//시작 지점 깃발 전송 
int STG_AREA::SendStartPos( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_ITEMS	TransItems;
	int cnt,scnt;
	int dx,dz,dist;

	cnt = 0;
	scnt = 0;

	StartPointActiveCount = 0;
	StartPointOpenCount = 0;

	while(1) {
		if ( scnt>=TRANS_ITEM_MAX ) break;
		if ( cnt>=STG_START_POINT_MAX ) break;

		if ( StartPoint[cnt].state ) {
			dx = StartPoint[cnt].x - (lpPlayInfo->Position.x>>FLOATNS);
			dz = StartPoint[cnt].z - (lpPlayInfo->Position.z>>FLOATNS);

			dist = dx*dx+dz*dz;

			if ( dist<DIST_TRANSLEVEL_CONNECT && abs(dx)<TRANS_VIEW_LIMIT && abs(dz)<TRANS_VIEW_LIMIT ) {

				StartPointNearPlay[cnt] ++;					//깃발 근처에 유저정보 전송

				if ( lpPlayInfo->AdminMode>=2 ) {
					TransItems.Items[scnt].state = StartPoint[cnt].state;
					TransItems.Items[scnt].x = StartPoint[cnt].x<<FLOATNS;
					TransItems.Items[scnt].y = 0;
					TransItems.Items[scnt].z = StartPoint[cnt].z<<FLOATNS;
					TransItems.Items[scnt].ItemCode = 0;
					TransItems.Items[scnt].lpStgArea = (void *)this;

					//lstrcpy( TransItems.Items[scnt].szName , "위험! 몬스터 출현지점" );
#ifdef _LANGUAGE_KOREAN
					wsprintf( TransItems.Items[scnt].szName , szMonsterFlagMsg , cnt , StartPointMonCount[cnt] );
#else
					lstrcpy( TransItems.Items[scnt].szName , szMonsterFlagMsg );
#endif
					scnt++;
				}
			}

			if ( StartPointNearPlay[cnt] )	StartPointActiveCount++;
			StartPointOpenCount ++;

		}


		cnt++;
	}

	if ( lpPlayInfo->AdminMode>=2 ) {
		TransItems.code = smTRANSCODE_PLAYITEM;
		TransItems.size = sizeof( TRANS_ITEM )*scnt + 16;
		TransItems.state = 1;
		TransItems.Count = scnt;

		if ( scnt>0 && lpPlayInfo && lpPlayInfo->lpsmSock ) 
			return lpPlayInfo->lpsmSock->Send( (char *)&TransItems , TransItems.size , TRUE );
	}
	return TRUE;
}

int STG_AREA::LoadStartPoint( char *szFile )
{
	FILE *fp;

	fp = fopen( szFile , "rb" );
	if ( fp ) {
		fread( StartPoint , sizeof(STG_START_POINT)*STG_START_POINT_MAX , 1, fp );
		fclose(fp);
		dwActiveMode |= 1;
	}

	return TRUE;
}

int STG_AREA::SaveStartPoint( char *szFile )
{
	FILE *fp;

	fp = fopen( szFile , "wb" );
	if ( fp ) {
		fwrite( StartPoint , sizeof(STG_START_POINT)*STG_START_POINT_MAX , 1, fp );
		fclose(fp);
		dwActiveMode |= 1;
	}

	return TRUE;
}


//	int SaveStartPoint( char *szFile );



//빈 몬스터 테이블 번호 찾기
int	STG_AREA::FindEmptyMonTable()
{
	int cnt;

	for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
		if ( lpCharMonster[cnt]==0 ) return cnt;
	}

	return -1;
}

//몬스터 테이블에 포인터 추가
int	STG_AREA::AddMonTable( smCHAR *lpChar )
{
	int	cnt;
	int mtab;

	//시작 깃발의 발생수 기록
	StartPointMonCount[lpChar->OpenStartPostion] ++;

	mtab = FindEmptyMonTable();
	if ( mtab>=0 ) {
		lpCharMonster[ mtab ] = lpChar;			//몬스터 포인터 기록
		lpChar->lpExt4 = this;
		//몬스터 마지막 테이블 번호 찾아 기록
		MonsterLastPoint = mtab;
		for( cnt=mtab;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpCharMonster[ cnt ] )
				MonsterLastPoint = cnt+1;
		}
		return TRUE;
	}

	return FALSE;
}

//몬스터 테이블에 포인터 제거
int	STG_AREA::DeleteMonTable( smCHAR *lpChar )
{
	int cnt;


	//시작 깃발의 발생수 기록
	if ( StartPointMonCount[lpChar->OpenStartPostion]>0 ) 
		StartPointMonCount[lpChar->OpenStartPostion] --;

	for( cnt=0;cnt<MonsterLastPoint;cnt++ ) {
		if ( lpCharMonster[cnt]==lpChar ) {
			lpCharMonster[cnt] = NULL;
			return TRUE;
		}
	}

	return FALSE;
}

//몬스터 출현
smCHAR *STG_AREA::OpenMonster( STG_CHAR_INFO *lpStgCharInfo , int gGroup )
{

	smCHAR *lpChar;
	int dist;
	int x,y,z;
	int cnt;


	//빈캐릭터를 찾는다 
	lpChar = srFindEmptyChar();
	if ( !lpChar ) return NULL;

		//새로운 출현 시작 위치를 찾아 설정 
		if ( SetStartPosChar( lpChar )==TRUE ) {
			MonsterCount++;
			lpChar->lpExt1 = (void *)&Head;
			lpChar->dwObjectSerial = GetNewObjectSerial();
			lpChar->ActionPattern = 5;
			memcpy( &lpChar->smCharInfo , &lpStgCharInfo->smCharInfo , sizeof( smCHAR_INFO ) );
			memcpy( &lpChar->smMonsterInfo , lpStgCharInfo->smCharInfo.lpMonInfo , sizeof( smCHAR_MONSTER_INFO ) );
			lpChar->SetLoadPattern( lpChar->smCharInfo.szModelName );

			//구분 코드를 StatePoint 에 설정
			lpChar->smCharInfo.StatePoint = lpStgCharInfo->smCharInfo.lpMonInfo->ClassCode;

			dist = 64*20;
			lpChar->DistAroundDbl =  dist*dist;
			lpChar->AttackUserFlag = 0;
			lpChar->lpExt2 = 0;


			//경험치 배분 유저 기억 정보
			lpChar->lpExpAttackPlayInfo = 0;
			lpChar->ExpAttackLife = 0;

			//시작하면 아무곳으로 나 이동
			lpChar->Angle.y = (GetCurrentTime()<<2)&ANGCLIP;
			lpChar->SetMotionFromCode( CHRMOTION_STATE_WALK );
			lpChar->TargetMoveCount = 2;

			AddMonTable( lpChar );

			if ( lprsFixedPoint )
				lpChar->ReopenCount	= REOPEN_COUNT_NUM*32;			//슬립모드시 재시작 시간 카운터
			else
				lpChar->ReopenCount	= REOPEN_COUNT_NUM;			//슬립모드시 재시작 시간 카운터

			lpChar->dwLastTransTime = dwPlayServTime;		//최근 활성화된 시간

			//발렌토 물약 개수 만큼 피 업그레이드
			if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_DEATHKNIGHT || lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_KELVEZU || lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_MOKOVA ) {
				lpChar->UseObject_VirtualLife = lpChar->smMonsterInfo.PotionCount;
				lpChar->sObject_VirtualLife[0] = lpChar->UseObject_VirtualLife;	
				lpChar->sObject_VirtualLife[1] = lpChar->UseObject_VirtualLife;	
				lpChar->sObject_DisplayLife[0] = lpChar->UseObject_VirtualLife;
				lpChar->sObject_DisplayLife[1] = lpChar->UseObject_VirtualLife;
			}
			else {
				//물약 갯수 등록
				if ( lpChar->smMonsterInfo.PotionCount ) {
					if ( (rand()%100)<lpChar->smMonsterInfo.PotionPercent ) {
						lpChar->smMonsterInfo.PotionCount = (rand()%lpChar->smMonsterInfo.PotionCount)+1;
					}
					else {
						lpChar->smMonsterInfo.PotionCount = 0;
					}
				}
			}

#ifndef	_LANGUAGE_PHILIPIN
			if ( rsDamgeOffEvent )
			{
				//공격력 활인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*ATTACK_RATE)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*ATTACK_RATE)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] )
				{
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*ATTACK_RATE)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*ATTACK_RATE)/100;
				}
			}
#else
//해외////////////////////////////////////////////////////////////////////////////
			if ( rsDamgeOffEvent1 )
			{
				//공격력 활인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*75)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*75)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] )
				{
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*75)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*75)/100;
				}
			}

			if ( rsDamgeOffEvent2 )
			{
				//공격력 활인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*50)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*50)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] )
				{
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*50)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*50)/100;
				}
			}
#endif
//////////////////////////////////////////////////////////////////////////////////

			//해외
			if( rsDefenseOffEvent )
			{
				//몬스터 방어력 할인 이벤트
				lpChar->smCharInfo.Defence = (lpChar->smCharInfo.Defence*DEFENSE_RATE)/100;
			}

			//뱀피릭 머신 움직이지 않도록
			if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_VAMPRICMACHINE )
			{
					lpChar->DontMoveFlag = 1;
			}



			rsMonOpenCount++;			//몬스터 발생 기록

		}
		else {
			lpChar->Close();
			return NULL;
		}



	x = lpChar->pX;
	y = lpChar->pY;
	z = lpChar->pZ;

	for( cnt=1;cnt<gGroup;cnt++ ) {
		//빈캐릭터를 찾는다 
		lpChar = srFindEmptyChar();
		if ( !lpChar ) return NULL;

		if ( SetStartPosNearChar( lpChar , x, y, z )==TRUE ) {
			MonsterCount++;
			lpChar->lpExt1 = (void *)&Head;
			lpChar->dwObjectSerial = GetNewObjectSerial();
			lpChar->ActionPattern = 5;
			memcpy( &lpChar->smCharInfo , &lpStgCharInfo->smCharInfo , sizeof( smCHAR_INFO ) );
			memcpy( &lpChar->smMonsterInfo , lpStgCharInfo->smCharInfo.lpMonInfo , sizeof( smCHAR_MONSTER_INFO ) );
			lpChar->SetLoadPattern( lpChar->smCharInfo.szModelName );

			//구분 코드를 StatePoint 에 설정
			lpChar->smCharInfo.StatePoint = lpStgCharInfo->smCharInfo.lpMonInfo->ClassCode;

			dist = 64*20;
			lpChar->DistAroundDbl =  dist*dist;
			lpChar->AttackUserFlag = 0;
			lpChar->lpExt2 = 0;

			//경험치 배분 유저 기억 정보
			lpChar->lpExpAttackPlayInfo = 0;
			lpChar->ExpAttackLife = 0;

			AddMonTable( lpChar );

			if ( lprsFixedPoint )
				lpChar->ReopenCount	= REOPEN_COUNT_NUM*32;		//슬립모드시 재시작 시간 카운터
			else
				lpChar->ReopenCount	= REOPEN_COUNT_NUM;			//슬립모드시 재시작 시간 카운터

			lpChar->dwLastTransTime = dwPlayServTime;		//최근 활성화된 시간

			//물약 갯수 등록
			if ( lpChar->smMonsterInfo.PotionCount ) {
				if ( (rand()%100)<lpChar->smMonsterInfo.PotionPercent ) {
					lpChar->smMonsterInfo.PotionCount = (rand()%lpChar->smMonsterInfo.PotionCount)+1;
				}
				else {
					lpChar->smMonsterInfo.PotionCount = 0;
				}
			}

#ifndef	_LANGUAGE_PHILIPIN
			if ( rsDamgeOffEvent )
			{
				//공격력 활인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*ATTACK_RATE)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*ATTACK_RATE)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] ) {
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*ATTACK_RATE)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*ATTACK_RATE)/100;
				}
			}
#else
//해외(필리핀)///////////////////////////////////////////////////////////////////////////////
			if ( rsDamgeOffEvent1 )
			{
				//공격력 활인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*75)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*75)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] )
				{
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*75)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*75)/100;
				}
			}

			if ( rsDamgeOffEvent2 )
			{
				//공격력 활인 이벤트
				lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*50)/100;
				lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*50)/100;
				if ( lpChar->smMonsterInfo.SkillDamage[0] )
				{
					lpChar->smMonsterInfo.SkillDamage[0] = (lpChar->smMonsterInfo.SkillDamage[0]*50)/100;
					lpChar->smMonsterInfo.SkillDamage[1] = (lpChar->smMonsterInfo.SkillDamage[1]*50)/100;
				}
			}
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////
			//해외
			if( rsDefenseOffEvent )
			{
				//몬스터 방어력 할인 이벤트
				lpChar->smCharInfo.Defence = (lpChar->smCharInfo.Defence*DEFENSE_RATE)/100;
			}

			rsMonOpenCount++;			//몬스터 발생 기록

			//뱀피릭 머신 움직이지 않도록
			if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_VAMPRICMACHINE || 
				lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_DOOR ) 
			{
					lpChar->DontMoveFlag = 2;		//각도 고정
			}


		}
		else {
			lpChar->Close();
			return NULL;
		}
	}

	return lpChar;
}

int STG_AREA::SendStartPointFlag()
{
	int cnt;

	ZeroMemory( StartPointNearPlay , sizeof( int ) * STG_START_POINT_MAX );

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial ) {
			//시작 지점 깃발 전송 
			SendStartPos( &rsPlayInfo[cnt] );
		}
	}

	return TRUE;
}


//직역 메인
int STG_AREA::Main()
{
	STG_CHAR_INFO StgCharInfo;
	int cnt;
	int rnd;
	int gGroup;
	DWORD	OsCode;
	smCHAR_INFO *lpCharInfo;

	Counter++;

	if ( chrMonsterCnt>0 && MonsterCount<rsMonsterList.LimitMax && 
		(Counter&rsMonsterList.OpenInterval)==0 && 
		( lpField->FieldEvent!=FIELD_EVENT_NIGHTMARE || FieldNightDay ) ) {
		StgCharInfo.PosiState = TRUE;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;

		if ( rsMonsterList.Counter ) {
			//몬스터 설정이 있을경우
			rnd = (rand()%rsMonsterList.PecetageCount);
			for( cnt=0;cnt<rsMonsterList.Counter;cnt++ ) {
				if ( rsMonsterList.rsMonster[cnt].NumOpenStart>rnd ) break;
			}
			memcpy( &StgCharInfo.smCharInfo , rsMonsterList.rsMonster[cnt-1].lpCharInfo , sizeof( smCHAR_INFO ) );
			//memcpy( &StgCharInfo.smMonsterInfo , rsMonsterList.rsMonster[cnt-1].lpMonInfo , sizeof( smCHAR_MONSTER_INFO ) );
			if ( EventMonster ) {
				//이벤트 몬스터 모드
				OpenEventMonster( &StgCharInfo.smCharInfo , this );
			}
			lpCharInfo = &StgCharInfo.smCharInfo;

			if ( lpCharInfo && StgCharInfo.smCharInfo.lpMonInfo ) {
				gGroup = GetRandomPos( StgCharInfo.smCharInfo.lpMonInfo->GenerateGroup[0] , 
					StgCharInfo.smCharInfo.lpMonInfo->GenerateGroup[1] );

				if ( gGroup<=0 ) gGroup=1;

				//이벤트용 몬스터 일정시간동안 발생
				if ( Event_dwMonsterTime>dwPlayServTime && Event_MonsterPercentage>0 && Event_lpChrMonster ) {
					if ( (rand()%1000)<Event_MonsterPercentage ) {
						memcpy( &StgCharInfo.smCharInfo , Event_lpChrMonster , sizeof( smCHAR_INFO ) );
						gGroup = 1;
					}
				}

				if ( rsServerConfig.Event_Child==2 && srHammerMonsterCount>0 ) {
					//뿅망치 이벤트
					if ( (rand()%1000)<10 ) {
						if ( lpField->State==FIELD_STATE_FOREST ) {
							for(cnt=0;cnt<srHammerMonsterCount;cnt++) {
								//저랩용 숲에서는 해머고블린 만 출현
								if ( srCharInfo_HammerMonster[ cnt ]->dwCharSoundCode==snCHAR_SOUND_HOBGOBLIN ) {
									memcpy( &StgCharInfo.smCharInfo , srCharInfo_HammerMonster[ cnt ] , sizeof( smCHAR_INFO ) );
									break;
								}
							}
						}
						else
							memcpy( &StgCharInfo.smCharInfo , srCharInfo_HammerMonster[ rand()%srHammerMonsterCount ] , sizeof( smCHAR_INFO ) );

						gGroup = 1;
					}
				}

				if ( rsServerConfig.Event_MorifSheltom ) {
					//모리프 이벤트
					if ( (rand()%1000)<5 ) {
						for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
							if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_NPC_MORIF ) {
								memcpy( &StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) );
								break;
							}
						}
						gGroup = 1;
					}
				}


				if ( rsServerConfig.Event_WorldCup ) {
					//월드컵 이벤트
					int chrFind = 0;
					int rFind = rand()%4;
					if ( (rand()%1000)<rsServerConfig.Event_WorldCup ) {
						for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
							if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_WORLDCUP ) {
								memcpy( &StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) );
								if ( chrFind==rFind ) break;
								chrFind++;
							}
						}
						gGroup = 1;
					}
				}

				if ( rsServerConfig.Event_MollyWolf ) {
					//늑대 이벤트
					if ( (rand()%1000)<rsServerConfig.Event_MollyWolf ) {
						for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
							if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_NPC_MOLLYWOLF ) {
								memcpy( &StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) );
								break;
							}
						}
						gGroup = 1;
					}
				}

				if ( rsServerConfig.Event_Ghost ) {
					//고스트 이벤트
					if ( (rand()%1000)<rsServerConfig.Event_Ghost ) {
						for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
							if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_MRGHOST && chrMonsterList[cnt].wPlayClass[0]==MONSTER_CLASS_GHOST ) {
								memcpy( &StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) );
								break;
							}
						}
						gGroup = 1;
					}
				}

				if ( rsServerConfig.Event_SantaGoblin ) {
					//산타고블린 이벤트
					if ( (rand()%1000)<rsServerConfig.Event_SantaGoblin ) {
						for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
							if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_HOBGOBLIN && chrMonsterList[cnt].Level==60 ) {
								memcpy( &StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) );
								break;
							}
						}
						gGroup = 1;
					}
				}

				if ( rsServerConfig.Event_SummerChicken ) {
					//삼계탕 이벤트
					if ( (rand()%1000)<rsServerConfig.Event_SummerChicken ) {
						for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
							if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_RABIE && chrMonsterList[cnt].Level>=10 && chrMonsterList[cnt].wPlayClass[1] ) {
								//빅 토비
								memcpy( &StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) );
								break;
							}
						}
						gGroup = 1;
					}
				}


				OpenMonster( &StgCharInfo , gGroup );
			}
		}
/*
		else {
			//몬스터 설정이 없을 경우 ( 무작위로 나오게함 ) 
			//memcpy( &StgCharInfo.smCharInfo , &chrMonsterList[(rand()%chrMonsterCnt)] , sizeof( smCHAR_INFO ) );
			lpCharInfo = SetMonsterModelRandom( &StgCharInfo.smCharInfo );
		}
*/
	}

	switch( Counter&0x1FF ) {
	case 0x80:
		SendStartPointFlag();
		break;
	case 0xC0:
		SendStgItems();
		break;
	}

	DWORD	dwTime;
	int		dist;

	dwTime = dwPlayServTime;//GetCurrentTime();

	for( cnt=0;cnt<STG_ITEM_MAX;cnt++) {
		if ( StgItems[cnt].state ) {
			if ( StgItems[cnt].dwLoseTime<dwTime ) {
				StgItems[cnt].state = 0;
			}
		}
	}


	if ( rsServerConfig.Event_HardCore && lpField->FieldCode==rsSOD_FIELD && rsMonsterList.Counter>0 ) {
		if ( (Counter&0x3F)==0 ) {
			//SetMonsterModelRandom( &StgCharInfo.smCharInfo );
			memcpy( &StgCharInfo.smCharInfo , rsMonsterList.rsMonster[0].lpCharInfo , sizeof( smCHAR_INFO ) );
			rsHardCoreEvent_OpenMonster( this , &StgCharInfo );
		}
	}


	if ( lpField->FieldCode==rsCASTLE_FIELD ) {
		//공성 처리메인
		rsMain_CombatCastle();
	}


	//밤과 낮이 바뀜
	if ( FieldNightDay!=dwServ_NightDay ) {
		if ( lpField->FieldEvent==FIELD_EVENT_NIGHTMARE ) {
			if ( dwServ_NightDay ) {
				//밤으로 바뀜
				for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
					if ( chrAutoPlayer[cnt].Flag && chrAutoPlayer[cnt].lpExt1==this &&
						chrAutoPlayer[cnt].smCharInfo.State==smCHAR_STATE_NPC &&
						chrAutoPlayer[cnt].smMonsterInfo.EventNPC==0 ) {

						chrAutoPlayer[cnt].Close();

						chrAutoPlayer[cnt].Flag = TRUE;

						//캐릭터의 정보 변경
						rnd = chrAutoPlayer[cnt].smCharInfo.bUpdateInfo[0];
						OsCode = chrAutoPlayer[cnt].dwObjectSerial;

						//몬스터 캐릭터 수치 설정
						memcpy( &chrAutoPlayer[cnt].smCharInfo , chrNpcMonsterInfo , sizeof( smCHAR_INFO ) );
						memcpy( &chrAutoPlayer[cnt].smMonsterInfo , chrNpcMonsterInfo->lpMonInfo , sizeof( smCHAR_MONSTER_INFO ) );
						chrAutoPlayer[cnt].ActionPattern = 5;
						MonsterCount++;
						chrAutoPlayer[cnt].SetLoadPattern( chrAutoPlayer[cnt].smCharInfo.szModelName );

						dist = 64*20;
						chrAutoPlayer[cnt].DistAroundDbl =  dist*dist;
						AddMonTable( &chrAutoPlayer[cnt] );
						chrAutoPlayer[cnt].ReopenCount	= REOPEN_COUNT_NUM;			//슬립모드시 재시작 시간 카운터
						chrAutoPlayer[cnt].SetMotionFromCode(CHRMOTION_STATE_STAND);

						chrAutoPlayer[cnt].smCharInfo.bUpdateInfo[0] = rnd+1;
						chrAutoPlayer[cnt].dwObjectSerial = OsCode;
					}
				}
			}
			else {
				//낮으로 바뀜
				for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
					if ( chrAutoPlayer[cnt].Flag && chrAutoPlayer[cnt].lpExt1==this &&
						chrAutoPlayer[cnt].smCharInfo.State==smCHAR_STATE_ENEMY ) {

						//낮이 되면 몬스터 전멸
						chrAutoPlayer[cnt].smCharInfo.Life[0] = 0;
						chrAutoPlayer[cnt].SetMotionFromCode(CHRMOTION_STATE_DEAD);
					}
				}

				rsOpenNPC_RandomPos = rand();
				//NPC 재 설정
				for( cnt=0;cnt<FIX_CHAR_MAX;cnt++) {
					if ( TransCharFixed[cnt].code )	
						OpenNpc( &TransCharFixed[cnt] );
				}
			}
		}

		if ( lpField->FieldCode==3 ) {//State==FIELD_STATE_VILLAGE && lpField->FieldEvent!=FIELD_EVENT_NIGHTMARE ) {
			//일반 마을 (리카르텐)

			if ( dwServ_NightDay ) {
				/*
				for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
					if ( chrAutoPlayer[cnt].Flag && chrAutoPlayer[cnt].lpExt1==this &&
						chrAutoPlayer[cnt].smMonsterInfo.EventCode==100 &&
						chrAutoPlayer[cnt].smCharInfo.dwCharSoundCode==snCHAR_SOUND_WOLVERLIN &&
						chrAutoPlayer[cnt].smCharInfo.State==smCHAR_STATE_NPC ) {
							chrAutoPlayer[cnt].Close();			//밤이 되면 울버린 사라짐
						}
				}
				*/

				rsCloseEventMonster( 100 );				//이벤트 몬스터 제거 ( NPC 제거 )
				rsOpenEventMonster( 100 ,0,0,0 );		//이벤트 몬스터 호출

			}
			else {
				rsCloseEventMonster( 100 );				//이벤트 몬스터 제거

				//NPC 재 설정
				for( cnt=0;cnt<FIX_CHAR_MAX;cnt++) {
					if ( TransCharFixed[cnt].code && TransCharFixed[cnt].smCharInfo.dwCharSoundCode==snCHAR_SOUND_WOLVERLIN )	
						OpenNpc( &TransCharFixed[cnt] );
				}

			}
		}

		FieldNightDay = dwServ_NightDay;
	}

	return TRUE;
}



//배경 메시 로드 
int STG_AREA::LoadStage( char *szFile )
{
	smSTAGE3D *lpRes;
	int cnt;

	lpStage = new smSTAGE3D;
	lpRes = smSTAGE3D_ReadASE( szFile , lpStage );
	lpStage->Head = TRUE;


	if ( lpRes ) {

		SetFieldInfoPath( szStartPointFile , szFile , "spp" );
		LoadStartPoint( szStartPointFile );

		SetFieldInfoPath( szCharFixedFile , szFile , "spc" );
		if ( LoadCharInfoFixed( szCharFixedFile ) ) {
			for( cnt=0;cnt<FIX_CHAR_MAX;cnt++) {
				if ( TransCharFixed[cnt].code )	
					OpenNpc( &TransCharFixed[cnt] );
			}
			dwActiveMode |= 2;
		}

		SetFieldInfoPath( szCharMonsterFile , szFile , "spm" );

		//몬스터 출현 정보 파일에서 해독하여 설정한다
		DecodeOpenMonster( szCharMonsterFile , &rsMonsterList , chrMonsterList, chrMonsterCnt );
		if ( !rsMonsterList.LimitMax ) rsMonsterList.LimitMax = 10;

		return TRUE;
	}

	delete lpStage;
	lpStage = 0;

	return FALSE;
}


//시작 지점 검색
int STG_AREA::FindStartPoint( int x, int z )
{
	int cnt;
	for( cnt=0;cnt<STG_START_POINT_MAX;cnt++) {
		if ( StartPoint[cnt].state && 
			StartPoint[cnt].x==x && StartPoint[cnt].z==z ) {
			return cnt;
		}
	}

	return -1;
}




//시작 지점 추가
int STG_AREA::AddStartPoint( int x, int z, int state )
{
	int cnt;

	//이미 위치에 존재함
	cnt = FindStartPoint( x, z );
	if ( cnt>=0 ) return FALSE;

	for( cnt=0;cnt<STG_START_POINT_MAX;cnt++) {
		if ( !StartPoint[cnt].state ) {
			StartPoint[cnt].state = state;
			StartPoint[cnt].x = x;
			StartPoint[cnt].z = z;
			StartPointMonCount[cnt] = 0;
			SaveStartPoint( szStartPointFile );
			return TRUE;
		}
	}
 
	return FALSE;
}

//시작 지점 제거
int STG_AREA::DeleteStartPoint( int x, int z )
{
	int cnt;

	cnt = FindStartPoint( x, z );
	if ( cnt>=0 ) {
		StartPoint[cnt].state = 0;
		StartPointMonCount[cnt] = 0;
		SaveStartPoint( szStartPointFile );
		return TRUE;
	}
	return FALSE;
}
//출현 시작 위치 랜덤화 한다 
int STG_AREA::StartPosRandomize()
{
	int cnt;
	int end;
	int rnd;

	end = 1;

	for( cnt=STG_START_POINT_MAX-1;cnt>=0;cnt--) {
		if (StartPoint[cnt].state) {
			end = cnt+1;
		}
	}

	rnd = rand()%end;

	StartPointCnt = rnd;

	return TRUE;
}

//새로운 출현 시작 위치를 찾아 설정 
int STG_AREA::SetStartPosChar( smCHAR *lpChar )
{
	int x,y,cnt;
	int flag;

	flag = 0;

	for( cnt=StartPointCnt;cnt<STG_START_POINT_MAX;cnt++ ) {
		if ( StartPoint[cnt].state && StartPointNearPlay[cnt] && 
			StartPointMonCount[cnt]<rsMonsterList.OpenLimit &&
			dwStartPoint_OpenTime[cnt]<dwPlayServTime ) {

			x = StartPoint[cnt].x * fONE;
			y = StartPoint[cnt].z * fONE;
			StartPointCnt = cnt+1;
			StartPointLastOpenCount = cnt;
			flag++;
			break;
		}
	}

	if ( flag==0 ) {
		for( cnt=0;cnt<STG_START_POINT_MAX;cnt++ ) {
			if ( StartPoint[cnt].state && StartPointNearPlay[cnt] &&
				StartPointMonCount[cnt]<rsMonsterList.OpenLimit &&
				dwStartPoint_OpenTime[cnt]<dwPlayServTime ) {

				x = StartPoint[cnt].x * fONE;
				y = StartPoint[cnt].z * fONE;
				StartPointCnt = cnt+1;
				StartPointLastOpenCount = cnt;
				flag++;
				break;
			}
		}
	}

	if ( flag==0 && EvnMonster ) {
		EvnMonster = 0;
		//강제로 오픈


		for( cnt=StartPointCnt;cnt<STG_START_POINT_MAX;cnt++ ) {
			if ( StartPoint[cnt].state && StartPointNearPlay[cnt] ) {
				x = StartPoint[cnt].x * fONE;
				y = StartPoint[cnt].z * fONE;
				flag++;
				break;
			}
		}

		if ( flag==0 && StartPointCnt<STG_START_POINT_MAX ) {
			for( cnt=0;cnt<StartPointCnt;cnt++ ) {
				if ( StartPoint[cnt].state && StartPointNearPlay[cnt] ) {
					x = StartPoint[cnt].x * fONE;
					y = StartPoint[cnt].z * fONE;
					flag++;
					break;
				}
			}
		}

		if ( flag==0 ) {
			for( cnt=0;cnt<STG_START_POINT_MAX;cnt++ ) {
				if ( StartPoint[cnt].state ) {
					x = StartPoint[cnt].x * fONE;
					y = StartPoint[cnt].z * fONE;
					flag++;
					break;
				}
			}
		}
	}

	if ( flag>0 ) {

		if ( lprsFixedPoint ) {
			x = lprsFixedPoint->x;
			y = lprsFixedPoint->z;
		}

		lpChar->Init();
		lpChar->lpStage = lpStage;
		lpChar->SetPosi( x, 0, y ,0,0,0 );

		lpChar->PosiAround.x = x;
		lpChar->PosiAround.y = lpChar->pY;
		lpChar->PosiAround.z = y;
		lpChar->DistAroundDbl =  DIST_AROUND_MIDDLE;

		lpChar->OpenStartPostion = StartPointLastOpenCount;

		dwStartPoint_OpenTime[StartPointLastOpenCount] = dwPlayServTime+rsMonsterList.dwIntervalTime;

		return TRUE;
	}

	return FALSE;
}


//특정 좌표 주변에 캐릭터 위치를 설치함 
int STG_AREA::SetStartPosNearChar( smCHAR *lpChar , int cx, int cy, int cz )
{
	int cnt;
	int height;
	int mCnt;
	int x,y,z;

	for(cnt=0;cnt<8;cnt++) {
		MonsterSettingCount++;
		mCnt = MonsterSettingCount&7;

		x = cx+ptItemSettingPosi[ mCnt ].x * 4 * fONE;
		z = cz+ptItemSettingPosi[ mCnt ].y * 4 * fONE;
		y = cy;

		//현재 위치에서의 바닥 높이를 구한다
		height = lpStage->GetFloorHeight( x, y , z , 32*fONE );
		if ( height!=CLIP_OUT ) {
			if ( abs( height-y )<fONE*64 ) break;
		}
	}

	if ( cnt<8 ) {
		lpChar->Init();
		lpChar->lpStage = lpStage;
		lpChar->SetPosi( x, 0, z ,0,0,0 );
		lpChar->PosiAround.x = x;
		lpChar->PosiAround.y = lpChar->pY;
		lpChar->PosiAround.z = z;
		lpChar->DistAroundDbl =  DIST_AROUND_MIDDLE;
		lpChar->OpenStartPostion = StartPointLastOpenCount;
		return TRUE;
	}

	return FALSE;
}

//특정 좌표 주변에 캐릭터 위치를 설치함 
int STG_AREA::SetPosNearChar( smCHAR *lpChar , int cx, int cy, int cz )
{
	int cnt;
	int height;
	int mCnt;
	int x,y,z;

	for(cnt=0;cnt<8;cnt++) {
		MonsterSettingCount++;
		mCnt = MonsterSettingCount&7;

		x = cx+ptItemSettingPosi[ mCnt ].x * 4 * fONE;
		z = cz+ptItemSettingPosi[ mCnt ].y * 4 * fONE;
		y = cy;

		//현재 위치에서의 바닥 높이를 구한다
		height = lpStage->GetFloorHeight( x, y , z , 32*fONE );
		if ( height!=CLIP_OUT ) {
			if ( abs( height-y )<fONE*64 ) break;
		}
	}

	if ( cnt<8 ) {
		lpChar->SetPosi( x, 0, z ,0,0,0 );
		lpChar->PosiAround.x = x;
		lpChar->PosiAround.y = lpChar->pY;
		lpChar->PosiAround.z = z;
		lpChar->DistAroundDbl =  DIST_AROUND_MIDDLE;
		return TRUE;
	}

	return FALSE;
}


//새로운 출현 시작 위치를 찾아 설정 
int SetStartPosChar( smCHAR *lpChar )
{
	int x,y,cnt;

//	cnt = StartPointCnt & START_POINT_MASK;
	cnt = StartPointCnt;
	x = StartPoint[cnt].x * fONE;
	y = StartPoint[cnt].y * fONE;

	StartPointCnt++;
	if ( StartPointCnt>=START_POINT_MAX ) StartPointCnt = 0;

	return TRUE;
}

//캐릭터 초기화
int srInitChar()
{
	int cnt;

	InitPatterns();

	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		chrAutoPlayer[cnt].Init();
		chrAutoPlayer[cnt].lpStage = lpsmStage[1];
	}

	return TRUE;
}

int srRemoveChar()
{

	//패턴버퍼를 말기화
	ClosePatterns();

	return TRUE;
}


//위치로 해당 배경 구역을 찾는다 
STG_AREA *FindStageField( int x, int z )
{
	int cnt;
	int he;

	for( cnt=0;cnt<STAGE_AREA_MAX;cnt++) {
		if ( StageArea[cnt].lpStage ) {
			he=StageArea[cnt].lpStage->GetHeight( x,z );
			if ( he>0 ) {
				return &StageArea[cnt];
			}
		}
	}

	return NULL;
}



int srReadStage()
{
	int cnt;

	//배경 로더 초기화
	InitStageLoader();
	InitField();


//sFIELD	sField[ FIELD_MAX ];

	cnt = 0;

	while(1) {
		if ( sField[cnt].szName[0]==0 ) break;
///////////임시
//		if ( cnt>5 ) break;						
////////////////////

		StageArea[cnt].LoadStage(  sField[cnt].szName );
		StageArea[cnt].lpField = &sField[cnt];
		cnt++;
	}
//	StageArea[0].AddStartPoint( -10006 , -10283 , TRUE );


	lpsmStage[0] = StageArea[0].lpStage;
	lpsmStage[1] = StageArea[0].lpStage;

/*
	for(cnt=0;cnt<STAGE_MAX;cnt++) {
		lpsmStage[cnt] = 0;
	}

	lpsmStage[0] = new smSTAGE3D;
	lpsmStage[0] = smSTAGE3D_ReadASE( "field\\village.ASE" , lpsmStage[0] );
	lpsmStage[0]->Head = TRUE;

	lpsmStage[1] = new smSTAGE3D;
	lpsmStage[1] = smSTAGE3D_ReadASE( "field\\forest(attach).ASE" , lpsmStage[1] );
	lpsmStage[1]->Head = TRUE;
*/

	return TRUE;
}

int srRemoveStage()
{
/*
	int cnt;

	for(cnt=0;cnt<STAGE_MAX;cnt++) {
		if ( lpsmStage[cnt] ) {
			delete lpsmStage[cnt];
		}
	}
*/
	return TRUE;
}



//		rsSendPlayerInfo( (smTRNAS_COMMAND *)IPData );

//캐릭터의 포괄적 정보를 소켓으로 상대방에 전송
int rsSendCharInfo( smCHAR *lpChar , rsPLAYINFO *lpPlayInfo )
{

	smTRNAS_PLAYERINFO	TransPlayerInfo;

	memcpy( &TransPlayerInfo.smCharInfo , &lpChar->smCharInfo , sizeof( smCHAR_INFO ) );
	TransPlayerInfo.size = sizeof( smTRNAS_PLAYERINFO );
	TransPlayerInfo.code = smTRANSCODE_PLAYERINFO;
	TransPlayerInfo.dwObjectSerial = lpChar->dwObjectSerial;

	TransPlayerInfo.x = lpChar->pX;
	TransPlayerInfo.y = lpChar->pY;
	TransPlayerInfo.z = lpChar->pZ;

	if ( !lpPlayInfo->AdminMode ) {
		TransPlayerInfo.smCharInfo.Attack_Damage[0] = 1000;
		TransPlayerInfo.smCharInfo.Attack_Damage[1] = 9999;
/*
#ifdef _LANGUAGE_CHINESE
		TransPlayerInfo.smCharInfo.Exp = 0;
		TransPlayerInfo.smCharInfo.Defence = 0;
		TransPlayerInfo.smCharInfo.Sight = 0;
		TransPlayerInfo.smCharInfo.Absorption = 0;
		TransPlayerInfo.smCharInfo.Level = 79;
#endif
*/
	}

	return lpPlayInfo->lpsmSock->Send( (char *)&TransPlayerInfo , TransPlayerInfo.size , TRUE );
}

/*
//캐릭터 정보적어서 되돌려서 보냄
int rsSendPlayerInfo( smWINSOCK *lpsmsock , smTRANS_COMMAND *lpTransCommand , rsPLAYINFO *lpPlayInfo )
{
	smTRNAS_PLAYERINFO	TransPlayerInfo;

	memcpy( &TransPlayerInfo.smCharInfo , &lpPlayInfo->smCharInfo , sizeof( smCHAR_INFO ) );

	if ( !lpPlayInfo->AdminMode ) {
		//일반 유저에겐 가짜 보내기
		TransPlayerInfo.smCharInfo.Attack_Damage[0] = 2*TransPlayerInfo.smCharInfo.Level;
		TransPlayerInfo.smCharInfo.Attack_Damage[1] = 3*TransPlayerInfo.smCharInfo.Level;
#ifdef _LANGUAGE_CHINESE
		TransPlayerInfo.smCharInfo.Exp = 0;
#endif

	}

	TransPlayerInfo.size = sizeof( smTRNAS_PLAYERINFO );
	TransPlayerInfo.code = smTRANSCODE_PLAYERINFO;
	TransPlayerInfo.dwObjectSerial = lpPlayInfo->dwObjectSerial;

	TransPlayerInfo.x = lpPlayInfo->Position.x;
	TransPlayerInfo.y = lpPlayInfo->Position.y;
	TransPlayerInfo.z = lpPlayInfo->Position.z;

	return lpsmsock->Send( (char *)&TransPlayerInfo , TransPlayerInfo.size , TRUE );
}
*/

//캐릭터 정보적어서 되돌려서 보냄
int rsSendPlayerInfo( rsPLAYINFO *lpSndPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	smCHAR		*lpChar;
	rsPLAYINFO	*lpPlayInfo;
	smTRNAS_PLAYERINFO	TransPlayerInfo;

	//NPC 또는 몬스터
	lpChar = srFindCharFromSerial( lpTransCommand->WParam );
	if ( lpChar ) {
		//lpChar->SendCharInfo( lpsmsock );
		rsSendCharInfo( lpChar , lpSndPlayInfo );
		return TRUE;
	}


	//다른 유저들
	lpPlayInfo = srFindUserFromSerial( lpTransCommand->WParam );
	if ( lpPlayInfo && lpPlayInfo->dwObjectSerial && lpSndPlayInfo && lpSndPlayInfo->lpsmSock) {
		
		memcpy( &TransPlayerInfo.smCharInfo , &lpPlayInfo->smCharInfo , sizeof( smCHAR_INFO ) );

		TransPlayerInfo.size = sizeof( smTRNAS_PLAYERINFO );
		TransPlayerInfo.code = smTRANSCODE_PLAYERINFO;
		TransPlayerInfo.dwObjectSerial = lpPlayInfo->dwObjectSerial;

		TransPlayerInfo.x = lpPlayInfo->Position.x;
		TransPlayerInfo.y = lpPlayInfo->Position.y;
		TransPlayerInfo.z = lpPlayInfo->Position.z;

		return lpSndPlayInfo->lpsmSock->Send( (char *)&TransPlayerInfo , TransPlayerInfo.size , TRUE );
	}

	return TRUE;
}

//캐릭터 정보적어서 되돌려서 보냄 ( 퀵사이즈 )
int rsSendPlayerInfoQuick( rsPLAYINFO *lpSndPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	smCHAR		*lpChar;
	rsPLAYINFO	*lpPlayInfo;
	smTRNAS_PLAYERINFO_QUICK	TransPlayerInfoQ;
	int			QuickSize;

	//NPC 또는 몬스터
	lpChar = srFindCharFromSerial( lpTransCommand->WParam );
	if ( lpChar ) {
		rsSendCharInfo( lpChar , lpSndPlayInfo );
		return TRUE;
	}

	//다른 유저들
	lpPlayInfo = srFindUserFromSerial( lpTransCommand->WParam );
	if ( lpPlayInfo && lpPlayInfo->dwObjectSerial && lpSndPlayInfo && lpSndPlayInfo->lpsmSock ) {

		if ( lpPlayInfo->smCharInfo.bUpdateInfo[0]!=0 ) {	//업데이트 된 정보 (캐릭터 전체정보 보냄)
			//캐릭터 정보적어서 되돌려서 보냄
			//return rsSendPlayerInfo( lpsmsock , lpTransCommand , lpPlayInfo );
			QuickSize = smCHAR_INFO_QUICK_SIZE2;
		}
		else {
			QuickSize = smCHAR_INFO_QUICK_SIZE;
		}
		
		memcpy( &TransPlayerInfoQ.smCharInfo , &lpPlayInfo->smCharInfo , QuickSize );
		TransPlayerInfoQ.size = sizeof( smTRNAS_PLAYERINFO_QUICK )-(sizeof(smCHAR_INFO)-QuickSize);
		TransPlayerInfoQ.code = smTRANSCODE_PLAYERINFO_Q;
		TransPlayerInfoQ.dwObjectSerial = lpPlayInfo->dwObjectSerial;
		TransPlayerInfoQ.x = lpPlayInfo->Position.x;
		TransPlayerInfoQ.y = lpPlayInfo->Position.y;
		TransPlayerInfoQ.z = lpPlayInfo->Position.z;

		return lpSndPlayInfo->lpsmSock->Send( (char *)&TransPlayerInfoQ , TransPlayerInfoQ.size , TRUE );
	}

	return TRUE;
}

#ifdef _PLAY_MORYON
//레벨 차이별 경험치 획득
int srGetTotalExp( int Exp , int Level )
{
/*
	if ( abs(Level)<=10 ) return Exp;					//100%
	if ( abs(Level)<=20 ) return (Exp*90)/100;			//90%
	if ( abs(Level)<=30 ) return (Exp*70)/100;			//70%
	return (Exp*60)/100;
*/
	if ( abs(Level)<=10 ) return Exp;					//100%
	if ( abs(Level)<=20 ) return (Exp*85)/100;			//90%
	if ( abs(Level)<=30 ) return (Exp*70)/100;			//70%

	return (Exp*55)/100;


/*
  - 기존 자료
  (+-)1 ~ (+-)10	: 100%
  (+-)11 ~ (+-)20	: 90%
  (+-)21 ~ (+-)30	: 80%
  (+-)31 ~ (+-)~	: 70%
  

  - 수정 자료
  (+-)1 ~ (+-)10	: 100%
  (+-)11 ~ (+-)20	: 85%
  (+-)21 ~ (+-)30	: 70%
  (+-)31 ~ (+-)~	: 55%
*/

}
#else
//레벨 차이별 경험치 획득
int srGetTotalExp( int Exp , int Level )
{
	if ( Level<=7 ) return Exp;					//100%
	if ( Level<=14 ) return (Exp*80)/100;		//80%
	if ( Level<=20 ) return (Exp*60)/100;		//60%

	return (Exp*40)/100;
}
#endif

//상대 캐릭터에 기술 공격 가함 
int rsSendTransSkillAttack( smCHAR *lpChar , rsPLAYINFO *lpPlayInfo )
{
	TRANS_ATTACKDATA	TransAttackData;
	int	temp;


	//같은클랜 공격 안함
	if ( lpChar->dwClanCode && lpChar->dwClanCode==lpPlayInfo->dwClanCode ) 
		return NULL;


	TransAttackData.code = smTRANSCODE_ATTACKDATA;
	TransAttackData.size = sizeof(TRANS_ATTACKDATA);

	TransAttackData.x = lpPlayInfo->Position.x;
	TransAttackData.y = lpPlayInfo->Position.y;
	TransAttackData.z = lpPlayInfo->Position.z;

	TransAttackData.AttackState = 0x80;
	//TransAttackData.AttackState = 1;
	TransAttackData.AttackSize  = 32*fONE;
	TransAttackData.Power		= GetRandomPos( lpChar->smMonsterInfo.SkillDamage[0] , lpChar->smMonsterInfo.SkillDamage[1] );

	TransAttackData.dwDestObjectSerial = lpChar->dwObjectSerial;
	TransAttackData.dwTarObjectSerial = lpPlayInfo->dwObjectSerial;

	TransAttackData.sRating[0] = lpChar->smCharInfo.Level;
	TransAttackData.sRating[1] = lpChar->smCharInfo.Attack_Rating;

	//종성 아이템 시간종료 확인
	if (  lpPlayInfo->dwSiegeItem_Scroll_Time && lpPlayInfo->dwSiegeItem_Scroll_Time<dwPlayServTime ) {
		lpPlayInfo->dwSiegeItem_Scroll_Code = 0;
		lpPlayInfo->dwSiegeItem_Scroll_Time = 0;
	}
	if (  lpPlayInfo->dwSiegeItem_Stone1_Time && lpPlayInfo->dwSiegeItem_Stone1_Time<dwPlayServTime ) {
		lpPlayInfo->dwSiegeItem_Stone1_Code = 0;
		lpPlayInfo->dwSiegeItem_Stone1_Time = 0;
	}

	if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_B ) {
		//공성 타워크리스탈 (아이스)
		TransAttackData.sRating[0] = -SKILL_PLAY_ICE_CRYSTAL;
		TransAttackData.sRating[1] = 4;
	}
	else if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_G ) 
	{
		//공성 타워크리스탈 (전기)
		TransAttackData.sRating[0] = -SKILL_PLAY_LIGHTNING_CRYSTAL;
		TransAttackData.sRating[1] = 3;
	}
	else if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_R ) {
		//공성 타워크리스탈 (불)
		TransAttackData.sRating[0] = -SKILL_PLAY_FIRE_CRYSTAL;
		TransAttackData.sRating[1] = 1;
	}

	if ( lpPlayInfo->dwSiegeItem_Stone1_Code && lpPlayInfo->dwSiegeItem_Stone1_Code==lpChar->smCharInfo.dwCharSoundCode ) {
		//크리스탈 저항석
		TransAttackData.Power /= 2;		//공격력 절반
		TransAttackData.sRating[0] = lpChar->smCharInfo.Level;
		TransAttackData.sRating[1] = lpChar->smCharInfo.Attack_Rating;
	}

	if ( lpPlayInfo->dwSiegeItem_Scroll_Code==(sinBC1|sin01) ) {	//무적스크롤
		if ( lpPlayInfo->Position.Area==rsCASTLE_FIELD ) return FALSE;
	}
	if ( lpPlayInfo->dwSiegeItem_Scroll_Code==(sinBI1|sin05) )		//무적스크롤
		return FALSE;


	if ( lpPlayInfo->dwSkill_PhysicalAbsorb_Time ) {	//공격력 감소 (흡수력 미리적용)- 피지컬 사용
		if ( lpPlayInfo->dwSkill_PhysicalAbsorb_Time>dwPlayServTime ) {
			TransAttackData.Power -= lpPlayInfo->dwSkill_PhysicalAbsorb_Param;
			if ( TransAttackData.Power<0 ) return FALSE;
		}
		else {
			lpPlayInfo->dwSkill_PhysicalAbsorb_Time = 0;
			lpPlayInfo->dwSkill_PhysicalAbsorb_Param = 0;
		}
	}

	if ( lpPlayInfo->dwSkill_MetalArmor_Time ) {	//공격력 감소 (흡수력 미리적용)- 메탈아머 사용
		if ( lpPlayInfo->dwSkill_MetalArmor_Time>dwPlayServTime ) {
			TransAttackData.Power -= lpPlayInfo->dwSkill_MetalArmor_Param;
			if ( TransAttackData.Power<0 ) return FALSE;
		}
		else {
			lpPlayInfo->dwSkill_MetalArmor_Time = 0;
			lpPlayInfo->dwSkill_MetalArmor_Param = 0;
		}
	}



	if ( lpPlayInfo->dwSkill_HolyBody_Time ) {	//언데드 x% 공격력 감소 (흡수력 미리적용)- 홀리바디 사용
		if ( lpPlayInfo->dwSkill_HolyBody_Time>dwPlayServTime ) {
			if ( lpChar->smCharInfo.Brood==smCHAR_MONSTER_UNDEAD ) {
				TransAttackData.Power -= (TransAttackData.Power*lpPlayInfo->dwSkill_HolyBody_Param)/100;
				if ( TransAttackData.Power<0 ) return FALSE;
			}
		}
		else {
			lpPlayInfo->dwSkill_HolyBody_Time = 0;
			lpPlayInfo->dwSkill_HolyBody_Param = 0;
		}
	}

	if ( lpPlayInfo->dwSkill_VirtualLife_Time ) {	//가상 생명력을 높여서 공격력 감소
		if ( lpPlayInfo->dwSkill_VirtualLife_Time>dwPlayServTime ) {
			TransAttackData.Power -= (TransAttackData.Power*lpPlayInfo->dwSkill_VirtualLife_Param)/100;
			if ( TransAttackData.Power<0 ) return FALSE;
		}
		else {
			lpPlayInfo->dwSkill_VirtualLife_Time = 0;
			lpPlayInfo->dwSkill_VirtualLife_Param = 0;
		}
	}

	if ( lpPlayInfo->dwSkill_EnergyShield_Time ) {	//에너지쉴드 공격력 감소
		if ( lpPlayInfo->dwSkill_EnergyShield_Time>dwPlayServTime ) {
			temp = (TransAttackData.Power*lpPlayInfo->dwSkill_EnergyShield_Param)/100;
			TransAttackData.Power -= temp;
			TransAttackData.AttackState |= (temp<<16);
			if ( TransAttackData.Power<0 ) return FALSE;
		}
		else {
			lpPlayInfo->dwSkill_EnergyShield_Time = 0;
			lpPlayInfo->dwSkill_EnergyShield_Param = 0;
		}
	}

	if ( lpPlayInfo->dwBlessSkill_Code ) {
		if ( lpPlayInfo->dwBlessSkill_Code==SKILL_PLAY_BLESS_ABSORB ) {	//클랜스킬 (흡수)
			if ( lpPlayInfo->dwBlessSkill_Time>dwPlayServTime ) {
				TransAttackData.Power -= lpPlayInfo->dwBlessSkill_Param;
				if ( TransAttackData.Power<0 ) return FALSE;
			}
			else {
				lpPlayInfo->dwBlessSkill_Code = 0;
				lpPlayInfo->dwBlessSkill_Time = 0;
			}
		}
	}

	//카오스카라 스킬
	if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CHAOSCARA && lpChar->smMonsterInfo.SkillRangeRect.left==0 && lpChar->smMonsterInfo.SkillRangeRect.right==0 ) {//lpChar->MotionInfo->KeyCode!='J' ) {
		TransAttackData.sRating[0] = -SKILL_PLAY_CHAOSCARA_VAMP;
		TransAttackData.sRating[1] = 0;
	}

	TransAttackData.dwChkSum = TransAttackData.Power*2002 + 
		(TransAttackData.x * TransAttackData.y * TransAttackData.z);// 조작 방지 코드

	if ( lpPlayInfo->lpsmSock ) {

		//공격 데이타 기록
		lpPlayInfo->Send_AttackCount++;
		lpPlayInfo->Send_AttackDamage+=TransAttackData.Power;

		if ( rsServerConfig.CrazyPacketMode && lpPlayInfo->dwDecPacketCode && 
			lpPlayInfo->dwDecPacketTime2<dwPlayServTime ) {					//크레이지 패킷 모드

			TransAttackData.code = smTRANSCODE_ATTACKDATA2;
			TransAttackData.dwDamageChkSum = dm_GetDamgeChkSum_S2V( &TransAttackData );		//S2C 공격 첵크섬

			if ( lpPlayInfo ) 
				rsEncodeDamagePacket( lpPlayInfo , &TransAttackData );
		}
		else
			TransAttackData.dwDamageChkSum = dm_GetDamgeChkSum_S2V( &TransAttackData );		//S2C 공격 첵크섬


		return lpPlayInfo->lpsmSock->Send2( (char *)&TransAttackData , TransAttackData.size , TRUE );
	}

	return NULL;
}


//캐릭터 변경
int rsCharChanger( smCHAR *lpChar , smCHAR_INFO *lpCharInfo , smCHAR_MONSTER_INFO *lpMonInfo ) 
{
	int rnd,OsCode;
	int dist;
	STG_AREA	*lpStgArea;


	lpStgArea = (STG_AREA *)lpChar->lpExt1;

	lpChar->Close();
	lpChar->Flag = TRUE;

	//캐릭터의 정보 변경
	rnd = lpChar->smCharInfo.bUpdateInfo[0];
	OsCode = lpChar->dwObjectSerial;


	//몬스터 캐릭터 수치 설정
	memcpy( &lpChar->smCharInfo , lpCharInfo , sizeof( smCHAR_INFO ) );
	memcpy( &lpChar->smMonsterInfo , lpMonInfo , sizeof( smCHAR_MONSTER_INFO ) );
	lpChar->ActionPattern = 5;
	
	lpChar->SetLoadPattern( lpChar->smCharInfo.szModelName );

	dist = 64*30;
	lpChar->DistAroundDbl =  dist*dist;
	lpChar->PosiAround.x = lpChar->pX;
	lpChar->PosiAround.z = lpChar->pZ;

	//if ( lpStgArea ) lpStgArea->MonsterCount ++;
	//if ( lpStgArea ) lpStgArea->AddMonTable( lpChar );

	lpChar->ReopenCount	= REOPEN_COUNT_NUM;			//슬립모드시 재시작 시간 카운터
	lpChar->SetMotionFromCode(CHRMOTION_STATE_STAND);
	lpChar->smCharInfo.bUpdateInfo[0] = rnd+1;
	lpChar->dwObjectSerial = OsCode;
	lpChar->lpTargetPlayInfo = 0;
	lpChar->smCharInfo.Life[0] = lpChar->smCharInfo.Life[1];	//생명력 꽉
	lpChar->smCharInfo.StatePoint = lpMonInfo->ClassCode;

	//물약 갯수 등록
	if ( lpChar->smMonsterInfo.PotionCount ) {
		if ( (rand()%100)<lpChar->smMonsterInfo.PotionPercent ) {
			lpChar->smMonsterInfo.PotionCount = (rand()%lpChar->smMonsterInfo.PotionCount)+1;
		}
		else {
			lpChar->smMonsterInfo.PotionCount = 0;
		}
	}

	/* 안쓴다넹~
	if( lpChar->smCharInfo.dwCharSoundCode == snCHAR_SOUND_DEADHOPT )
	{
		rsOpenSubMonster( lpChar , snCHAR_SOUND_DEADHOPT , lpChar->pX+200, 0, lpChar->pZ+50 , 1 ); // pluto 데드 호피 한마리 더 나오게 할려고
	}
	*/
	return TRUE;
}


//데미지준 유저 10명 선별
int	SelectDamageTop10( smCHAR *lpChar ,  rsUSER_LIST_TOP10 *lpUserListDamageTop10 )
{
	int cnt,cnt2;
	int ChkCnt;
	smWINSOCK	*lpsmSock;

	if ( !lpChar->lpAttackDamageList || !lpUserListDamageTop10 ) return FALSE;

	ZeroMemory( lpUserListDamageTop10 , sizeof(rsUSER_LIST_TOP10) );

	for( cnt=0;cnt<10;cnt++ ) {
		ChkCnt = -1;
		for(cnt2=0;cnt2<ATTACK_DAMAGE_LIST_MAX;cnt2++ ) {
			if ( lpChar->lpAttackDamageList[cnt2].dwUserCode && 
				lpChar->lpAttackDamageList[cnt2].DamageCount>lpUserListDamageTop10->Damage[cnt] ) {

					lpUserListDamageTop10->dwUserCode[cnt]	= lpChar->lpAttackDamageList[cnt2].dwUserCode;
					lpUserListDamageTop10->Damage[cnt]		= lpChar->lpAttackDamageList[cnt2].DamageCount;
					lpUserListDamageTop10->Counter[cnt]		= lpChar->lpAttackDamageList[cnt2].Count;

					ChkCnt = cnt2;
				}
		}

		if ( ChkCnt>=0 )
			lpChar->lpAttackDamageList[ChkCnt].dwUserCode = 0;
	}

	lpUserListDamageTop10->dwUpdateTime = dwPlayServTime;
	lpUserListDamageTop10->dwCharCode = lpChar->dwObjectSerial;

	lpUserListDamageTop10->code = smTRANSCODE_SYSTEM;
	lpUserListDamageTop10->size = sizeof(rsUSER_LIST_TOP10);
	lpUserListDamageTop10->tCode = smTRANS_SYSCODE_DMG_USER_LIST;
	lpUserListDamageTop10->dwObjectSerial = rsServerConfig.ServerCode;

	if ( !dwSerToSerIP ) return TRUE;

	lpsmSock = rsFindNextSertoServerSock();

	if ( lpsmSock ) 
		return lpsmSock->Send( (char *)lpUserListDamageTop10 , lpUserListDamageTop10->size , TRUE );

	return FALSE;
}


//SOD 깜짝 아이템 드롭률 테이블
DWORD dwSoD_ItemDropTable[8][2] = {
	{	(sinSD2|sin01)	,	20	},		//폭탄
	{	(sinSD2|sin02)	,	40	},		//시계
	{	(sinSD2|sin03)	,	60	},		//아이스크림
	{	(sinSD2|sin04)	,	68	},		//토끼 인형
	{	(sinSD2|sin05)	,	80	},		//달 수정
	{	(sinSD2|sin06)	,	95	},		//태양 수정
	{	(sinSD2|sin07)	,	100	},		//빛 수정
	{	0,0 }
};



//SOD 용 깜짝 아이템 드롭
int rsOpen_SodItem( smCHAR *lpChar , rsPLAYINFO *lprsPlayInfo )
{
	int rnd,cnt,cnt2;
	psITEM	psItem;
	STG_ITEMS	*lpStgItem;

	//rnd = rand()%10000;
	rnd = rand()%1000;
	if ( rnd<20 ) {
		rnd = rand()%100;
		for(cnt=0;cnt<7;cnt++) {		//임시로 3까지 나온다
			if ( dwSoD_ItemDropTable[cnt][0]==0 ) return FALSE;
			if ( (DWORD)rnd<dwSoD_ItemDropTable[cnt][1] ) {

				for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
					if ( DefaultItems[cnt2].Item.CODE==dwSoD_ItemDropTable[cnt][0] && !DefaultItems[cnt2].Item.UniqueItem ) {
						CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt2] );

						psItem.state = TRUE;
						lpStgItem = ((STG_AREA *)lpChar->lpExt1)->AddItem( &psItem , lpChar->pX>>FLOATNS, lpChar->pY>>FLOATNS, lpChar->pZ>>FLOATNS , TRUE );
						((STG_AREA *)lpChar->lpExt1)->SendStgItemToNearUsers( lpStgItem );

						break;
					}
				}
				return TRUE;
			}
		}
	}

	return FALSE;
}

//이벤트 아이템 드롭 가능 검사 
int rsCheckEventItem( DWORD dwItemCode , rsPLAYINFO *lpPlayInfo , smCHAR *lpChar )
{
	int rnd;


	if ( lpChar->smMonsterInfo.dwEvnetItem==(sinQT1|sin13) ) {
		//3차 전업 아이템
		rnd = rand()%100;

		if ( lpPlayInfo->smCharInfo.ChangeJob<3 && rnd<=20 ) {
			return TRUE;
		}
	}
	else
		return TRUE;


	return FALSE;
}


//몬스터로부터 아이템 경험치 생성
int rsOpen_MonsterItemExp( smCHAR *lpChar , rsPLAYINFO *lprsPlayInfo  )
{
	psITEM		sItem;
	psITEM		*lpsItem = &sItem;
	STG_ITEMS	*lpStgItem;
	smTRANS_COMMAND	smTransCommand;
	int			cnt,cnt2;
	DWORD		dwCode;
	//int			x,z;

	rsPLAYINFO	*lpDamagePlayInfo[10];
	int			DmgPlayUse = FALSE;

	//데미지준 유저목록 존재 확인
	if ( rsUserListDamageTop10.dwCharCode && rsUserListDamageTop10.dwCharCode==lpChar->dwObjectSerial ) {
		for(cnt=0;cnt<10;cnt++) {
			if ( rsUserListDamageTop10.dwUserCode[cnt] ) {
				lpDamagePlayInfo[cnt] = srFindUserFromSerial(rsUserListDamageTop10.dwUserCode[cnt]);
			}
			else
				lpDamagePlayInfo[cnt] = 0;
		}

#ifdef _LANGUAGE_KOREAN
#ifdef _TEST_SERVER

		TRANS_CHATMESSAGE	TransChatMessage;

		for( cnt2=0;cnt2<10;cnt2++ ) {
			if ( lpDamagePlayInfo[cnt2] && lpDamagePlayInfo[cnt2]->AdminMode>=3 ) {
				for(cnt=0;cnt<6;cnt++) {
					if ( lpDamagePlayInfo[cnt] ) {

						wsprintf( TransChatMessage.szMessage , "%s(%d)> %s ( %d  %d )" , 
							lpChar->smCharInfo.szName , cnt ,
							lpDamagePlayInfo[cnt]->smCharInfo.szName,
							rsUserListDamageTop10.Damage[cnt],
							rsUserListDamageTop10.Counter[cnt] );

						TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
						TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
						TransChatMessage.dwIP = 0;
						TransChatMessage.dwObjectSerial = lpDamagePlayInfo[cnt]->dwObjectSerial;
						lpDamagePlayInfo[cnt2]->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
					}
				}
			}
		}

#endif
#endif

		ZeroMemory( &rsUserListDamageTop10 , sizeof(rsUSER_LIST_TOP10) );		//데미지준 유저목록 초기화
		DmgPlayUse = TRUE;

		int	BabelHornSort[10];
		int	BabelHornSortCnt;

		BabelHornSortCnt = 2;
		BabelHornSort[0] = 0;
		BabelHornSort[1] = 1;

		for(cnt=2;cnt<10;cnt++) {
			for(cnt2=0;cnt2<cnt;cnt2++) {
				if ( lpDamagePlayInfo[cnt] && lpDamagePlayInfo[cnt]->lpsmSock && 
					lpDamagePlayInfo[cnt2] && lpDamagePlayInfo[cnt2]->lpsmSock &&
					lpDamagePlayInfo[cnt]->smCharInfo.JOB_CODE==lpDamagePlayInfo[cnt2]->smCharInfo.JOB_CODE ) {
						break;
					}
			}
			if ( cnt2==cnt ) {
				BabelHornSort[BabelHornSortCnt++] = cnt;
			}
		}


		if ( rsServerConfig.Event_BabelHorn && lpChar->lpExt1 ) {
			if ( BabelHornSortCnt<=2 ) {
				//바벨의뿔 나오는 이벤트
				for(cnt=0;cnt<rsServerConfig.Event_BabelHorn;cnt++) {
					if ( lpDamagePlayInfo[cnt] && lpDamagePlayInfo[cnt]->lpsmSock ) {
						rsPutItem( lpDamagePlayInfo[cnt] , (sinGF1|sin02) );
					}
				}
			}
			else {
				for(cnt=0;cnt<rsServerConfig.Event_BabelHorn;cnt++) {
					if ( cnt<BabelHornSortCnt ) {
						cnt2 = BabelHornSort[cnt];
						if ( lpDamagePlayInfo[cnt2] && lpDamagePlayInfo[cnt2]->lpsmSock ) {
							rsPutItem( lpDamagePlayInfo[cnt2] , (sinGF1|sin02) );
						}
					}
				}
			}
		}
	}

	if ( lpChar->smMonsterInfo.dwEvnetItem ) {
		/*
		if ( lpChar->smMonsterInfo.dwEvnetItem==(sinQT1|sin13) ) {
			//3차 전업 아이템
			if ( lprsPlayInfo->smCharInfo.ChangeJob<3 )
				rsPutItem( lprsPlayInfo , lpChar->smMonsterInfo.dwEvnetItem );		//전업퀘스트 아이템 획득
		}
		else
		*/
		if ( rsCheckEventItem(lpChar->smMonsterInfo.dwEvnetItem,lprsPlayInfo,lpChar)==TRUE )
			rsPutItem( lprsPlayInfo , lpChar->smMonsterInfo.dwEvnetItem );		//이벤트 아이템 획득
	}


	for(cnt=0;cnt<lpChar->smMonsterInfo.FallItemPlusCount;cnt++) {
		//추가 아이템 떨이지기
		if ( (rand()%10000)<lpChar->smMonsterInfo.FallItems_Plus[cnt].Percentage ) 
		{
			dwCode = lpChar->smMonsterInfo.FallItems_Plus[cnt].dwItemCode;
			for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
				if ( DefaultItems[cnt2].Item.CODE==dwCode && !DefaultItems[cnt2].Item.UniqueItem ) {
					CreateDefItem( &lpsItem->ItemInfo , &DefaultItems[cnt2] );
					if ( rsServerConfig.Event_Potion ) {
						//물약 이벤트
						if ( (lpsItem->ItemInfo.CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
							lpsItem->ItemInfo.PotionCount = (rand()%rsServerConfig.Event_Potion)+1;
						}
					}

					dwCode = (lpsItem->ItemInfo.CODE&sinITEM_MASK2);
					if ( dwCode==sinMA2 || dwCode==sinQT1 ) {
						//퀘스트 아이템
						rsPutItem2( lprsPlayInfo , &lpsItem->ItemInfo );
						break;
					}

					dwCode = (lpsItem->ItemInfo.CODE&sinITEM_MASK2);
					//일반 아이템
					if ( lpChar->PartyFlag!=rsHARDCORE_EVENT_FLAG || ( lpsItem->ItemInfo.CODE!=(sinGG1|sin01) && (lpsItem->ItemInfo.CODE&sinITEM_MASK1)!=(sinPM1&sinITEM_MASK1) ) ) {
						lpsItem->state = TRUE;
						lpStgItem = ((STG_AREA *)lpChar->lpExt1)->AddItem( lpsItem , lpChar->pX>>FLOATNS, lpChar->pY>>FLOATNS, lpChar->pZ>>FLOATNS , TRUE );

						if ( lpStgItem ) {
							if ( lpChar->smMonsterInfo.AllSeeItem ) {		//아이템 떨어질때 주변유저에게 다보이게
								((STG_AREA *)lpChar->lpExt1)->SendStgItemToNearUsers( lpStgItem );
							}
							else {
								if ( DmgPlayUse ) {
									//데미지준 유저목록 존재 확인 ( 아이템 미리 보이게 )
									for(cnt2=0;cnt2<6;cnt2++) {
										if ( lpDamagePlayInfo[cnt2] ) {
											((STG_AREA *)lpChar->lpExt1)->SendStgItem( lpDamagePlayInfo[cnt2] , lpStgItem );
										}
									}
								}
								else
									((STG_AREA *)lpChar->lpExt1)->SendStgItem( lprsPlayInfo , lpStgItem );

								//다른 유저는 5초 뒤에나 아이템 볼수 있음
								lpStgItem->dwCreateTime += 5000;		
							}
						}
					}
					break;
				}
			}
		}
	}



	int FallItemMax = lpChar->smMonsterInfo.FallItemMax;

	//유료 아이템 사용중 ( 아이템 하나더 추가 )
	if ( FallItemMax>0 ) 
	{
		int	FallRandom = 0;

		if ( lprsPlayInfo->dwTime_PrimeItem_X2>(DWORD)tServerTime )	{		//써드 아이즈 사용중50%
			switch( lprsPlayInfo->dwPrimeItem_PackageCode ) 
			{
			case PRIME_ITEM_PACKAGE_NONE:
				FallRandom = 50;
				break;
			case PRIME_ITEM_PACKAGE_BRONZE:
				FallRandom = 20;
				break;
			case PRIME_ITEM_PACKAGE_SILVER:
				FallRandom = 30;
				break;
			case PRIME_ITEM_PACKAGE_GOLD:
				FallRandom = 40;
				break;
			case PRIME_ITEM_PACKAGE_ULTRA:		// pluto 슈페리어 패키지
				FallRandom = 50;
				break;
			}

		}
		if ( lprsPlayInfo->Bl_RNo>0 )										//PC방인경우 추가 50%
			FallRandom += 50;

		if ( FallRandom && (rand()%100)<FallRandom )
		{
			FallItemMax++;
		}
	}


	//시간별 경험치 분배 ( 중국 )
	if ( rsServerConfig.ExpGameTimeMode==3 ) {
		int giCnt = rsGetExp_GameTime( lprsPlayInfo );
		FallItemMax = (FallItemMax*giCnt)/100;
		if ( giCnt>0 && FallItemMax==0 ) {
			if ( (rand()%100)<giCnt ) FallItemMax = 1;
		}
	}



	for( cnt=0;cnt<FallItemMax;cnt++) {
	//몬스터 아이템 떨어짐
		if ( srGetMonsterItem( lprsPlayInfo , lpChar , lpsItem )==TRUE ) {
			
			if ( rsServerConfig.Event_Potion ) {
				//물약 이벤트
				if ( (lpsItem->ItemInfo.CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
					lpsItem->ItemInfo.PotionCount = (rand()%rsServerConfig.Event_Potion)+1;
				}
			}

////////////////////////////////// 중국 시간별분배 경험치 //////////////////////////////////
#ifdef _LANGUAGE_CHINESE
	if ( rsServerConfig.ExpGameTimeMode==3 && lpsItem->ItemInfo.CODE==(sinGG1|sin01) ) {
		lpsItem->ItemInfo.Money = (lpsItem->ItemInfo.Money*rsGetExp_GameTime( lprsPlayInfo ))/100;
		if ( !lpsItem->ItemInfo.Money ) continue;
		ReformItem( &lpsItem->ItemInfo );
	}
#endif
////////////////////////////////////////////////////////////////////////////////////////////



			dwCode = (lpsItem->ItemInfo.CODE&sinITEM_MASK2);
			if ( dwCode==sinMA2 || dwCode==sinQT1 ) {
				//퀘스트 아이템
				if ( !lprsPlayInfo->smCharInfo.ChangeJob )
					rsPutItem2( lprsPlayInfo , &lpsItem->ItemInfo );		//퀘스트 아이템 ( 꿀 , 기름 )
				else {
					if ( lprsPlayInfo->smCharInfo.ChangeJob==1 && lpsItem->ItemInfo.CODE==(sinQT1|sin06) ) {
						rsPutItem2( lprsPlayInfo , &lpsItem->ItemInfo );		//퀘스트 아이템 ( 뱀프 )
					}
				}
			}
			else {
				//일반 아이템
				if ( lpChar->PartyFlag!=rsHARDCORE_EVENT_FLAG || ( lpsItem->ItemInfo.CODE!=(sinGG1|sin01) && (lpsItem->ItemInfo.CODE&sinITEM_MASK1)!=(sinPM1&sinITEM_MASK1) ) ) {
					lpsItem->state = TRUE;
					lpStgItem = ((STG_AREA *)lpChar->lpExt1)->AddItem( lpsItem , lpChar->pX>>FLOATNS, lpChar->pY>>FLOATNS, lpChar->pZ>>FLOATNS , TRUE );


					if ( lpStgItem ) {
						if ( lpChar->smMonsterInfo.AllSeeItem ) {		//아이템 떨어질때 주변유저에게 다보이게
							((STG_AREA *)lpChar->lpExt1)->SendStgItemToNearUsers( lpStgItem );
						}
						else {
							//if ( lprsPlayInfo->dwPartyInfo ) {
							//	//파티유저들 아이템 동시에 보이게 
							//	((STG_AREA *)lpChar->lpExt1)->SendStgItemToPartyUsers( lprsPlayInfo , lpStgItem );
							//}
							//else {

							if ( DmgPlayUse ) {
								//데미지준 유저목록 존재 확인 ( 아이템 미리 보이게 )
								for(cnt2=0;cnt2<6;cnt2++) {
									if ( lpDamagePlayInfo[cnt2] ) {
										((STG_AREA *)lpChar->lpExt1)->SendStgItem( lpDamagePlayInfo[cnt2] , lpStgItem );
									}
								}
							}
							else
								((STG_AREA *)lpChar->lpExt1)->SendStgItem( lprsPlayInfo , lpStgItem );
							//}
							//다른 유저는 5초 뒤에나 아이템 볼수 있음
							lpStgItem->dwCreateTime += 5000;		
						}
					}
				}
			}
		}
	}


	if ( lprsPlayInfo->BadPlayer ) {
		//배드 플레이어 등록되면 몬스터를 죽일수록 경험치 획득비율이 감소 (최하 10%)
		cnt = lprsPlayInfo->MonsterKillCounter;
		if ( cnt>45 ) cnt=45;
		cnt = (lpChar->smMonsterInfo.GetExp*cnt)/50;
		lpChar->smMonsterInfo.GetExp -= cnt;
	}

	int	ExpBack = 0;
//해외
	int ExpBackup;

	if ( rsServerConfig.Event_ExpUp ) {
		ExpBack = lpChar->smMonsterInfo.GetExp;

#ifdef	_LANGUAGE_PHILIPIN
//ExpBackup = rsServerConfig.Event_ExpUp;		//ExpBackup=경치이벤트 수치 백업
//경험치 관련
		/*
		if(rsServerConfig.Event_ExpUp == 1)
		{
			if(lprsPlayInfo->smCharInfo.Level <=50) ExpBackup = 400;
			if(lprsPlayInfo->smCharInfo.Level <= 40) ExpBackup = 600;
		}*/
		if(lprsPlayInfo->smCharInfo.Level<25) ExpBackup = 400;

		else
		{
			if(rsServerConfig.Event_ExpUp >= 100 && rsServerConfig.Event_ExpUp < 200)
				lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*100)/100;
			else if(rsServerConfig.Event_ExpUp >= 200 && rsServerConfig.Event_ExpUp < 300)
				lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*200)/100;
			else if(rsServerConfig.Event_ExpUp >= 300 && rsServerConfig.Event_ExpUp < 400)
				lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*300)/100;
			else if(rsServerConfig.Event_ExpUp >= 400)
				lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*400)/100;
	//		else if(rsServerConfig.Event_ExpUp >= 500)
	//			lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*500)/100;
			else
				lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*100)/100;
			//lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*ExpBackup)/100;//경치 이벤트시 받는 총 경치
		}

#else
		if(rsServerConfig.Event_ExpUp >= 100 && rsServerConfig.Event_ExpUp < 200)
			lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*100)/100;
		else if(rsServerConfig.Event_ExpUp >= 200 && rsServerConfig.Event_ExpUp < 300)
			lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*200)/100;
		else if(rsServerConfig.Event_ExpUp >= 300 && rsServerConfig.Event_ExpUp < 400)
			lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*300)/100;
		else if(rsServerConfig.Event_ExpUp >= 400)
			lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*400)/100;
		else
			lpChar->smMonsterInfo.GetExp += (lpChar->smMonsterInfo.GetExp*100)/100;

#endif
//#endif
	}

	if ( lprsPlayInfo->dwPartyInfo ) {
		//파티원 경험치 획득
		if ( !lprsPlayInfo->lpPartyMaster || lprsPlayInfo->lpPartyMaster->GetPartyExp( lpChar , lprsPlayInfo )==FALSE ) {
			//파티정보 오류
			lprsPlayInfo->dwPartyInfo = PARTY_STATE_NONE;
			lprsPlayInfo->lpPartyMaster = NULL;
		}
	}
	else {
		//경험치 획득
		smTransCommand.code = smTRANSCODE_ADDEXP;
		smTransCommand.size = sizeof( smTRANS_COMMAND );
		smTransCommand.WParam = srGetTotalExp( lpChar->smMonsterInfo.GetExp , lpChar->smCharInfo.Level-lprsPlayInfo->smCharInfo.Level );			//획득 경험치

		int ExpUp = 0;

		if ( lprsPlayInfo->dwTime_PrimeItem_ExpUp>(DWORD)tServerTime ) {
			switch( lprsPlayInfo->dwPrimeItem_PackageCode ) 
			{
			case PRIME_ITEM_PACKAGE_NONE:
				ExpUp += 30;
				break;
			case PRIME_ITEM_PACKAGE_BRONZE:
				ExpUp += 10;
				break;
			case PRIME_ITEM_PACKAGE_SILVER:
				ExpUp += 20;
				break;
			case PRIME_ITEM_PACKAGE_GOLD:
				ExpUp += 30;
				break;
			case PRIME_ITEM_PACKAGE_ULTRA:
				ExpUp += 40;					// pluto 슈페리어 패키지
				break;
			}
		}


		if ( lprsPlayInfo->Bl_RNo>0 )
			ExpUp +=20;

		//시간별 경험치 분배 ( 베트남 )
		if ( rsServerConfig.ExpGameTimeMode ) {
			smTransCommand.WParam = (smTransCommand.WParam*rsGetExp_GameTime( lprsPlayInfo ))/100;
		}

		if ( ExpUp ) {
			//유료 아이템 사용중 또는 PC방 가맹점 ( 경험치 30% 추가 )
			smTransCommand.WParam += (smTransCommand.WParam*ExpUp)/100;
		}
		
		smTransCommand.LParam = lpChar->dwObjectSerial;					//몬스터 고유번호
		smTransCommand.SParam = (smTransCommand.WParam*3 + smTransCommand.LParam*13)*2002;	//조작 방지 프로텍터 코드

		lprsPlayInfo->spEXP_Out += smTransCommand.WParam;		//나간 경험치 기록
		smTransCommand.EParam = smTransCommand.SParam^lprsPlayInfo->spEXP_Out;

		lprsPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
	}

	if ( ExpBack )
		lpChar->smMonsterInfo.GetExp = ExpBack;

	lprsPlayInfo->MonsterKillCounter++;		//몬스터 죽인 갯수

	rsMonHuntCount ++;						//사냥 횟수 카운터


	return TRUE;
}

//몬스터로부터 아이템 경험치 생성
int rsOpen_MonsterItemExp( rsKILL_MONSTER_INFO *lpKillMonInfo )
{
	rsPLAYINFO *lprsPlayInfo;
	smCHAR	smChar;
	int		cnt;

	for(cnt=0;cnt<chrMonsterCnt;cnt++) {
		if ( chrMonInfoList[cnt].dwAutoCharCode==lpKillMonInfo->dwAutoCharCode && 
			chrMonsterList[cnt].dwCharSoundCode==lpKillMonInfo->dwCharSoundCode ) {

				memcpy( &smChar.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) );
				memcpy( &smChar.smMonsterInfo , &chrMonInfoList[cnt] , sizeof( smCHAR_MONSTER_INFO ) );
				break;
			}
	}
	if ( cnt>=chrMonsterCnt ) return FALSE;

	if ( lpKillMonInfo->PartyFlag==rsHARDCORE_EVENT_FLAG && lpKillMonInfo->dwParam[0]>=sinPM1 ) {
		//SOD2 기력약 선물

		CreatePresentItem( lpKillMonInfo->dwParam[0] , &StageArea[lpKillMonInfo->Area] , lpKillMonInfo->x, lpKillMonInfo->y, lpKillMonInfo->z , 3 );
		return TRUE;
	}

	lprsPlayInfo = srFindUserFromSerial( lpKillMonInfo->dwUserObjectSerial );
	if ( !lprsPlayInfo ) return FALSE;

	smChar.pX = lpKillMonInfo->x;
	smChar.pY = lpKillMonInfo->y;
	smChar.pZ = lpKillMonInfo->z;
	smChar.dwObjectSerial = lpKillMonInfo->dwMonObjectSerial;
	smChar.PartyFlag = lpKillMonInfo->PartyFlag;
	smChar.lpExt1 = &StageArea[lpKillMonInfo->Area];
	smChar.lpExt2 = 0;
	smChar.lpExt3 = 0;
	smChar.lpExt4 = 0;

	return rsOpen_MonsterItemExp( &smChar , lprsPlayInfo );
}


int srAutoCharMain( smCHAR *lpChar )
{

#ifdef _W_SERVER

	int pX,pZ,pY;
	int rX,rZ,rY;
	int dist,dist2;
	int MinDist;
	rsPLAYINFO	*lprsPlayInfo;
	smCHAR		*lpCharTarget;
	STG_AREA	*lpStgArea;
	int	score;
	int	TragetSerachFlag = 0;
	int	MonAttackFlag;
	smTRANS_COMMAND smTransCommand;

	int cnt;

	if ( lpChar->PatLoading ) return TRUE;

	lpChar->Main();

	if ( lpChar->MotionInfo ) {

		if ( rsServerConfig.Event_MorifSheltom && lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_NPC_MORIF ) {
			//이벤트용 모리프 대시
			rsMorifEventMessage( lpChar );
		}
		if ( rsServerConfig.Event_MollyWolf && lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_NPC_MOLLYWOLF ) {
			//이벤트용 늑대 대사
			rsMollyWolfEventMessage( lpChar );
		}
		if ( lpChar->lpLinkPlayInfo && lpChar->dwLinkObjectCode==lpChar->lpLinkPlayInfo->dwObjectSerial ) {
			//퀘스트용 마스터 대사
			rsQuestMasterMessage( lpChar , lpChar->lpLinkPlayInfo );
		}
		if ( rsServerConfig.Event_SantaGoblin && lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_HOBGOBLIN && lpChar->smCharInfo.Level==60 ) {
			//이벤트용 산타고블린 대시
			rsSantaGoblinEventMessage( lpChar );
		}
/*		if ( rsServerConfig.Event_WorldCup && lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_WORLDCUP )
		{
			//이벤트용 월드컵대사
			rsWorldCupEventMessage( lpChar );
		}
*/
		if ( lpChar->MotionInfo->State==CHRMOTION_STATE_DEAD ) {

			if ( lpChar->lpAttackDamageList ) {
				//공격자 목록 기억

				if ( lpChar->smCharInfo.dwCharSoundCode!=snCHAR_SOUND_CASTLE_TOWER_B ) {	//발할라타워 제외
					//데미지준 유저 10명 선별
					SelectDamageTop10( lpChar , &rsUserListDamageTop10 );
				}

				delete lpChar->lpAttackDamageList;
				lpChar->lpAttackDamageList = 0;
			}


			if ( lpChar->lpExt2 && lpChar->FrameCounter>128 && !lpChar->lpMasterPlayInfo ) {
				lprsPlayInfo = (rsPLAYINFO *)lpChar->lpExt2;
				lpChar->lpExt2 = 0;

				if ( lpChar->lpExpAttackPlayInfo && lpChar->lpExpAttackPlayInfo!=lprsPlayInfo) {
					//선제 공격자 우선 설정 ( 40%이상 데미지 )
					if ( lpChar->ExpAttackLife>=((lpChar->smCharInfo.Life[1]*40)/100) ) {
						lprsPlayInfo = lpChar->lpExpAttackPlayInfo;
					}
				}

				if ( lpChar->smMonsterInfo.dwEvnetItem ) {
					//rsPutItem( lprsPlayInfo , lpChar->smMonsterInfo.dwEvnetItem );		//이벤트 아이템 획득
					// 같은 종류의 이벤트 몬스터 생성
					if ( lpChar->smMonsterInfo.EventCode )
						rsReOpenEventMonster( (STG_AREA *)lpChar->lpExt1 , lpChar );
				}

				if ( lprsPlayInfo->lpsmSock && lprsPlayInfo->dwObjectSerial ) {


					//몬스터 사냥정보 보관
					if ( rsPushKillMonster( lpChar , lprsPlayInfo , ((STG_AREA *)lpChar->lpExt1) )==FALSE ) {
						rsOpen_MonsterItemExp( lpChar , lprsPlayInfo  );		//아이템 경험치 획득
					}
					else {
						lprsPlayInfo->MonsterKillCounter++;		//몬스터 죽인 갯수
					}


					//이벤트 중 몬스터 사냥 ( 득점 )
					if ( lprsPlayInfo->EventMode==rsHARDCORE_EVENT_FLAG && lpChar->PartyFlag==rsHARDCORE_EVENT_FLAG && rsHardCoreEvent_Count ) {
						if ( !lpChar->lpExt3 ) {			//소환 몹이 아닌경우만 득점 인정

							if ( rsServerConfig.TestSeverMode )
								score = (lpChar->smMonsterInfo.GetExp>>2)/rsSOD_ScoreDiv;//9;
							else
								score = lpChar->smMonsterInfo.GetExp/rsSOD_ScoreDiv;//9;

							if ( lpChar->smCharInfo.wPlayClass[0]==MONSTER_CLASS_BOSS ) {
								score *= rsHardCoreEvent_Count*2;

								//득점 상황 표시
								rsShowHardCoreEventScore2( lprsPlayInfo , lpChar , score );
							}

							lprsPlayInfo->EventScore += score;
							lprsPlayInfo->EventCount++;					//몬스터 죽인 수
							if ( lprsPlayInfo->sEventParam[0]>=0 && lprsPlayInfo->sEventParam[0]<4 )
								rsSodTeamScore[ lprsPlayInfo->sEventParam[0] ] +=score;		//팀득점에 추가

							rsShowHardCoreEventScore(lprsPlayInfo);		//득점 상황 표시

							rsOpen_SodItem( lpChar , lprsPlayInfo );	//SOD 깜짝 아이템 드롭 
						}
					}

					if ( (lprsPlayInfo->smCharInfo.Level-lpChar->smCharInfo.Level)<20 ) {
						lprsPlayInfo->dwMacroTime = dwPlayServTime;			//랩차 20이상 몬스터 사냥시 매크로 감시 시간 초기화
					}

				}
			}

			if ( lpChar->FrameCounter>400 ) {
				if ( lpChar->lpMasterPlayInfo && lpChar->HoSkillCode && lpChar->lpMasterPlayInfo->lpsmSock ) {
					//스킬 소환몹 죽다! (스킬 취소 시키자)
					smTransCommand.code = smTRANSCODE_CANCEL_SKILL;
					smTransCommand.size = sizeof(smTRANS_COMMAND);
					smTransCommand.WParam = lpChar->HoSkillCode;
					smTransCommand.LParam = lpChar->dwObjectSerial;
					smTransCommand.SParam = 0;
					smTransCommand.EParam = 0;
					lpChar->lpMasterPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
				}

				lpChar->Close();
				((STG_AREA *)lpChar->lpExt1)->MonsterCount--;
				((STG_AREA *)lpChar->lpExt1)->DeleteMonTable( lpChar );
				return TRUE;
			}
		}

		if ( lpChar->MotionInfo->State==CHRMOTION_STATE_WARP && 
			lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_HUNGKY && lpChar->FrameCounter>60 ) {
				//헐크 변신
				for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {

					if ( chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_HULK && chrMonsterList[cnt].szName[0]!=' ' ) {
						if ( lpChar->AttackAnger<=80 ) {
							if ( chrMonsterList[cnt].Level<80 ) {
								//캐릭터 변경 (헐크)
								rsCharChanger( lpChar , &chrMonsterList[cnt], &chrMonInfoList[cnt] ); 
								break;
							}
						}
						else {
							if ( chrMonsterList[cnt].Level>=80 ) {
								//화가 많이난 헝키는 타이푼으로 변신
								rsCharChanger( lpChar , &chrMonsterList[cnt], &chrMonInfoList[cnt] ); 
								break;
							}
						}
					}
				}
		}

		// 언데드 킹호피 변신
		if( lpChar->MotionInfo->State == CHRMOTION_STATE_WARP && 
			lpChar->smCharInfo.dwCharSoundCode == snCHAR_SOUND_DEADHOPT && lpChar->FrameCounter > 60 )
		{
			for( cnt = 0; cnt < chrMonsterCnt; cnt++ )
			{
				if( chrMonsterList[cnt].dwCharSoundCode == snCHAR_SOUND_DEADKINGHOPY && chrMonsterList[cnt].szName[0] != ' ' )
				{
					if( lpChar->AttackAnger <= 80 )
					{
						if( chrMonsterList[cnt].Level >= 108)
						{
							rsCharChanger( lpChar, & chrMonsterList[cnt], &chrMonInfoList[cnt] );
							break;
						}
					}
					else
					{
						if( chrMonsterList[cnt].Level >= 108)
						{
							rsCharChanger( lpChar, & chrMonsterList[cnt], &chrMonInfoList[cnt] );
							break;
						}
					}
				}
			}
		}
	}



	if ( lpChar->AttackUserFlag ) {
		//이번 카운트에 유저 공격
		lpChar->AttackUserFlag = 0;
		if ( lpChar->lpTargetPlayInfo )
			lpChar->lpTargetPlayInfo->HitMonsterCount = 0;		//몬스터 공격 카운터 초기화

	}

	if ( lpChar->smCharInfo.Life[0]<0 ) lpChar->smCharInfo.Life[0] = 0;
	if ( lpChar->smCharInfo.Life[0]>lpChar->smCharInfo.Life[1] ) lpChar->smCharInfo.Life[0] = lpChar->smCharInfo.Life[1];

	lpChar->ReopenCount	= REOPEN_COUNT_NUM;			//슬립모드시 재시작 시간 카운터

	if ( (srAutoPlayCount&0x3F)==0 ) {
		lpChar->MakeTransPlayData( lpChar->srTransBuff , 0x10 , 4 );

		pX = lpChar->pX;
		pY = lpChar->pY;
		pZ = lpChar->pZ;

		MinDist = DIST_TRANSLEVEL_LOW;

		lpStgArea = ((STG_AREA *)lpChar->lpExt1);

		if ( lpStgArea && lpChar->lpMasterPlayInfo ) {
			lpCharTarget = 0;
			//주인이 있는 캐릭터
			for(cnt=0;cnt<lpStgArea->MonsterLastPoint;cnt++) {
				if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]!=lpChar &&
					lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0]>0 ) {

					//소환 몹은 주인의 공격에 따라서 시행
					if ( lpChar->HoSkillCode && !lpChar->HoSkillMode && lpChar->lpMasterPlayInfo && lpChar->lpMasterPlayInfo->lpChrTarget!=lpStgArea->lpCharMonster[cnt] ) 
						continue;

					MonAttackFlag = 1;

					//같은 클랜 끼리는 공격 안함
					if ( lpChar->smCharInfo.ClassClan && lpChar->smCharInfo.ClassClan==lpStgArea->lpCharMonster[cnt]->smCharInfo.ClassClan ) 
						MonAttackFlag = 0;

					//같은 소환몹 끼리는 공격 안함
					if ( lpChar->HoSkillCode ) {
						if ( lpStgArea->lpCharMonster[cnt]->HoSkillCode )
							MonAttackFlag = 0;
						else if (lpStgArea->lpCharMonster[cnt]->dwLinkObjectCode && lpStgArea->lpCharMonster[cnt]->dwLinkObjectCode!=lpChar->lpMasterPlayInfo->dwObjectSerial)
							MonAttackFlag = 0;
					}

					//빌링 아이템으로 소환한 경우
					if ( lpChar->Clan_CastleMasterFlag && lpStgArea->lpCharMonster[cnt]->Clan_CastleMasterFlag )
						MonAttackFlag = 0;


					//소환몹이 소환한 경우
					if ( lpChar==lpStgArea->lpCharMonster[cnt]->lpLinkChar || lpChar->lpLinkChar==lpStgArea->lpCharMonster[cnt] )
						MonAttackFlag = 0;

					if ( MonAttackFlag ) {

						rX = (pX-lpStgArea->lpCharMonster[cnt]->pX)>>FLOATNS;
						rY = (pY-lpStgArea->lpCharMonster[cnt]->pY)>>FLOATNS;
						rZ = (pZ-lpStgArea->lpCharMonster[cnt]->pZ)>>FLOATNS;

						dist = rX*rX+rZ*rZ+rY*rY;

						if ( dist<DIST_TRANSLEVEL_CONNECT && abs(rX)<TRANS_VIEW_LIMIT && abs(rZ)<TRANS_VIEW_LIMIT ) {

							if ( dist<MinDist && abs(rY)<140) {
								MinDist = dist;
								//유저가 캐릭터 시야내에 들어온경우 목표로 설정
								if ( dist<lpChar->smCharInfo.Sight ) {
									lpCharTarget = lpStgArea->lpCharMonster[cnt];


								}
							}
						}
					}
				}
			}

			lpChar->lpTargetChar = lpCharTarget;

			if ( lpCharTarget ) {
				lpChar->SetNextTarget( 
						lpCharTarget->pX ,
						lpCharTarget->pY ,
						lpCharTarget->pZ );
			}

			if ( lpChar->dwUpdateCharInfoTime && lpChar->dwUpdateCharInfoTime<dwPlayServTime && lpChar->smCharInfo.Life[0]>0 ) {
				//몬스터 재생 시간 초과 (자동으로 죽는다 )
				lpChar->smCharInfo.Life[0] = 0;
				lpChar->SetMotionFromCode( CHRMOTION_STATE_DEAD );
			}

		}
		else {

			TragetSerachFlag = FALSE;

			if ( lpChar->dwCompulsionTime ) {
				//시선끄는 유저가 있는경우 목표로 설정
				if ( lpChar->dwCompulsionTime>dwPlayServTime && lpChar->lpCompulsionPlayInfo && lpChar->lpCompulsionPlayInfo->lpsmSock ) {
					lpChar->lpTargetPlayInfo = lpChar->lpCompulsionPlayInfo;

					lpChar->SetNextTarget( 
							lpChar->lpTargetPlayInfo->Position.x ,
							lpChar->lpTargetPlayInfo->Position.y ,
							lpChar->lpTargetPlayInfo->Position.z );

					TragetSerachFlag = TRUE;
				}
				else {
					lpChar->dwCompulsionTime = 0;
					lpChar->lpCompulsionPlayInfo = 0;
				}
			}

			if ( !TragetSerachFlag ) {
				if ( !lpChar->lpTargetChar ) {
					lprsPlayInfo = 0;
					for(cnt=0;cnt<CONNECTMAX;cnt++) {
						if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial && rsPlayInfo[cnt].smCharInfo.Life[0] &&
							rsPlayInfo[cnt].smCharInfo.State!=smCHAR_STATE_ENEMY ) {

							//솔로 대전모드
							if ( lpChar->dwLinkObjectCode && lpChar->dwLinkObjectCode!=rsPlayInfo[cnt].dwObjectSerial ) continue;
							if ( lpChar->dwClanCode && lpChar->dwClanCode==rsPlayInfo[cnt].dwClanCode ) continue;	//같은클랜 공격 안함

							rX = (pX-rsPlayInfo[cnt].Position.x)>>FLOATNS;
							rY = (pY-rsPlayInfo[cnt].Position.y)>>FLOATNS;
							rZ = (pZ-rsPlayInfo[cnt].Position.z)>>FLOATNS;

							dist = rX*rX+rZ*rZ+rY*rY;

							if ( dist<DIST_TRANSLEVEL_CONNECT && abs(rX)<TRANS_VIEW_LIMIT && abs(rZ)<TRANS_VIEW_LIMIT ) {

								if ( lpChar->AttackSkillRange && abs(rY)<140 ) {
									if ( lpChar->smMonsterInfo.SkillDistance && lpChar->smMonsterInfo.SkillRangeRect.left && lpChar->smMonsterInfo.SkillRangeRect.right ) {
										if ( rsPlayInfo[cnt].Position.x>lpChar->smMonsterInfo.SkillRangeRect.left &&
											rsPlayInfo[cnt].Position.x<lpChar->smMonsterInfo.SkillRangeRect.right &&
											rsPlayInfo[cnt].Position.z>lpChar->smMonsterInfo.SkillRangeRect.top &&
											rsPlayInfo[cnt].Position.z<lpChar->smMonsterInfo.SkillRangeRect.bottom ) {

												rsSendTransSkillAttack( lpChar , &rsPlayInfo[cnt] );
											}
									}
									else {
										if ( dist<lpChar->AttackSkillRange ) {
											//상대 캐릭터에 기술 공격 가함 
											rsSendTransSkillAttack( lpChar , &rsPlayInfo[cnt] );
										}
									}
								}

								if ( dist<MinDist && abs(rY)<140) {
//									MinDist = dist;		// pluto 파이크 베니쉬 공격 버그 몹이 유저 인식못함
									dist2 = lpChar->smCharInfo.Sight;

									//배니쉬 스킬 사용중일때 처리
									if ( rsPlayInfo[cnt].dwSkill_Vanish_Time ) {
										if ( rsPlayInfo[cnt].dwSkill_Vanish_Time<dwPlayServTime ) {
											//배니쉬 종료
											rsPlayInfo[cnt].dwSkill_Vanish_Time = 0;
											rsPlayInfo[cnt].dwSkill_Vanish_Param = 0;
										}
										else {

											if ( lpChar->smCharInfo.dwCharSoundCode!=snCHAR_SOUND_BABEL &&
												lpChar->smCharInfo.dwCharSoundCode!=snCHAR_SOUND_DEATHKNIGHT &&
												lpChar->smCharInfo.dwCharSoundCode!=snCHAR_SOUND_KELVEZU &&
												lpChar->smCharInfo.dwCharSoundCode!=snCHAR_SOUND_MOKOVA ) 
											{
												dist2 = (lpChar->smMonsterInfo.Real_Sight*Vanish_Range[rsPlayInfo[cnt].dwSkill_Vanish_Param])/100;
												dist2 = lpChar->smMonsterInfo.Real_Sight+dist2;
												if ( dist2>0 ) dist2 *= dist2;
												else dist2 = 0;
											}
										}
									}

									//유저가 캐릭터 시야내에 들어온경우 목표로 설정
									if ( dist<dist2 && !rsPlayInfo[cnt].HideMode ) {

										//하드코어 이벤트용 ( 이벤트 몬스터는 이벤트 참여 캐릭만 목표로 설정 )
										if ( lpChar->PartyFlag==rsHARDCORE_EVENT_FLAG ) {
											if (rsPlayInfo[cnt].EventMode==rsHARDCORE_EVENT_FLAG )
												lprsPlayInfo = &rsPlayInfo[cnt];
										}
										else 
											lprsPlayInfo = &rsPlayInfo[cnt];

										MinDist = dist;		// pluto 파이크 베니쉬 공격 버그 몹이 유저 인식못함
									}
								}
							}
						}
					}

					if ( lpChar->PlayStunCount ) lprsPlayInfo = 0;			//중립 모드 (로어)
					if ( lpChar->AttackSkillRange ) lpChar->AttackSkillRange = 0;

					if ( !lpChar->dwTargetLockTime ) {						//타겟 고정이 아닐경우
						lpChar->lpTargetPlayInfo = lprsPlayInfo;

						if ( lprsPlayInfo ) {
							lpChar->SetNextTarget( 
									lprsPlayInfo->Position.x ,
									lprsPlayInfo->Position.y ,
									lprsPlayInfo->Position.z );
						}
					}
					else {
						if ( lpChar->dwTargetLockTime<dwPlayServTime )
							lpChar->dwTargetLockTime = 0;
					}
				}
				else {
					lpChar->SetNextTarget( lpChar->lpTargetChar->pX , lpChar->lpTargetChar->pY , lpChar->lpTargetChar->pZ );
				}
			}
		}



		if ( lpChar->ActionPattern==5 && lpChar->dwLastTransTime && (lpChar->dwLastTransTime+5*60*1000)<dwPlayServTime && !lpChar->dwUpdateCharInfoTime ) {
			//5분동안 행동이 없었다
			lpChar->Close();
			((STG_AREA *)lpChar->lpExt1)->MonsterCount--;
			((STG_AREA *)lpChar->lpExt1)->DeleteMonTable( lpChar );
		}
	}
#endif
	return TRUE;

}

//다른 캐릭터와의 위치 겹치는지 확인
smCHAR *Serv_CheckOtherPlayPosi( int x, int y, int z )
{
	int cnt;
	int dist;
	int dx,dz;
	smCHAR *lpChar;
	STG_AREA	*lpStgArea_AutoPlayer;


	lpStgArea_AutoPlayer = (STG_AREA *)lpActiveChar->lpExt1;

	if ( !lpStgArea_AutoPlayer ) 	return NULL;

	for( cnt=0;cnt<lpStgArea_AutoPlayer->MonsterLastPoint;cnt++) {
		lpChar = lpStgArea_AutoPlayer->lpCharMonster[cnt];

		if ( lpChar && lpActiveChar!=lpChar && lpChar->smCharInfo.Life[0]>0 ) {
			if ( (y-32*fONE)<lpChar->pY && (y+32*fONE)>lpChar->pY ) {

				dx = (lpChar->pX-x)>>FLOATNS;
				dz = (lpChar->pZ-z)>>FLOATNS;
				dist =dx*dx+dz*dz;
				if ( dist<(32*32) ) return lpChar;
			}
		}
	}

	return NULL;
}

//자동 캐릭터 플레이
int srAutoPlayMain()
{
	int cnt, ChrCnt;

	dwPlayTime = GetCurrentTime();


	if ( (srAutoPlayCount&3)==0 ) {
		ActivePlayCounter = 0;

		for(ChrCnt=0;ChrCnt<AUTOPLAYER_MAX;ChrCnt++) {
			if ( chrAutoPlayer[ChrCnt].Flag ) {
				lpActiveChar = &chrAutoPlayer[ChrCnt];
				if ( chrAutoPlayer[ChrCnt].NearPlayCount ||	chrAutoPlayer[ChrCnt].MotionInfo->State==CHRMOTION_STATE_DEAD || 
					chrAutoPlayer[ChrCnt].smMonsterInfo.EventCode ) {

					srAutoCharMain( &chrAutoPlayer[ChrCnt] );
					chrAutoPlayer[ChrCnt].NearPlayCount--;
				}
				else {
					if ( lpActiveChar->smCharInfo.State==smCHAR_STATE_ENEMY && !lpActiveChar->smMonsterInfo.EventCode ) {
						lpActiveChar->ReopenCount--;
						if ( lpActiveChar->ReopenCount<=0 ) {
							//시간 초과 몬스터 제거
							lpActiveChar->Close();
							((STG_AREA *)lpActiveChar->lpExt1)->MonsterCount--;
							((STG_AREA *)lpActiveChar->lpExt1)->DeleteMonTable( lpActiveChar );
						}
					}
				}
				ActivePlayCounter++;
			}
		}
	}



	srAutoPlayCount++;
	if ( (srAutoPlayCount&0x3F)==0 ) {
		rsAutoPlayTransCount++;
	}

	for( cnt=0;cnt<STAGE_AREA_MAX;cnt++) {
		if ( StageArea[cnt].lpStage ) {
			StageArea[cnt].Main();
		}
	}

	if ( (srAutoPlayCount&0x3FF)==0 ) {
		dwServ_GameTimeHour = GetGameTimeHour();
		//밤낮 확인하여 세팅
		if ( dwServ_GameTimeHour>=GAME_HOUR_DAY && dwServ_GameTimeHour<GAME_HOUR_DARKNESS )
			dwServ_NightDay = FALSE;
		else
			dwServ_NightDay = TRUE;
	}

	return TRUE;
}

//자동 버퍼링 전송
int srTransPlayData( rsPLAYINFO *lpPlayInfo )
{

	char TransBuff[ TRANS_BUFF_SIZE ];
	char *lpTransBuff;
	smPLAYDATA_GROUP *lpPlayDataGroup;
	int cnt;
	smPLAYDATA	*lpPlayData;
	int dist;
	int size;
	int x,z;
	int PlayDataCnt;
	smCHAR *lpChar;
	int	TransDataCount;
	int	TransOver;
	int	ClipCnt;
	int SndFlag;
	smTRANS_COMMAND	*lpTransCommand;
	smTRANS_COMMAND_EX	*lpTransCommandEx;
	int SoloMode = 0;


	lpPlayDataGroup = (smPLAYDATA_GROUP *)TransBuff;
	lpTransBuff = TransBuff+sizeof(smPLAYDATA_GROUP);

	lpPlayDataGroup->code = smTRANSCODE_PLAYDATAGROUP;
	//보내기 구분 코드
	lpPlayDataGroup->dwSendCode = 0x80000000+(lpPlayInfo->SendPlayGroupCount&0x00FFFFFF);

	PlayDataCnt = 0;
	TransDataCount = 0;
	SndFlag = 0;

	TransOver = lpPlayInfo->LastTransAutoPlayCount+AUTOPLAYER_MAX;

	if ( lpPlayInfo->Position.Area==QUEST_ARENA_FIELD && lpPlayInfo->AdminMode<=3 ) SoloMode=TRUE;		//1:1 대전 모드

	if (lpPlayInfo->lpChrTarget) {
		//목표 캐릭터 있으면 우선 전송
		lpChar = lpPlayInfo->lpChrTarget;
		if ( lpChar->Flag && lpChar->dwObjectSerial==lpPlayInfo->dwTarObjSerial &&
			lpChar->srTransBuffSize  ) {
			x = ( lpChar->pX-lpPlayInfo->Position.x )>>FLOATNS;
			z = ( lpChar->pZ-lpPlayInfo->Position.z )>>FLOATNS;
			dist = x*x+z*z;

			if ( dist<DIST_TRANSLEVEL_HIGH && abs(x)<TRANS_VIEW_LIMIT && abs(z)<TRANS_VIEW_LIMIT ) {
				//근거리 정확한 데이타 필요
				size = ((smTRANS_PLAYDATA *)lpChar->srTransBuff)->size;
				memcpy( lpTransBuff , lpChar->srTransBuff , size );
				lpTransBuff += size;
				TransDataCount+=3;
				PlayDataCnt++;
				lpChar->NearPlayCount = 256;			//몬스터(NPC) 주변 캐릭터 카운터 기록
			}
			else {
				lpPlayInfo->lpChrTarget = 0;
			}
		}
		else {
			lpPlayInfo->lpChrTarget = 0;
		}
	}

	for( cnt=lpPlayInfo->LastTransAutoPlayCount;cnt<TransOver;cnt++) {
		ClipCnt = cnt&AUTOPLAYER_MASK;

		if ( SoloMode && chrAutoPlayer[ClipCnt].dwLinkObjectCode!=lpPlayInfo->dwObjectSerial )	{	//1:1 대전 모드 (대전 몬스터만 표시)
			if ( chrAutoPlayer[ClipCnt].smCharInfo.Brood!=smCHAR_MONSTER_USER || chrAutoPlayer[ClipCnt].lpMasterPlayInfo!=lpPlayInfo ) 		//몬스터 종족 (유저편)
				continue;
		}

		if ( chrAutoPlayer[ClipCnt].Flag && chrAutoPlayer[ClipCnt].srTransBuffSize ) {
			lpChar = &chrAutoPlayer[ClipCnt];
			x = ( lpChar->pX-lpPlayInfo->Position.x )>>FLOATNS;
			z = ( lpChar->pZ-lpPlayInfo->Position.z )>>FLOATNS;
			dist = x*x+z*z;


			if ( dist<DIST_TRANSLEVEL_CONNECT && lpPlayInfo->lpChrTarget!=lpChar && 
				abs(x)<TRANS_VIEW_LIMIT && abs(z)<TRANS_VIEW_LIMIT) {
				size = ((smTRANS_PLAYDATA *)lpChar->srTransBuff)->size;

				//버퍼의 다찾으면 클라이언트로 전송
				if ( (lpTransBuff-TransBuff+size)>=(TRANS_BUFF_SIZE-sizeof(smTRANS_COMMAND)) ) {
					lpPlayDataGroup->size = (lpTransBuff-TransBuff);
					lpPlayDataGroup->PlayDataCnt = PlayDataCnt;
					lpPlayInfo->lpsmSock->Send( (char *)lpPlayDataGroup , lpPlayDataGroup->size , TRUE );

					PlayDataCnt = 0;
					lpTransBuff = TransBuff+sizeof(smPLAYDATA_GROUP);
					SndFlag++;
					break;
				}

				if ( lpPlayInfo->Position.Area==rsCASTLE_FIELD && chrAutoPlayer[ClipCnt].DontMoveFlag ) {

					if ( chrAutoPlayer[ClipCnt].smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_TOWER_B ||
						chrAutoPlayer[ClipCnt].smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_DOOR ) 
					{
						dist = DIST_TRANSLEVEL_HIGH-1;		//공성용 오브젝트 멀리서도 보이게 출력
					}
				}

				if ( dist<DIST_TRANSLEVEL_HIGH ) {
					//근거리 정확한 데이타 필요
					memcpy( lpTransBuff , lpChar->srTransBuff , size );
					lpTransBuff += size;
					TransDataCount+=3;
					PlayDataCnt++;
					lpChar->NearPlayCount = 256;			//몬스터(NPC) 주변 캐릭터 카운터 기록
					if ( TransDataCount>=TRANS_MAX_CHAR_LIMIT ) break;
				}
				else {
					if ( lpChar->MotionInfo->State!=CHRMOTION_STATE_DEAD ) {
						//거리가 멀음
						lpPlayData = (smPLAYDATA *)lpTransBuff;

						lpPlayData->size = sizeof( smPLAYDATA );
						lpPlayData->code = smTRANSCODE_PLAYDATA1;
						lpPlayData->x = lpChar->pX;
						lpPlayData->y = lpChar->pY;
						lpPlayData->z = lpChar->pZ;

						lpPlayData->angle[0] = lpChar->Angle.x;
						lpPlayData->angle[1] = lpChar->Angle.y;
						lpPlayData->angle[2] = lpChar->Angle.z;
						lpPlayData->angle[3] = (short)lpChar->MotionInfo->State;
						lpPlayData->frame = lpChar->frame;
						lpPlayData->dwObjectSerial = lpChar->dwObjectSerial;
						lpPlayData->dwAutoCharCode = lpChar->smMonsterInfo.dwAutoCharCode;

						lpTransBuff +=sizeof( smPLAYDATA );

						TransDataCount++;
						PlayDataCnt++;
						lpChar->NearPlayCount = 256;			//몬스터(NPC) 주변 캐릭터 카운터 기록
						if ( TransDataCount>=TRANS_MAX_CHAR_LIMIT ) break;
					}
				}
			}
		}
	}

	//바벨 출현중 알림
	if ( lpPlayInfo->Position.Area==BabelPlayField && dwBabelPlayTime>dwPlayServTime ) {
		lpTransCommand = (smTRANS_COMMAND *)lpTransBuff;
		lpTransCommand->code = smTRANSCODE_PLAY_COMMAND;
		lpTransCommand->size = sizeof(smTRANS_COMMAND);
		lpTransCommand->WParam = lpPlayInfo->dwObjectSerial;
		lpTransCommand->LParam = smCOMMAND_PLAY_BABEL;
		lpTransCommand->SParam = BabelPlayField;
		lpTransCommand->EParam = 0;
		lpTransBuff +=sizeof( smTRANS_COMMAND );
	}
/*
	//켈베쥬 출현중 알림
	if ( lpPlayInfo->Position.Area==KelvezuPlayField && dwKelvezuPlayTime>dwPlayServTime ) {
		lpTransCommand = (smTRANS_COMMAND *)lpTransBuff;
		lpTransCommand->code = smTRANSCODE_PLAY_COMMAND;
		lpTransCommand->size = sizeof(smTRANS_COMMAND);
		lpTransCommand->WParam = lpPlayInfo->dwObjectSerial;
		lpTransCommand->LParam = smCOMMAND_PLAY_KELVEZU;
		lpTransCommand->SParam = KelvezuPlayField;
		lpTransCommand->EParam = 0;
		lpTransBuff +=sizeof( smTRANS_COMMAND );
	}
*/
	//공성전 정보
	if ( lpPlayInfo->Position.Area==rsCASTLE_FIELD && StageArea[rsCASTLE_FIELD].dwActiveMode ) {

		lpTransCommandEx = (smTRANS_COMMAND_EX *)lpTransBuff;
		lpTransCommandEx->code = smTRANSCODE_PLAY_COMMAND;
		lpTransCommandEx->size = sizeof(smTRANS_COMMAND_EX);
		lpTransCommandEx->WParam = lpPlayInfo->dwObjectSerial;
		lpTransCommandEx->LParam = smCOMMAND_PLAY_BELSS_CASTLE;
		lpTransCommandEx->SParam = (rsBlessCastle.CastleMode<<16)|((rsBlessCastle.DefenceLevel)&0xFFFF);
		lpTransCommandEx->EParam = rsBlessCastle.dwMasterClan;
		lpTransCommandEx->WxParam = ((int *)rsBlessCastle.TimeSec)[0];		//진행시간
		lpTransCommandEx->LxParam = ((int *)rsBlessCastle.bCrystalSolderCount)[0];	//용병수
		lpTransCommandEx->SxParam = ((int *)lpPlayInfo->sBlessCastle_Damage)[0];	//개인 데미지
		lpTransCommandEx->ExParam = 0;
		lpTransBuff +=sizeof( smTRANS_COMMAND_EX );

		((int *)lpPlayInfo->sBlessCastle_Damage)[0] = 0;		//보낸후 초기화
	}

	//PK 허용 필드
	if ( lpPlayInfo->Position.Area==rsServerConfig.Enable_PKField && rsServerConfig.Enable_PKField>=0 && StageArea[rsServerConfig.Enable_PKField].dwActiveMode ) {
		lpTransCommand = (smTRANS_COMMAND *)lpTransBuff;
		lpTransCommand->code = smTRANSCODE_PLAY_COMMAND;
		lpTransCommand->size = sizeof(smTRANS_COMMAND);
		lpTransCommand->WParam = lpPlayInfo->dwObjectSerial;
		lpTransCommand->LParam = smCOMMAND_PLAY_PK_FIELD;
		lpTransCommand->SParam = rsServerConfig.Enable_PKField;
		lpTransCommand->EParam = 0;
		lpTransBuff +=sizeof( smTRANS_COMMAND );
	}

	//클라이언트로 남은 데이타 전송
	if ( SndFlag==0 ) {
		lpPlayDataGroup->size = (lpTransBuff-TransBuff);
		lpPlayDataGroup->PlayDataCnt = PlayDataCnt;
		lpPlayInfo->lpsmSock->Send( (char *)lpPlayDataGroup , lpPlayDataGroup->size , TRUE );
	}

	ClipCnt = cnt&AUTOPLAYER_MASK;
	lpPlayInfo->LastTransAutoPlayCount = ClipCnt;
	lpPlayInfo->SendPlayGroupCount++;

	if ( (lpPlayInfo->SendPlayGroupCount&0x1F)==0 ) {
		if ( rsServerConfig.Event_HardCore ) {
			//이벤트 지역인지 첵크
			if ( rsCheckHardCoreEventArea( lpPlayInfo->Position.x, lpPlayInfo->Position.y, lpPlayInfo->Position.z )==TRUE ) {
				//if ( !lpPlayInfo->AdminMode && lpPlayInfo->EventMode!=rsHARDCORE_EVENT_FLAG ) {
				if ( lpPlayInfo->EventMode!=rsHARDCORE_EVENT_FLAG ) {
					//제한 구역 침범
					lpPlayInfo->AreaOutCount++;
					//if ( lpPlayInfo->AreaOutCount>=5 && !lpPlayInfo->dwHopeDisconnectTime ) {
						//lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime + 10*1000;		//10초후 강제 종료
						//lpPlayInfo->BadPlayer = TRUE;

					if ( lpPlayInfo->AreaOutCount==10 ) {
						//군서버에 신고
						smTRANS_COMMAND	smTransCommand;
						smTransCommand.size = sizeof(smTRANS_COMMAND);
						smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
						smTransCommand.WParam = 1840;
						smTransCommand.SParam = lpPlayInfo->smCharInfo.Level;
						smTransCommand.LParam = 9100;
						rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
						lpPlayInfo->AreaOutCount = 0;
					}
				}
			}
			//else
			//	lpPlayInfo->AreaOutCount = 0;
		}

	}

	return TRUE;
}

//#define TRANS_MAX_CHAR_LIMIT_OVER		(TRANS_MAX_CHAR_LIMIT*8)
#define TRANS_MAX_USER_LIMIT_OVER		(TRANS_MAX_USER_LIMIT*4)

//주변 유저 전송 거리
int rsConnectViewDist = DIST_TRANSLEVEL_CONNECT;

//자동 버퍼링 전송 ( 다른 플레이어들의 데이타 )
int srTransPlayUserData( rsPLAYINFO *lpPlayInfo )
{

	char TransBuff[ TRANS_BUFF_SIZE ];
	char *lpTransBuff;
	smPLAYDATA_GROUP *lpPlayDataGroup;
	int cnt;
	smPLAYDATA	*lpPlayData;
	int dist;
	int size;
	int x,z;
	int PlayDataCnt;
	int TransDataCount;
	int	sbCnt;
	//smCHAR *lpChar;
	rsPLAYINFO *lpPlayInfo2;
	TRANS_CHATMESSAGE	TransChatMessage;
	int	TransOver;
	int	ClipCnt;
	int SndFlag;
	int	ddist;
	DWORD	dwSendFrame;
	DWORD	dwRecvFrame;

	int sLen;
	int SoloMode=0;

	lpPlayDataGroup = (smPLAYDATA_GROUP *)TransBuff;
	lpTransBuff = TransBuff+sizeof(smPLAYDATA_GROUP);

	lpPlayDataGroup->code = smTRANSCODE_PLAYDATAGROUP;
	//보내기 구분 코드
	lpPlayDataGroup->dwSendCode = lpPlayInfo->SendPlayGroupCount&0x00FFFFFF;

	PlayDataCnt = 0;
	TransDataCount = 0;
	SndFlag = 0;

	if ( lpPlayInfo->dwPartyInfo==PARTY_STATE_MASTER && lpPlayInfo->PartyUpdateFlag && !rsServerConfig.szLinkServerIP[0] ) {
		//파티장 / 파티정보 업데이트
		lpPlayInfo->UpdatePartyPlayInfo();
	}

	if ( lpPlayInfo->Position.Area==QUEST_ARENA_FIELD ) SoloMode=TRUE;		//1:1 대전 모드

	if ( lpPlayInfo->szChatMessage[0] ) {
		sLen = lstrlen(lpPlayInfo->szChatMessage)+1;
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(lpPlayInfo->szChatMessage);
		TransChatMessage.dwObjectSerial = lpPlayInfo->dwObjectSerial;
		memcpy( TransChatMessage.szMessage , lpPlayInfo->szChatMessage , sLen );

		if ( lpPlayInfo->ChatMsgMode ) {
			TransChatMessage.dwIP = lpPlayInfo->ChatMsgMode;	//거래용 채팅
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			ddist = DIST_TRANSLEVEL_LOW;		//거래용 채팅은 먼거리까지 보낼수 있다
		}
		else {
			TransChatMessage.dwIP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;
			ddist = DIST_TRANSLEVEL_HIGH;
		}

		for( cnt=0;cnt<CONNECTMAX;cnt++) {
			if ( rsPlayInfo[cnt].lpsmSock && &rsPlayInfo[cnt]!=lpPlayInfo && rsPlayInfo[cnt].TransInfoFlag &&
				(!SoloMode || rsPlayInfo[cnt].AdminMode>=3 ) ) {

				//같은 파티원은 여기서 보내지 않는다
				//if ( !lpPlayInfo->dwPartyInfo || lpPlayInfo->lpPartyMaster!=rsPlayInfo[cnt].lpPartyMaster ) {
					lpPlayInfo2 = &rsPlayInfo[cnt];

					x = ( lpPlayInfo2->Position.x - lpPlayInfo->Position.x )>>FLOATNS;
					z = ( lpPlayInfo2->Position.z - lpPlayInfo->Position.z )>>FLOATNS;
					dist = x*x+z*z;

					if ( dist<ddist && abs(x)<TRANS_VIEW_LIMIT && abs(z)<TRANS_VIEW_LIMIT ) {
						//말풍선 글씨 보내기
						lpPlayInfo2->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
					}
				//}
			}
		}
		lpPlayInfo->szChatMessage[0] = 0;
	}
	else
		sLen = 0;

	//if ( lpPlayInfo->HideMode ) return TRUE;		//투명 모드 ( 캐릭터 정보 전송 금지 )

	if ( (lpPlayInfo->dwLastMotionRecvTime+10000)<dwPlayServTime ) return FALSE;		//받은 데이타 시간 초과시 처리 안함 ( 10초 시한 )

	TransOver = lpPlayInfo->LastTransPlayUserCount+CONNECTMAX;


	for( cnt=lpPlayInfo->LastTransPlayUserCount;cnt<TransOver;cnt++) {
		ClipCnt = cnt&CONNECTMAX_MASK;

		if ( rsPlayInfo[ClipCnt].lpsmSock && &rsPlayInfo[ClipCnt]!=lpPlayInfo && rsPlayInfo[ClipCnt].TransInfoFlag &&
			rsPlayInfo[ClipCnt].srRecvPlayBuffCnt>0 && !rsPlayInfo[ClipCnt].HideMode &&
			(!SoloMode || rsPlayInfo[ClipCnt].AdminMode>=3 ) ) {
	
			lpPlayInfo2 = &rsPlayInfo[ClipCnt];
			dwRecvFrame = lpPlayInfo2->srRecvPlayBuffCnt;
			dwSendFrame = lpPlayInfo->dwSendFrames[ClipCnt];

			x = ( lpPlayInfo2->Position.x - lpPlayInfo->Position.x )>>FLOATNS;
			z = ( lpPlayInfo2->Position.z - lpPlayInfo->Position.z )>>FLOATNS;
			dist = x*x+z*z;

			if ( dist<rsConnectViewDist && abs(x)<TRANS_VIEW_LIMIT && abs(z)<TRANS_VIEW_LIMIT ) {
				if (lpPlayInfo2->PlayBuffSleep && dwSendFrame>=dwRecvFrame ) {
					//슬립 모드에서는 8번 건너 슬립 데이타 전송
					if ( dist<DIST_TRANSLEVEL_HIGH ) {
						sbCnt = srPLAYBUFF_MAX;
					}
					else {
						sbCnt = -1;
					}
				}
				else {
					if ( !dwSendFrame || dwSendFrame>=dwRecvFrame ) {
						sbCnt = -1;
						lpPlayInfo->dwSendFrames[ClipCnt] = dwRecvFrame;
					}
					else {
						if ( (dwRecvFrame-dwSendFrame)>srPLAYBUFF_MASK )
							dwSendFrame = dwRecvFrame-srPLAYBUFF_MASK;

						sbCnt = dwSendFrame&srPLAYBUFF_MASK;
						dwSendFrame++;
						lpPlayInfo->dwSendFrames[ClipCnt] = dwSendFrame;
					}
				}


				if ( sbCnt>=0  ) {
					size = ((smTRANS_PLAYDATA *)lpPlayInfo2->srPlayBuff[sbCnt])->size;

					//버퍼가 찾을 경우 클라이언트로 전송
					if ( (lpTransBuff-TransBuff+size)>=TRANS_BUFF_SIZE ) {
						lpPlayDataGroup->size = (lpTransBuff-TransBuff);
						lpPlayDataGroup->PlayDataCnt = PlayDataCnt;
						lpPlayInfo->lpsmSock->Send( (char *)lpPlayDataGroup , lpPlayDataGroup->size , TRUE );

						PlayDataCnt = 0;
						lpTransBuff = TransBuff+sizeof(smPLAYDATA_GROUP);
						SndFlag++;
						break;
					}

					if ( lpPlayInfo->BefUserPacketLoop>TRANS_MAX_USER_LIMIT_OVER && 
						dist>DIST_TRANSLEVEL_NEAR && sbCnt!=srPLAYBUFF_MAX ) {
						//인원 과대 초과 경우 ( 아주 바로 앞에 있는 캐릭만 정확 데이타 보냄 )
						dist = DIST_TRANSLEVEL_HIGH;
					}

					if ( dist<DIST_TRANSLEVEL_HIGH ) {
						//근거리 정확한 데이타 필요
						memcpy( lpTransBuff , lpPlayInfo2->srPlayBuff[sbCnt] , size );
						lpTransBuff += size;

						if ( sbCnt==srPLAYBUFF_MAX )
							TransDataCount+=2;
						else
							TransDataCount+=4;

						PlayDataCnt++;
						if ( TransDataCount>=TRANS_MAX_USER_LIMIT ) break;
					}
					else {
						//거리가 멀음
						lpPlayData = (smPLAYDATA *)lpTransBuff;

						lpPlayData->size = sizeof( smPLAYDATA );
						lpPlayData->code = smTRANSCODE_PLAYDATA1;
						lpPlayData->x = lpPlayInfo2->Position.x;
						lpPlayData->y = lpPlayInfo2->Position.y;
						lpPlayData->z = lpPlayInfo2->Position.z;

						lpPlayData->angle[0] = 0;
						lpPlayData->angle[1] = 0;
						lpPlayData->angle[2] = 0;
						lpPlayData->angle[3] = 0;
						lpPlayData->frame = 0;
						lpPlayData->dwObjectSerial = lpPlayInfo2->dwObjectSerial;
						lpPlayData->dwAutoCharCode = 0;

						lpTransBuff +=sizeof( smPLAYDATA );

						TransDataCount++;
						PlayDataCnt++;
						if ( TransDataCount>=TRANS_MAX_USER_LIMIT ) break;
					}
				}
			}
		}

		if ( cnt==CONNECTMAX ) {
			//전송 수치 통계 계산 반영
			lpPlayInfo->BefUserPacketLoop = lpPlayInfo->UserPacketLoop;
			lpPlayInfo->UserPacketLoop = 0;
		}
	}

	//클라이언트로 남은 데이타 전송
	if ( SndFlag==0 && ( PlayDataCnt || (lpPlayInfo->SendPlayGroupCount&3)==0 ) ) {
		lpPlayDataGroup->size = (lpTransBuff-TransBuff);
		lpPlayDataGroup->PlayDataCnt = PlayDataCnt;
		lpPlayInfo->lpsmSock->Send( (char *)lpPlayDataGroup , lpPlayDataGroup->size , TRUE );
	}

	ClipCnt = cnt&CONNECTMAX_MASK;
	lpPlayInfo->LastTransPlayUserCount = ClipCnt;
	lpPlayInfo->SendPlayGroupCount++;
	lpPlayInfo->UserPacketLoop += TransDataCount;

	return TRUE;
}

/*
//몬스터/NPC 데이타 보내주기
int srTransAutoPlayData( rsPLAYINFO *lpPlayInfo )
{

	if ( lpPlayInfo->lpsmSock && rsAutoPlayTransCount>lpPlayInfo->MonTranCount ) {
		srTransPlayData( lpPlayInfo );
		lpPlayInfo->MonTranCount = rsAutoPlayTransCount;
	}

	return TRUE;
}

//캐릭터 데이타 보내주기
int srTransCharPlayData( rsPLAYINFO *lpPlayInfo )
{
	if ( lpPlayInfo->lpsmSock )
		srTransPlayUserData( lpPlayInfo );

	return TRUE;
}
*/

DWORD srAutoTransCounter = 0;

//자동 캐릭터 플레이
int srAutoTransPlay()
{
	int cnt;
	//int step;
	int start;
	DWORD	dwWaitTime;
	smTRANS_COMMAND	smTransCommand;
	char	szTempBuff[128];

//	rsPlayInfo[cnt].MonTransReady = TRUE;
//	rsPlayInfo[cnt].CharTransReady = TRUE;


/*
	start = srAutoTransCounter & 0xFF;
	for(cnt=start;cnt<CONNECTMAX;cnt+=0x100 ) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial && rsPlayInfo[cnt].AdminMode &&
			(dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)>OVER_TRANS_TIME ) {

			//네트웤 이상 상태 로그 전송
			rsSendNetLog( &rsPlayInfo[cnt] );

		}
	}
*/

	if ( AutoPlayServer ) {
		start = srAutoTransCounter & 0x3F;

		for(cnt=start;cnt<CONNECTMAX;cnt+=0x40 ) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial &&//) {
				(dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)<OVER_TRANS_TIME ) {
//				((dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)<OVER_TRANS_TIME || rsPlayInfo[cnt].PlayBuffSleep )) {
				//자동 버퍼링 전송
				srTransPlayData( &rsPlayInfo[cnt] );
				//군서버로 경험치 정보 보냄
				rsSendGameServerExp( &rsPlayInfo[cnt] );
			}
		}
	}


	if ( UserPlayServer ) {
		start = srAutoTransCounter & 0x1F;

		for(cnt=start;cnt<CONNECTMAX;cnt+=0x20 ) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial && 
				((dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)<OVER_TRANS_TIME || rsPlayInfo[cnt].PlayBuffSleep ) ) {
				//자동 버퍼링 전송 ( 다른 플레이어들의 데이타 )
				srTransPlayUserData( &rsPlayInfo[cnt] );
			}
		}

		if ( start==0x3F ) {
			//보내기 카운터 하나 증가
			for(cnt=0;cnt<CONNECTMAX;cnt++ ) {
				if ( rsPlayInfo[cnt].lpsmSock ) {
					if ( rsPlayInfo[cnt].PlayBuffSleep!=0 ) {
						rsPlayInfo[cnt].PlayBuffSleep++;
					}
					/*
					else {
						step = rsPlayInfo[cnt].srRecvPlayBuffCnt-rsPlayInfo[cnt].srSendPlayBuffCnt;
						if ( step>1 )	//보내기 버퍼링 증가
							rsPlayInfo[cnt].srSendPlayBuffCnt++;

						if ( step>2 ) //보내기 받기 버퍼링 차이가 2단계 초과시 강제 조절
							rsPlayInfo[cnt].srSendPlayBuffCnt = rsPlayInfo[cnt].srRecvPlayBuffCnt-1;
					}
					*/
				}
			}
		}
	}

/*
		cnt = lpPlayInfo->dwExpGameTime/1000;
		len = cnt%(60*60);
		wsprintf( TransChatMessage.szMessage , "> ExpGameTime Exp( %d ) ExpTime( %d:%d:%d )" , 
			rsGetExp_GameTime(lpPlayInfo) , cnt/(60*60) , len/60 , cnt%60 );

int rsGetExp_GameTime( rsPLAYINFO *lpPlayInfo )
{

	int gTime = lpPlayInfo->dwExpGameTime/(1000*60*60);

	if ( lpPlayInfo->dwExpGameTimeCheck ) {
		if ( gTime<3 ) return 100;
		else if ( gTime<5 ) return 50;
	}

	return 0;
}
*/

	//네트웍 ( 5분 이상 수신 없는 유저 연결 끈어버림 )
	for(cnt=(srAutoTransCounter&0x1FF);cnt<CONNECTMAX;cnt+=0x200 ) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwLastRecvTime ) {

			// 경험치 시간분배 (베트남) //해외
			if ( rsServerConfig.ExpGameTimeMode && rsPlayInfo[cnt].dwExpGameTimeCheck && 
				rsPlayInfo[cnt].Position.Area<STAGE_AREA_MAX && StageArea[rsPlayInfo[cnt].Position.Area].lpField )
			{

				int gTimeChk = rsPlayInfo[cnt].dwExpGameTime/(1000*60);
				int gTimeOld = rsPlayInfo[cnt].dwExpGameTime;
//해외
//				if ( StageArea[rsPlayInfo[cnt].Position.Area].lpField->State!=FIELD_STATE_VILLAGE ) 
					rsPlayInfo[cnt].dwExpGameTime += (dwPlayServTime - rsPlayInfo[cnt].dwExpGameTimeCheck);

				if ( rsServerConfig.ExpGameTimeMode==3 ) {
					rsDispay_GameTime( &rsPlayInfo[cnt] , gTimeOld ); 
				}


				////////////////// 베트남 추가 2 /////////////////////////
				if ( rsServerConfig.ExpGameTimeMode==2 ) {			//경험치 시간 타임 종료 모드
					int gTime = rsPlayInfo[cnt].dwExpGameTime/(1000*60);
					if ( gTime>(5*60-5) && gTimeChk!=gTime ) {			//5시간이 됐다~

						TRANS_CHATMESSAGE	TransChatMessage;
						wsprintf( TransChatMessage.szMessage , srMsg_Bl_01 , (5*60)-gTime ); 
						TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
						TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
						TransChatMessage.dwIP = 3;
						TransChatMessage.dwObjectSerial = 0;
						rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

						if ( gTime>=5*60 ) {
							rsSendCloseClient( &rsPlayInfo[cnt] );			//시간 초과 종료
						}
					}
				}
				//////////////////////////////////////////////////////////

				rsPlayInfo[cnt].dwExpGameTimeCheck = dwPlayServTime;
			}

			//이벤트 시간이 완료 되면 설정 복귀 ( 코믹 얼굴 )
			if ( rsPlayInfo[cnt].smCharInfo.dwEventTime_T && (rsPlayInfo[cnt].smCharInfo.dwEventTime_T+60)<(DWORD)tServerTime ) {
				rsPlayInfo[cnt].smCharInfo.dwEventTime_T = 0;
				rsPlayInfo[cnt].smCharInfo.SizeLevel = 1;
			}

			//처음시작 유저 아이템 지급
			if ( rsPlayInfo[cnt].dwStartUser_PresentItem_Time && rsPlayInfo[cnt].dwStartUser_PresentItem_Time<dwPlayServTime ) {
				rsStartUser_PresentItem( &rsPlayInfo[cnt] );
			}

			if ( UserPlayServer && (rsPlayInfo[cnt].dwMacroChkTime+60000)>dwPlayServTime ) {
				if ( rsPlayInfo[cnt].Position.Area<STAGE_AREA_MAX && StageArea[rsPlayInfo[cnt].Position.Area].lpField &&
					StageArea[rsPlayInfo[cnt].Position.Area].lpField->State==FIELD_STATE_VILLAGE ) {
						//마을에 서있는 경우
						rsPlayInfo[cnt].dwMacroAngTime = 0;
						rsPlayInfo[cnt].dwMacroTime = 0;
					}

				//오토마우스 / 매크로 감지 및 신고
				if ( rsPlayInfo[cnt].dwMacroAngTime && rsPlayInfo[cnt].dwMacroAngTime+(60000*2)<dwPlayServTime ) {
					//2분동안 방향 변경이 없었음.. 
					rsPlayInfo[cnt].dwMacroAngTime = 0;
					rsPlayInfo[cnt].dwMacroTime = 0;
				}
				if ( rsPlayInfo[cnt].dwMacroTime && rsPlayInfo[cnt].dwMacroTime+(60000*60)<dwPlayServTime ) {
					//60분 동안 제자리
					smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
					smTransCommand.size = sizeof( smTRANS_COMMAND );
					smTransCommand.WParam = 8102;
					smTransCommand.LParam = (dwPlayServTime-rsPlayInfo[cnt].dwMacroTime)/60000;
					smTransCommand.SParam = rsPlayInfo[cnt].Position.Area;
					smTransCommand.EParam = rsServerConfig.ServerCode;
					rsSendDataServer( rsPlayInfo[cnt].lpsmSock , &smTransCommand );

					rsPlayInfo[cnt].dwMacroAngTime = 0;
					rsPlayInfo[cnt].dwMacroTime = 0;
				}
			}

			dwWaitTime = rsPlayInfo[cnt].dwLastRecvTime+(1000*60*6);

			if ( dwWaitTime<dwPlayServTime || 
				( rsPlayInfo[cnt].dwHopeDisconnectTime && rsPlayInfo[cnt].dwHopeDisconnectTime<dwPlayServTime ) ) {

				if ( rsPlayInfo[cnt].lpsmSock ) {
					wsprintf( szTempBuff , "ID( %s ) Name( %s ) IP( %s ) TimeOut Message\r\n" , 
						rsPlayInfo[cnt].szID , rsPlayInfo[cnt].szName , rsPlayInfo[cnt].lpsmSock->szIPAddr );
					Record_TempLogFile( szTempBuff );
				}

				DisconnectUser( rsPlayInfo[cnt].lpsmSock );
			}

#ifdef _npGAME_GUARD_AUTH
				smTRANS_COMMAND_DWORD	smTrnasCommandDword;
				if ( rsPlayInfo[cnt].lpsmSock && rsServerConfig.GameGuard_Auth && rsPlayInfo[cnt].szID[0] && rsPlayInfo[cnt].npGameGuard.Auth_Time<dwPlayServTime ) {
					if ( rsPlayInfo[cnt].npGameGuard.Auth_Retry==0 ) {
						if (!rsPlayInfo[cnt].csa.IsAuth()) {
							//접속 해제

							smTransCommand.WParam = 8710;
							smTransCommand.LParam = rsPlayInfo[cnt].npGameGuard.Auth_Value;
							smTransCommand.SParam = rsPlayInfo[cnt].npGameGuard.Auth_Count;
							RecordHackLogFile( &rsPlayInfo[cnt] , &smTransCommand );

							rsPlayInfo[cnt].dwHopeDisconnectTime = dwPlayServTime+10*1000;
						}
						else {
							smTrnasCommandDword.code = smTRANSCODE_GAMEGUARD_AUTH;
							smTrnasCommandDword.size = sizeof( smTRANS_COMMAND_DWORD );
							smTrnasCommandDword.WParam = rsPlayInfo[cnt].csa.GetAuthDword();
							smTrnasCommandDword.LParam = 0;
							smTrnasCommandDword.SParam = 0;
							smTrnasCommandDword.EParam = 0;
							rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTrnasCommandDword , smTrnasCommandDword.size , TRUE );
							rsPlayInfo[cnt].npGameGuard.Auth_Retry = 4;
							rsPlayInfo[cnt].npGameGuard.Auth_Value = smTrnasCommandDword.WParam;
							rsPlayInfo[cnt].npGameGuard.Auth_Count ++;
						}
					}
					else {
						smTrnasCommandDword.code = smTRANSCODE_GAMEGUARD_AUTH;
						smTrnasCommandDword.size = sizeof( smTRANS_COMMAND_DWORD );
						smTrnasCommandDword.WParam = rsPlayInfo[cnt].npGameGuard.Auth_Value;
						smTrnasCommandDword.LParam = 0;
						smTrnasCommandDword.SParam = 0;
						smTrnasCommandDword.EParam = 0;
						rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTrnasCommandDword , smTrnasCommandDword.size , TRUE );

						rsPlayInfo[cnt].npGameGuard.Auth_Retry--;
					}

					rsPlayInfo[cnt].npGameGuard.Auth_Time = dwPlayServTime+40*1000;
				}
#endif

#ifdef _xTrap_GUARD_SERVER
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] && rsPlayInfo[cnt].smXTrapInfo.dwKeyGenTime<dwPlayServTime )
				{
					rsXTrap_Login( &rsPlayInfo[cnt] );
				}
#endif

#ifdef _XTRAP_GUARD_4_SERVER
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] && rsPlayInfo[cnt].XTrapCS_Session_Buf.dwTime<dwPlayServTime )
				{
					rsXTrap_SeedKey( &rsPlayInfo[cnt] );
				}
#endif

			//클라이언트 펑션 포지션 검사시 10회 이상 실패면 연결 종료 ( 60,80 회마다 초기화 )
			if ( rsServerConfig.ClientFuncCheckMode ) {
				if ( rsPlayInfo[cnt].dwClientFunChk_NextTime<dwPlayServTime ) {
					rsCheckClientFuncMem( &rsPlayInfo[cnt] );
					rsPlayInfo[cnt].dwClientFunChk_NextTime = dwPlayServTime+60*1000;

					if ( !rsPlayInfo[cnt].dwFuncChkErrorFlag ) {
						if ( rsPlayInfo[cnt].FuncChkFailCount1>10 || rsPlayInfo[cnt].FuncChkFailCount2>10 ) {

							if ( rsPlayInfo[cnt].lpsmSock ) {
								wsprintf( szTempBuff , "ID( %s ) Name( %s ) IP( %s ) Func Check Out Message\r\n" , 
									rsPlayInfo[cnt].szID , rsPlayInfo[cnt].szName , rsPlayInfo[cnt].lpsmSock->szIPAddr );
								Record_TempLogFile( szTempBuff );
							}

							DisconnectUser( rsPlayInfo[cnt].lpsmSock );
						}
						else {
							if ( rsPlayInfo[cnt].ClientFunChk1_Count>60 ) {
								rsPlayInfo[cnt].ClientFunChk1_Count = 0;
								rsPlayInfo[cnt].FuncChkFailCount1 = 0;
								rsPlayInfo[cnt].FuncChkSucessCount1 = 0;
							}
							if ( rsPlayInfo[cnt].ClientFunChk2_Count>80 ) {
								rsPlayInfo[cnt].ClientFunChk2_Count = 0;
								rsPlayInfo[cnt].FuncChkFailCount2 = 0;
								rsPlayInfo[cnt].FuncChkSucessCount2 = 0;
							}

							if ( (rsPlayInfo[cnt].ClientFunChk1_Count>10 && rsPlayInfo[cnt].FuncChkSucessCount1<(rsPlayInfo[cnt].ClientFunChk1_Count>>1) ) ||
								(rsPlayInfo[cnt].ClientFunChk2_Count>10 && rsPlayInfo[cnt].FuncChkSucessCount2<(rsPlayInfo[cnt].ClientFunChk2_Count>>1) )) {

									smTransCommand.WParam = 1132;
									if ( rsPlayInfo[cnt].ClientFunChk1_Count )
										smTransCommand.LParam = (rsPlayInfo[cnt].FuncChkSucessCount1*100)/rsPlayInfo[cnt].ClientFunChk1_Count;
									else
										smTransCommand.LParam = 0;

									if ( rsPlayInfo[cnt].ClientFunChk2_Count ) 
										smTransCommand.SParam = (rsPlayInfo[cnt].FuncChkSucessCount2*100)/rsPlayInfo[cnt].ClientFunChk2_Count;
									else
										smTransCommand.SParam = 0;

									RecordHackLogFile( &rsPlayInfo[cnt] , &smTransCommand );

									DisconnectUser( rsPlayInfo[cnt].lpsmSock );
							}

						}
					}
				}
			}

		}

		if ( smWSock[cnt].sock && smWSock[cnt].dwLastRecvTime && 
			(smWSock[cnt].dwLastRecvTime+1000*60*8)<dwPlayServTime ) {

			wsprintf( szTempBuff , "Socket IP( %s ) TimeOut Message\r\n" , smWSock[cnt].szIPAddr );
			Record_TempLogFile( szTempBuff );

			DisconnectUser( &smWSock[cnt] );
		}

	}

	if ( UserPlayServer || AutoPlayServer ) {
		//주서버
		start = srAutoTransCounter & 0x3F;
		for(cnt=start;cnt<CONNECTMAX;cnt+=0x40 ) {
			if ( rsPlayInfo[cnt].lpsmSock && (dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)>4000 ) {
				if ( rsPlayInfo[cnt].dwObjectSerial || 
					( rsPlayInfo[cnt].SystemLine && (dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)>10000 ) ) {

						if ( rsPlayInfo[cnt].lpsmSock->WaitReadMessage==0 ) {
							rsPlayInfo[cnt].lpsmSock->WaitReadMessage = 24;
						}
					}
			}
		}
	}
	else {
		//데이타 저장 서버
		start = srAutoTransCounter & 0x3F;
		for(cnt=start;cnt<CONNECTMAX;cnt+=0x40 ) {
			if ( rsPlayInfo[cnt].lpsmSock && (dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)>9000 ) {
				if ( rsPlayInfo[cnt].szName[0] || 
					( rsPlayInfo[cnt].SystemLine && (dwPlayServTime-rsPlayInfo[cnt].dwLastRecvTime)>10000 ) ) {

						if ( rsPlayInfo[cnt].lpsmSock->WaitReadMessage==0 ) {
							rsPlayInfo[cnt].lpsmSock->WaitReadMessage = 24;
						}
					}
			}
		}
	}

	srAutoTransCounter++;
	return TRUE;
}

static int srBillingCounter = 0;

static DWORD dwBillingTime = 0;

#ifdef _LANGUAGE_PHILIPIN
char	*srMsg_Bl_100p	= "%sYou can play until %d:%d - %d/%d/%d %s Pay2Play is Ongoing,Top up Now.";
char	*srMsg_Bl_1001p	= "%sYou can play until %d:0%d - %d/%d/%d %s Pay2Play is Ongoing,Top up Now.";
#endif

//빌링 남은 시간 표시
int srDisplayBillingTime( rsPLAYINFO *lpPlayInfo , int Add_BillingTime )
{
	//tServerTime

	struct tm *today;
	//struct tm *nextDay;
	int y,m,d,h,hm,hs;
	TRANS_CHATMESSAGE	TransChatMessage;
	int Time;
	char	*lpBuff;
	char	szBuff[128];


	if ( (lpPlayInfo->Bl_Meter&BIMASK_PRORATE_USER)!=0 ) return FALSE;		//종량제 표시 안함
	if ( (lpPlayInfo->Bl_Meter&BIMASK_FREE_USER)!=0 ) return FALSE;			//무료사용자 표시 안함

	if ( lpPlayInfo->Bl_RNo>0 ) 
		lpBuff = srMsg_Bl_02;
	else
		lpBuff = "";

	szBuff[0] = 0;

	if ( lpPlayInfo->DisuseDay ) {
		//정액제
/*
		if ( Add_BillingTime ) {
			nextDay = localtime( (time_t *)&Add_BillingTime );
			if ( nextDay ) {
				y = nextDay->tm_year + 1900;
				m = nextDay->tm_mon +1;
				d = nextDay->tm_mday;
				h = nextDay->tm_hour;
				hm = nextDay->tm_min;
				hs = nextDay->tm_sec;

				wsprintf( szBuff , srMsg_BI_03 , y,m,d );
			}
		}
*/
		today = localtime( &lpPlayInfo->DisuseDay );

		///////////////////// (출력변경 -> 시간 합산 ) ////////////////
		if ( Add_BillingTime ) {
			today = localtime( (time_t *)&Add_BillingTime );
		}
		///////////////////////////////////////////////////////////////

		if ( today ) {
			y = today->tm_year + 1900;
			m = today->tm_mon +1;
			d = today->tm_mday;
			h = today->tm_hour;
			hm = today->tm_min;
			hs = today->tm_sec;

#ifdef	_LANGUAGE_TAIWAN		//0x57
			wsprintf( TransChatMessage.szMessage ,srMsg_Bl_100, lpBuff,y,m, d , h , hm, szBuff );
#endif

#ifdef _LANGUAGE_THAI
			wsprintf( TransChatMessage.szMessage ,srMsg_Bl_100, lpBuff,d,m, y , h , hm, szBuff );
#endif

#ifdef _LANGUAGE_ENGLISH
#ifdef _LANGUAGE_PHILIPIN
			if(hm!=0)	wsprintf( TransChatMessage.szMessage ,srMsg_Bl_100p, lpBuff,h,hm,m,d,y, szBuff );
			else		wsprintf( TransChatMessage.szMessage ,srMsg_Bl_1001p, lpBuff,h,hm,m,d,y, szBuff );
#else
			if(hm!=0)	wsprintf( TransChatMessage.szMessage ,srMsg_Bl_100, lpBuff,h,hm,m,d,y, szBuff );
			else		wsprintf( TransChatMessage.szMessage ,srMsg_Bl_1001, lpBuff,h,hm,m,d,y, szBuff );
#endif
#endif

//중국
#ifdef _LANGUAGE_CHINESE													   //(년,월,일,시,분)
			if(hm!=0)	wsprintf( TransChatMessage.szMessage ,srMsg_Bl_100, lpBuff,y,m,d,h,hm, szBuff );
			else		wsprintf( TransChatMessage.szMessage ,srMsg_Bl_1001, lpBuff,y,m,d,h,hm, szBuff );
#endif
#ifdef _LANGUAGE_VEITNAM
			if(hm!=0)	wsprintf( TransChatMessage.szMessage ,srMsg_Bl_100, lpBuff,h,hm,m,d,y, szBuff );
			else		wsprintf( TransChatMessage.szMessage ,srMsg_Bl_1001, lpBuff,h,hm,m,d,y, szBuff );			
#endif

#ifdef _LANGUAGE_BRAZIL
			if(hm!=0)	wsprintf( TransChatMessage.szMessage ,srMsg_Bl_100, lpBuff,h,hm,m,d,y, szBuff );
			else		wsprintf( TransChatMessage.szMessage ,srMsg_Bl_1001, lpBuff,h,hm,m,d,y, szBuff );
#endif
#ifdef	_LANGUAGE_JAPANESE 
			wsprintf( TransChatMessage.szMessage ,srMsg_Bl_100, lpBuff,y,m, d , szBuff );
#endif

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 3;
			TransChatMessage.dwObjectSerial = 0;
			if ( lpPlayInfo->lpsmSock ) 
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
	}


	if ( lpPlayInfo->dwPeriodTime ) {
		//정량제
		if ( Add_BillingTime ) {
			wsprintf( szBuff , srMsg_BI_04 , Add_BillingTime/(60*60));
		}

		if ( lpPlayInfo->dwPeriodTime>(DWORD)tServerTime )
			Time = (lpPlayInfo->dwPeriodTime - (DWORD)tServerTime)/60;
		else
			Time = 0;

		if ( Time<0 ) Time = 0;

		///////////////////// (출력변경 -> 시간 합산 ) ////////////////
		Time += Add_BillingTime/60;
		szBuff[0] = 0;
		///////////////////////////////////////////////////////////////

		h = Time/60;
		m = Time%60;

		if ( h>0 ) {
			wsprintf( TransChatMessage.szMessage ,srMsg_Bl_101, lpBuff,h , m , szBuff );
		}
		else {
			wsprintf( TransChatMessage.szMessage ,srMsg_Bl_102, lpBuff,m ,szBuff );
		}

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 3;
		TransChatMessage.dwObjectSerial = 0;
		if ( lpPlayInfo->lpsmSock ) 
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}


	return TRUE;
}

//빌링 처리 함수
int  srBillingMain()
{
	int cnt;
	int Time;
	int HiddenPeriod;

	srBillingCounter++;


	if ( (srBillingCounter&0xF)==0 ) {

		cnt = (srBillingCounter>>4)&CONNECTMAX_MASK;

		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] && rsPlayInfo[cnt].szName[0] && 
			rsPlayInfo[cnt].dwObjectSerial ) {
				if ( rsPlayInfo[cnt].Bl_RNo ) {
					if ( rsPlayInfo[cnt].Bl_RNo>0 || ((srBillingCounter>>4)&CONNECTMAX)==0 ) {
						bSql_PCUse( &rsPlayInfo[cnt] );
					}
				}
				if ( UseDLL_Expined ) {
					bUrs_Expined( &rsPlayInfo[cnt] );		//빌링 주기적 검사 ( 타이완 버전 )
				}
		}
	}

	if ( (srBillingCounter&0xFFF)!=0 ) {
		return FALSE;
	}

	if ( dwBillingTime>=dwPlayServTime ) 
		return FALSE;

	dwBillingTime = dwPlayServTime;

	smTRANS_COMMAND	smTransCommand;
	TRANS_CHATMESSAGE	TransChatMessage;


	smTransCommand.code = smTRANSCODE_CLOSECLIENT;
	smTransCommand.size = sizeof( smTRANS_COMMAND );


	for(cnt=0;cnt<CONNECTMAX;cnt++) {

		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] && rsPlayInfo[cnt].szName[0] && rsPlayInfo[cnt].dwObjectSerial ) {

			if ( rsPlayInfo[cnt].dwPeriodTime2 ) {
				//숨겨진 빌링
				Time = rsPlayInfo[cnt].dwPeriodTime2 - tServerTime;
				if ( Time<6*60 && Time>0 ) {
					if ( rsPlayInfo[cnt].dwPeriodTime!=rsPlayInfo[cnt].dwPeriodTime2 ) {
						rsPlayInfo[cnt].dwPeriodTime = rsPlayInfo[cnt].dwPeriodTime2;
					}
					HiddenPeriod = TRUE;
				}
				else
					HiddenPeriod = FALSE;

			}
			else {
				HiddenPeriod = FALSE;
			}

			if ( rsPlayInfo[cnt].DisuseDay && HiddenPeriod==FALSE ) {
				//정액
				Time = rsPlayInfo[cnt].DisuseDay - tServerTime;


				if ( Time<6*60 && Time>0 ) {
					if ( Time<5*60 ) {
						wsprintf( TransChatMessage.szMessage , srMsg_Bl_01 , Time/60 ); 
						TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
						TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
						TransChatMessage.dwIP = 3;
						TransChatMessage.dwObjectSerial = 0;
						if ( rsServerConfig.DispBillingTime ) rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
					}
					bSql_PCSearchReserv( &rsPlayInfo[cnt] );			//빌링 연장확인 
				}

				if ( rsPlayInfo[cnt].DisuseDay<tServerTime ) {
					rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
					//빌링 접속 종료 기록 파일로 남김
					Record_BillingLogFile( &rsPlayInfo[cnt] , rsPlayInfo[cnt].DisuseDay , rsPlayInfo[cnt].dwPeriodTime , tServerTime , rsPlayInfo[cnt].Bl_RNo );
				}
			}

			if  ( rsPlayInfo[cnt].dwPeriodTime ) {
				//정량
				Time = rsPlayInfo[cnt].dwPeriodTime - tServerTime;

				if ( Time<6*60 && Time>0 ) {
					if ( Time<5*60 ) {
						//5분전 부터 종료 예고 메세지 보내기
						wsprintf( TransChatMessage.szMessage , srMsg_Bl_01 , Time/60 ); 
						TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
						TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
						TransChatMessage.dwIP = 3;
						TransChatMessage.dwObjectSerial = 0;
						if ( rsServerConfig.DispBillingTime )  rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
					}
					bSql_PCSearchReserv( &rsPlayInfo[cnt] );			//빌링 연장 확인
				}

				if ( Time<=0 ) {
					rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
					if ( !HiddenPeriod ) {
						//빌링 접속 종료 기록 파일로 남김
						Record_BillingLogFile( &rsPlayInfo[cnt] , rsPlayInfo[cnt].DisuseDay , rsPlayInfo[cnt].dwPeriodTime , tServerTime , rsPlayInfo[cnt].Bl_RNo );
					}
				}
			}
/*
			if ( rsPlayInfo[cnt].Bl_RNo ) {
				//bSql_PCUse( rsPlayInfo[cnt].szID, rsPlayInfo[cnt].szGPCode , 0 , rsPlayInfo[cnt].lpsmSock->szIPAddr, rsPlayInfo[cnt].Bl_RNo );
				bSql_PCUse( &rsPlayInfo[cnt] );
			}
*/
		}
	}

	return TRUE;
}





static DWORD FrameSkipTimer = 0;
static DWORD fps	= 70;
static DWORD FpsTime;


//플레이 메인 루프
int srPlayMain()
{
	int cnt;

	cnt = 0;

	if ( FrameSkipTimer==0 ) { 
		FrameSkipTimer = GetCurrentTime();
		FpsTime = 1000/fps;
	}

	//크리티칼 섹션 선언
	EnterCriticalSection( &cSerSection );

	while(1) {
		if ( FrameSkipTimer>GetCurrentTime() ) break;
		if ( Quit ) break;
		if ( cnt>70*2 ) {
			FrameSkipTimer = GetCurrentTime();
			break;
		}

		FrameSkipTimer += FpsTime;
		if ( AutoPlayServer ) srAutoPlayMain();
		srAutoTransPlay();
		if ( LoginServer ) srBillingMain();		//빌링 처리 함수

		cnt++;
	}

	//크리티칼 섹션 해제
	LeaveCriticalSection( &cSerSection );

	return cnt;
}


//초기화
int InitAll()
{
	int cnt;

	DWORD nsize = 32;
	char szServerName[32];

	ChatBuffCnt = 0;

	//테스트 서버 설정
	GetComputerName( szServerName , &nsize );
	if ( lstrcmpi( szServerName , szDebugServer )==0 ) 
		DebugServerMode=TRUE;

	ServerNameCode = GetSpeedSum(szServerName);			//서버 이름 코드 구하기\

	//공지사항 메세지 초기화
	rsNoticeMessage.Counter = 0;
	rsNoticeMessage.szMessage[0] = 0;

	//서버관련 메모리 확보
	Server_AllocMemory();


//	ZeroMemory( AreaPlayUserInfo , sizeof( rsPLAYINFO *) * AREA_MAX * AREA_USERMAX );
/*
	for(cnt=0;cnt<AREA_MAX;cnt++) {
		ZeroMemory( AreaPlayUserInfo[cnt] , sizeof( rsPLAYINFO *) * AREA_USERMAX );
	}
*/

	if ( rsServerConfig.UseRecorMemory ) {
		rsRecordDataBuff = new char[(srRECORD_MEMORY_SIZE+256)*CONNECTMAX ];
		if ( !rsRecordDataBuff )
		    MessageBox( NULL, "Error Record Memory", "Alloc Failed - Hotuk Server", MB_OK);
	}
	else  {
		rsRecordDataBuff = 0;
	}

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		ZeroMemory( &rsPlayInfo[cnt] , sizeof(rsPLAYINFO) );
		if ( rsRecordDataBuff ) {
			rsPlayInfo[cnt].lpRecordDataBuff = rsRecordDataBuff+((srRECORD_MEMORY_SIZE+256)*cnt);
		}
	}

	//서버 재설정
	//rsRefreshConfig();

	//메트리얼 초기화
	InitMaterial();

	//캐릭터 초기화
	srInitChar();
	//몬스터 그룹 초기화
	InitMonster();
	//아이템 초기화
	InitItems();
	//NPC 미리 로딩
	LoadOftenNpc();

	//크랙 찾기 초기화
	InitCrackFinding();


	//몬스터는 높은곳도 2배로 잘 올라간다
	Stage_StepHeight = fONE*20;

	StageArea = new STG_AREA[STAGE_AREA_MAX];
	srReadStage();

	//국가별 몬스터 이름 확인 변환
	ConvertMonsterNames();


	//캐릭터 NPC/MONSTER 가 존재하면 메인서버로 동작 
	//( 그렇지 않을경우 캐릭터 동작 전송 보조 서버로 동작 )
	AutoPlayServer = rsServerConfig.AutoPlayer;


/*
	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag ) {
			AutoPlayServer = TRUE;
			break;
		}
	}
*/
	//타이머 인터럽트 가동 0.1초 간격
	SetTimer( hwnd , 0 , 100 , NULL );
	dwPlayServTime = GetCurrentTime();

	InitODBC();				//ODBC 연결 (인증)
	InitLogSql();			//DB LOG 초기화
	//rsInitDataBase();		//서버DB함수 초기화

	//클라이언트 펑션 포지션 리셋
	rsResetClientFuncPos();

	rsLoadCopiedItemList();			//복사 아이템 목록 불러 오기


	RecordShutdownLog( 50020 , 0 , 0 );		//서버 서비스 시작 로그

	rsInit_SerToServer();					//다른 서버와 연결 초기화

	ZeroMemory( &rsUserListDamageTop10 , sizeof(rsUSER_LIST_TOP10) );		//데미지준 유저목록 초기화

	OpenBossTimeMin = (rand()%45)+1;		//1~46분 중 하나선택

	rsInit_Castle();					//공성정보 초기화

	ZeroMemory( &CurrencyLog , sizeof(rsCURRENCY_LOG) );

	
	return TRUE;
}

//종료 모든 작업을 메모리에서 제거
void RemoveAll()
{
	int cnt;
	smTRANS_COMMAND smTransCommand;

	RecordShutdownLog( 50030 , 0 , 0 );		//서버 서비스 종료 로그

	//rsSaveCastleInfo();			//블래스 캐슬정보


	//메모리 버퍼를 파일로 저장
	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpRecordDataBuff ) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szName[0] ) {
				if ( rsRecordMemoryBuffToFile( &rsPlayInfo[cnt] , rsPlayInfo[cnt].szName ,  rsPlayInfo[cnt].lpRecordDataBuff )==TRUE ) {
					if ( lstrcmpi( rsPlayInfo[cnt].szName , ((TRANS_RECORD_DATA *)rsPlayInfo[cnt].lpRecordDataBuff)->smCharInfo.szName )!=0 ) {

						smTransCommand.WParam = 10002;
						smTransCommand.LParam = (DWORD)rsPlayInfo[cnt].szName;
						smTransCommand.SParam = (DWORD)((TRANS_RECORD_DATA *)rsPlayInfo[cnt].lpRecordDataBuff)->smCharInfo.szName;
						RecordHackLogFile( &rsPlayInfo[cnt] , &smTransCommand );

					}

					//버려진 아이템 메모리버퍼 데이타에 저장 
					rsSaveThrowData( &rsPlayInfo[cnt] );
					//저장할 메모리버퍼의 아이템이 올바른지 전부 확인
					rsRecordMemoryBuff_CheckInvenItem( &rsPlayInfo[cnt] , 1 );

				}
			}
		}
	}
	if ( rsRecordDataBuff )
		delete rsRecordDataBuff;

/*
	for(cnt=CONNECTMAX-1;cnt>=0;cnt--) {
		if ( rsPlayInfo[cnt].lpRecordDataBuff ) {
			delete rsPlayInfo[cnt].lpRecordDataBuff;
			rsPlayInfo[cnt].lpRecordDataBuff = 0;
		}
	}
*/

	rsCloseDataBase();			//서버DB함수 말기화
	CloseLogSql();				//DB LOG 해제
	CloseODBC();				//ODBC 해제 (인증)

	//크리티칼 섹션 선언
	EnterCriticalSection( &cSerSection );

	srRemoveChar();
	srRemoveStage();
	CloseMaterial();

	for(cnt=STAGE_AREA_MAX-1;cnt>=0;cnt--) 
		StageArea[cnt].Close();

	delete StageArea;

	//복사 아이템 목록 제거
	rsRemoveCopiedItemList();

	//서버관련 메모리 해제
	Server_RemoveMemory();

	//크리티칼 섹션 해제
	LeaveCriticalSection( &cSerSection );

}

DWORD dwConnIPCheckTime = 0;

//플레이어 데이타 베이스에 새 클라이언트 추가 
int AddNewPlayInfo( smWINSOCK *lpsmSock )
{
	int cnt,cnt2;
	DWORD	dwMyIP;
	int	SameIPCount=0;
	smTRANS_COMMAND	TransCommand;

	dwMyIP = lpsmSock->acc_sin.sin_addr.S_un.S_addr;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].lpsmSock->acc_sin.sin_addr.S_un.S_addr==dwMyIP ) {
			SameIPCount++;
		}
		else {
			if ( rsPlayInfo[cnt].lpsmSock==0 ) break;
		}
	}
	if ( cnt==CONNECTMAX ) return FALSE;

	//같은 IP에서 32개 이상 접속한 경우
	if ( SameIPCount>32 ) {
		//시스템 IP 확인
		if ( rsCheckSystemIP( dwMyIP )==FALSE ) {
			//과다 연결 IP
			DisconnectUser( lpsmSock );

			if ( abs(dwConnIPCheckTime-dwPlayServTime)>60*1000*3 ) {
				//동일 IP 과다연결 
				smTRANS_COMMAND smTransCommand;
				smTransCommand.WParam = 5000;
				smTransCommand.SParam = SameIPCount;
				smTransCommand.LParam = dwMyIP;
				RecordHackLogFile( 0 , &smTransCommand );
			}

			return FALSE;
		}
	}

	if ( ShutDownFlag ) {
		//서버 셧다운중 .. 신규 접속 불가
		if ( strstr( lpsmSock->szIPAddr , szAdminIP )==0 ) {
			DisconnectUser( lpsmSock );
			return FALSE;
		}
	}


	lpsmSock->ExtData1 = (void *)&rsPlayInfo[cnt];

#ifdef _npGAME_GUARD_AUTH
/*
	if ( rsServerConfig.GameGuard_Auth && (dwConnectCount&0x1F)==0 ) {
		SetAuthIndex( rand()%8 );
	}
*/
	rsPlayInfo[cnt].csa.Init();
	ZeroMemory( &rsPlayInfo[cnt].npGameGuard  , sizeof(npGAME_GUARD_AUTH_INFO) );
#endif

#ifdef _xTrap_GUARD
	ZeroMemory( &rsPlayInfo[cnt].smXTrapInfo  , sizeof(smXTRAP_PLAYINFO) );
#endif

#ifdef _XTRAP_GUARD_4_SERVER
	rsPlayInfo[cnt].XTrapCS_Session_Buf.Clear();
#endif

	rsPlayInfo[cnt].lpsmSock = lpsmSock;
	rsPlayInfo[cnt].ChatBuffCnt = ChatBuffCnt;
	rsPlayInfo[cnt].SendListCnt = 0;
	rsPlayInfo[cnt].Position.Area = 0xFFFFFFFF;
	rsPlayInfo[cnt].TransInfoFlag = FALSE;
	rsPlayInfo[cnt].SystemLine = 0;
	rsPlayInfo[cnt].CharLevelMax = 0;
	rsPlayInfo[cnt].AdminOperMode = 0;
	rsPlayInfo[cnt].dwDataError = 0;

	for(cnt2=0;cnt2<srPLAYBUFF_MAX+1;cnt2++)
		rsPlayInfo[cnt].srPlayBuffSize[cnt2]=0;
	rsPlayInfo[cnt].srSendPlayBuffCnt = 0;
	rsPlayInfo[cnt].srRecvPlayBuffCnt = 0;
	rsPlayInfo[cnt].dwObjectSerial = 0;
	rsPlayInfo[cnt].szChatMessage[0] = 0;
	rsPlayInfo[cnt].lpRecordBase = 0;
	rsPlayInfo[cnt].lpPostBoxItem = 0;
	rsPlayInfo[cnt].PostPassFailCount = 0;

	rsPlayInfo[cnt].AdminMode = 0;
	rsPlayInfo[cnt].HideMode = 0;
	rsPlayInfo[cnt].CharLoadingCount = 0;
	rsPlayInfo[cnt].dwNoticeCount = rsNoticeMessage.Counter;

	rsPlayInfo[cnt].LastTransPlayUserCount = 0;
	rsPlayInfo[cnt].LastTransAutoPlayCount = 0;

	rsPlayInfo[cnt].UnsaveMoney = -1;
	rsPlayInfo[cnt].ThrowItemCount = 0;
	rsPlayInfo[cnt].szName[0] = 0;
	rsPlayInfo[cnt].szID[0] = 0;
	rsPlayInfo[cnt].szServerID[0] = 0;

	rsPlayInfo[cnt].dwLastRecvTime = dwPlayServTime;
	rsPlayInfo[cnt].dwLastMotionRecvTime = dwPlayServTime;

	rsPlayInfo[cnt].dwConnectCount = dwConnectCount;

	rsPlayInfo[cnt].SendPlayGroupCount = 0;

	rsPlayInfo[cnt].MonTranCount = 0;
	rsPlayInfo[cnt].CharTransCount = 0;
	rsPlayInfo[cnt].HitMonsterCount = 0;
	rsPlayInfo[cnt].UserPacketLoop = 0;
	rsPlayInfo[cnt].BefUserPacketLoop = 0;

	rsPlayInfo[cnt].lpChrTarget = 0;
	rsPlayInfo[cnt].dwTarObjSerial = 0;
	rsPlayInfo[cnt].smCharInfo.szName[0] = 0;
	rsPlayInfo[cnt].smCharInfo.Level = 0;
	rsPlayInfo[cnt].CrackWarning = 0;
	rsPlayInfo[cnt].dwTime_Disconnect = 0;
	rsPlayInfo[cnt].EventMode = 0;
	rsPlayInfo[cnt].AreaOutCount = 0;

	//파티정보 초기화
	rsPlayInfo[cnt].dwPartyInfo = 0;
	rsPlayInfo[cnt].lpPartyMaster = 0;

	rsPlayInfo[cnt].DamagePacketCount = 0;				//공격 패킷 카운터
	rsPlayInfo[cnt].dwDamagePacketTime = 0;				//공격 패킷 클라이언트 시간
	rsPlayInfo[cnt].AttackCount = 0;					//공격 카운터
	rsPlayInfo[cnt].dwAttackTime = dwPlayServTime;		//공격 시간
	rsPlayInfo[cnt].dwConnectTime = dwPlayServTime;		//접속한 시간
	rsPlayInfo[cnt].dwRecvTimePlayBuff = 0;
	rsPlayInfo[cnt].BadPlayer = 0;
	rsPlayInfo[cnt].dwPacketAttackCount = 0;
	rsPlayInfo[cnt].dwPacketAttackTime = dwPlayServTime;

	rsPlayInfo[cnt].BlockTime = 0;
	rsPlayInfo[cnt].MonsterKillCounter = 0;
	rsPlayInfo[cnt].WhisperMode = 0;
	rsPlayInfo[cnt].Event_StarTicketLevel = 0;

	//클랜 코드 초기화
	rsPlayInfo[cnt].dwClanCode = 0;
	rsPlayInfo[cnt].SucessCheck_ClanCode = 0;

	//보안 통계
	rsPlayInfo[cnt].spExp_Start = 0;				//시작시 경험치
	rsPlayInfo[cnt].spMoney_Start = 0;				//시작시 돈
	rsPlayInfo[cnt].spLevel_Start = 0;				//시작시 레벨

	rsPlayInfo[cnt].spExp_InOut_Total=0;			//경험치 출력 토탈
	rsPlayInfo[cnt].spMoney_In_Total=0;				//돈 입금 토탈
	rsPlayInfo[cnt].spMoney_InOut_Total=0;			//돈 출금 토탈

	rsPlayInfo[cnt].spEXP_Out=0;					//경험치 출력
	rsPlayInfo[cnt].spMoney_In=0;					//돈 입금
	rsPlayInfo[cnt].spMoney_Out=0;					//돈 출금
	rsPlayInfo[cnt].dwLastExpMoneyCheckTime = dwPlayServTime;	//경험치 돈 클라이언트라 비교시간
	rsPlayInfo[cnt].dwLastExpMoneyTransServer = dwPlayServTime;	//경험치 돈 클라이언트라 데이타 서버와 비교

	rsPlayInfo[cnt].ServerMoney = 0;
	rsPlayInfo[cnt].WareHouseMoney = 0;
	rsPlayInfo[cnt].dwNSpriteTime = 0;

	for(cnt2=0;cnt2<8;cnt2++) {
		rsPlayInfo[cnt].dwGameServerExp[cnt2] = 0;
		ZeroMemory( rsPlayInfo[cnt].RcvItemSecCodeBuff[cnt2] , sizeof(int)*16 );
	}
	rsPlayInfo[cnt].SndItemSecCodeCount = 1;

	rsPlayInfo[cnt].smCharInfo.Level = 0;
	rsPlayInfo[cnt].smCharInfo.Exp = 0;
	rsPlayInfo[cnt].smCharInfo.Exp_High = 0;
	rsPlayInfo[cnt].smCharInfo.Money = 0;
	rsPlayInfo[cnt].smCharInfo.JOB_CODE = 0;


	rsPlayInfo[cnt].RecordWarningCount = 0;
	rsPlayInfo[cnt].RecordWarningExp = 0;
	rsPlayInfo[cnt].WarningCount = 0;

	rsPlayInfo[cnt].dwLastTradeChksum = 0;

	//공격 송수신 데이타 초기화
	rsPlayInfo[cnt].Send_AttackCount = 0;
	rsPlayInfo[cnt].Send_AttackDamage = 0;
	rsPlayInfo[cnt].Recv_AttackCount = 0;
	rsPlayInfo[cnt].Recv_AttackDamage = 0;


	rsPlayInfo[cnt].dwHopeDisconnectTime = 0;		//강제 종료 시킬 시간

	rsPlayInfo[cnt].Client_Version = 0;				//버전정보 초기화

	rsPlayInfo[cnt].UpdateInfo_WarnigCounter = 0;


	rsPlayInfo[cnt].dwMacroTime	= 0;				//매크로 감지 시간
	rsPlayInfo[cnt].dwMacroAngTime = 0;
	rsPlayInfo[cnt].dwMacroChkTime = 0;

	//클라이언트 펑션 첵크 초기화
	rsPlayInfo[cnt].dwClientFuncChk_1 = 0;
	rsPlayInfo[cnt].dwClientFuncChk_2 = 0;
	rsPlayInfo[cnt].FuncChkFailCount1 = 0;
	rsPlayInfo[cnt].FuncChkFailCount2 = 0;
	rsPlayInfo[cnt].dwFuncChkErrorFlag = 0;
	rsPlayInfo[cnt].ClientFunChk1_Count = 0;
	rsPlayInfo[cnt].ClientFunChk2_Count = 0;
	rsPlayInfo[cnt].FuncChkSucessCount1 = 0;
	rsPlayInfo[cnt].FuncChkSucessCount2 = 0;
	rsPlayInfo[cnt].dwClientFunChk_NextTime = dwPlayServTime+60*1000*5;			//3분후 설정

	rsPlayInfo[cnt].dwLastSaveTime = 0;

	rsPlayInfo[cnt].dwClentOS = 0;
	rsPlayInfo[cnt].dwClentModulChkSum = 0;
	rsPlayInfo[cnt].ClentModuleCount = 0;


	////////////////// 빌링 관련 초기화 ////////////////////
	rsPlayInfo[cnt].szGuid[0] = 0;						//고유 식별자
	rsPlayInfo[cnt].szGPCode[0] = 0;					//빌링 식별자
	rsPlayInfo[cnt].GpCode = -1;						//빌링 상품코드
	rsPlayInfo[cnt].GpType = -1;						//빌링 타입( 개인/PC방 )
	rsPlayInfo[cnt].DisuseDay = 0;						//빌링 정액제 시간
	rsPlayInfo[cnt].dwPeriodTime = 0;					//빌링 정량제 남은시간
	rsPlayInfo[cnt].Bl_RNo = 0;							//PC방 사용자 확인
	rsPlayInfo[cnt].Bl_Meter = 0;						//종량제
	rsPlayInfo[cnt].dwPeriodTime2 = 0;					//숨겨진 게임 종료시간 (태국 미성년자 빌링)
	

	////////////////// 스킬 관련 초기화 ///////////////////////////////

	rsPlayInfo[cnt].dwSkill_AutoMation_Time = 0;
	rsPlayInfo[cnt].dwSkill_AutoMation_Param = 0;
	rsPlayInfo[cnt].dwSkill_Maximize_Time = 0;
	rsPlayInfo[cnt].dwSkill_Maximize_Param = 0;
	rsPlayInfo[cnt].dwSkill_PhysicalAbsorb_Time = 0;
	rsPlayInfo[cnt].dwSkill_PhysicalAbsorb_Param = 0;
	rsPlayInfo[cnt].dwSkill_ExtreamShield_Time = 0;
	rsPlayInfo[cnt].dwSkill_ExtreamShield_Param = 0;

	rsPlayInfo[cnt].dwSkill_HolyBody_Time = 0;
	rsPlayInfo[cnt].dwSkill_HolyBody_Param = 0;
	rsPlayInfo[cnt].dwSkill_HolyValor_Time = 0;
	rsPlayInfo[cnt].dwSkill_HolyValor_Param = 0;
	rsPlayInfo[cnt].dwSkill_HolyReflection_Time = 0;
	rsPlayInfo[cnt].dwSkill_HolyReflection_Param = 0;
	rsPlayInfo[cnt].dwSkill_EnchantWeapon_Time = 0;
	rsPlayInfo[cnt].dwSkill_EnchantWeapon_Param = 0;

	rsPlayInfo[cnt].dwSkill_SparkShield_Time = 0;
	rsPlayInfo[cnt].dwSkill_MetalArmor_Param = 0;
	rsPlayInfo[cnt].dwSkill_SparkShield_Time = 0;
	rsPlayInfo[cnt].dwSkill_SparkShield_Param = 0;

	rsPlayInfo[cnt].dwSKill_Falcon_Time = 0;
	rsPlayInfo[cnt].dwSKill_Falcon_Damage[0] = 0;
	rsPlayInfo[cnt].dwSKill_Falcon_Damage[1] = 0;

	rsPlayInfo[cnt].dwSkill_DivineInhalation_Time = 0;
	rsPlayInfo[cnt].dwSkill_DivineInhalation_Param = 0;

	rsPlayInfo[cnt].dwSkill_TriumphOfValhalla_Time = 0;
	rsPlayInfo[cnt].dwSkill_TriumphOfValhalla_Param = 0;

	rsPlayInfo[cnt].dwSkill_VirtualLife_Time = 0;
	rsPlayInfo[cnt].dwSkill_VirtualLife_Param = 0;

	rsPlayInfo[cnt].dwSkill_EnergyShield_Time = 0;
	rsPlayInfo[cnt].dwSkill_EnergyShield_Param = 0;

	rsPlayInfo[cnt].dwSkill_SpiritElemental_Time = 0;
	rsPlayInfo[cnt].dwSkill_SpiritElemental_Param = 0;

	rsPlayInfo[cnt].dwSkill_DancingSword_Time = 0;
	rsPlayInfo[cnt].dwSkill_DancingSword_Param = 0;
	rsPlayInfo[cnt].dwSkill_DancingSword_DelayTime = 0;

	rsPlayInfo[cnt].dwSkill_Vanish_Time = 0;
	rsPlayInfo[cnt].dwSkill_Vanish_Param = 0;

	rsPlayInfo[cnt].dwSkill_Compulsion_Time = 0;
	rsPlayInfo[cnt].dwSkill_Compulsion_Param = 0;

	rsPlayInfo[cnt].dwSkill_MagneticSphere_Time = 0;
	rsPlayInfo[cnt].dwSkill_MagneticSphere_Param = 0;

	rsPlayInfo[cnt].dwSkill_Berserker_Time = 0;
	rsPlayInfo[cnt].dwSkill_Berserker_Param = 0;

	rsPlayInfo[cnt].dwSkill_AssassinEye_Time = 0;
	rsPlayInfo[cnt].dwSkill_AssassinEye_Param = 0;

	rsPlayInfo[cnt].dwSkill_Vague_Time = 0;
	rsPlayInfo[cnt].dwSkill_Vague_Param = 0;

	rsPlayInfo[cnt].dwSkill_ForceOfNature_Time = 0;

	rsPlayInfo[cnt].dwSkill_GodlyShied_Time = 0;
	rsPlayInfo[cnt].dwSkill_GodlyShied_Param = 0;

	rsPlayInfo[cnt].dwSkill_GodsBless_Time = 0;
	rsPlayInfo[cnt].dwSkill_GodsBless_Param = 0;

	rsPlayInfo[cnt].dwSkill_HallOfValhalla_Time = 0;

	rsPlayInfo[cnt].dwSkill_FrostJavelin_Time = 0;
	rsPlayInfo[cnt].dwSkill_FrostJavelin_Param = 0;

	rsPlayInfo[cnt].dwSkill_RegenerationField_Time = 0;

	rsPlayInfo[cnt].dwSkill_SummonMuspell_Time = 0;
	rsPlayInfo[cnt].dwSkill_SummonMuspell_Param = 0;


	////////////////// 저주 관련 초기화 ///////////////////////////////

	rsPlayInfo[cnt].dwCurse_Attack_Time = 0;		//공격 저주
	rsPlayInfo[cnt].dwCurse_Defence_Time = 0;		//방어 저주

	////////////////// 포스오브 초기화 ///////////////////////////////

	rsPlayInfo[cnt].dwForceOrb_Code = 0;			//포스오브 아이템 실행코드
	rsPlayInfo[cnt].dwForceOrb_Time = 0;			//포스오브 유지시간
	rsPlayInfo[cnt].dwForceOrb_Damage = 0;			//포스오브 데미지

	rsPlayInfo[cnt].dwForceOrb_SaveCode = 0;		//포스오브 아이템 실행코드
	rsPlayInfo[cnt].dwForceOrb_SaveTime = 0;		//포스오브 유지시간
	rsPlayInfo[cnt].dwForceOrb_SaveDamage = 0;		//포스오브 데미지
	rsPlayInfo[cnt].dwForceOrb_NextSetTime = 0;		//포스오브 정보 설정 예약시간

	//시간제 빌링 아이템 설정
	rsPlayInfo[cnt].dwPrimeItem_NextSetTime = 0;	//시간제 빌링아이템 메인서버통보 예약시간
	rsPlayInfo[cnt].dwTime_PrimeItem_X2 = 0; 		//아이템 2배 드롭
	rsPlayInfo[cnt].dwTime_PrimeItem_ExpUp = 0;		//경험치업 포션

	rsPlayInfo[cnt].dwTime_PrimeItem_VampCuspid = 0;		//뱀피릭커스핏
	rsPlayInfo[cnt].dwTime_PrimeItem_ManaRecharg = 0;		//마나리차징
	rsPlayInfo[cnt].dwTime_PrimeItem_ManaReduce = 0;		// pluto 마나 리듀스 포션
	rsPlayInfo[cnt].dwTime_PrimeItem_MightofAwell = 0;		// pluto 마이트 오브 아웰
	rsPlayInfo[cnt].dwTime_PrimeItem_MightofAwell2 = 0;		// pluto 마이트 오브 아웰2

	rsPlayInfo[cnt].dwPrimeItem_PackageCode = 0;			//패키지아이템 종류


	//PC방 펫
	rsPlayInfo[cnt].dwPCBang_Pet_AttackTime = 0;	//PC방 펫 공격 시간기록
	rsPlayInfo[cnt].dwPCBang_Pet_NextSetTime = 0;

	rsPlayInfo[cnt].lpLinkChar = 0;					//소환캐릭터 포인트

	//////////////// 블레스캐슬 관련 ////////////////
	((DWORD *)rsPlayInfo[cnt].sBlessCastle_Damage)[0] = 0;	//공성 개인별 데미지 추가치
	rsPlayInfo[cnt].dwCheck_MasterClanTime = 0;				//성주 클랜 확인 시간

	rsPlayInfo[cnt].CastleMaster.Flag = 0;
	rsPlayInfo[cnt].dwBlessSkill_Code = 0;
	rsPlayInfo[cnt].dwBlessSkill_Time = 0;

	rsPlayInfo[cnt].dwSiegeItem_Scroll_Time = 0;	//공성 아이템 스크롤
	rsPlayInfo[cnt].dwSiegeItem_Scroll_Code = 0;	//공성 아이템 스크롤
	rsPlayInfo[cnt].dwSiegeItem_Stone1_Time  = 0;	//공성 아이템 저항석
	rsPlayInfo[cnt].dwSiegeItem_Stone1_Code  = 0;	//공성 아이템 저항석
	rsPlayInfo[cnt].dwSiegeItem_Stone2_Time  = 0;	//공성 아이템 저항석
	rsPlayInfo[cnt].dwSiegeItem_Stone2_Code  = 0;	//공성 아이템 저항석

	///////////////////////////////////////////////////////////////////
	// 공격력 크리티컬 제한 수치
	((DWORD *)rsPlayInfo[cnt].sLimitDamage)[0] = 0;
	((DWORD *)rsPlayInfo[cnt].sLimitCritical)[0] = 0;

	((DWORD *)rsPlayInfo[cnt].sLowLevel_PresentItem)[0] = 0;	//저레벨 아이템 선물
	rsPlayInfo[cnt].dwStartUser_PresentItem_Time = 0;	//시작유저 아이템 선물
	rsPlayInfo[cnt].dwStartUser_PresentItem_Count = 0;	//시작유저 아이템 선물

	((DWORD *)rsPlayInfo[cnt].sCheckPlayField_Count)[0] = 0;

	rsPlayInfo[cnt].ClanTicketCode = 0;

	rsPlayInfo[cnt].dwDecPacketCode = 0;
	rsPlayInfo[cnt].dwDecPacketTime = 0;

	ZeroMemory( rsPlayInfo[cnt].dwSendFrames , CONNECTMAX*sizeof(DWORD) );
	ZeroMemory( rsPlayInfo[cnt].InvenItemInfo , INVEN_ITEM_INFO_MAX*sizeof(sTHROW_ITEM_INFO) );
	rsPlayInfo[cnt].OpenWarehouseInfoFlag = 0;
	rsPlayInfo[cnt].TradePotionInfoCount = 0;
	rsPlayInfo[cnt].MyShopListCount = 0;
	rsPlayInfo[cnt].dwMyShopTradeTime = 0;

	rsPlayInfo[cnt].dwTradeMsgCode = 0;
	rsPlayInfo[cnt].dwHaQuestItemCount = 0;


	///////////// 베트남 경험치 분배 관련 /////////////////////
	rsPlayInfo[cnt].szUserExpTimeID[0] = 0;
	rsPlayInfo[cnt].szUserExpTimeName[0] = 0;
	rsPlayInfo[cnt].dwExpGameTime = 0;
	rsPlayInfo[cnt].dwExpGameTimeCheck = 0;
	//////////////////////////////////////////////////////////

	if ( rsPlayInfo[cnt].lpRecordDataBuff ) {
		((TRANS_RECORD_DATA *)rsPlayInfo[cnt].lpRecordDataBuff)->size = 0;
		rsPlayInfo[cnt].dwRecordDataTime = dwPlayServTime;

		if ( rsPlayInfo[cnt].lpRecordDataBuff!=(rsRecordDataBuff+((srRECORD_MEMORY_SIZE+256)*cnt)) ) {
			TransCommand.WParam = 10007;
			TransCommand.LParam = (int)rsRecordDataBuff+((srRECORD_MEMORY_SIZE+256)*cnt);
			TransCommand.SParam = (int)rsPlayInfo[cnt].lpRecordDataBuff;
			RecordHackLogFile( &rsPlayInfo[cnt] , &TransCommand );
		}
	}
	else 
		rsPlayInfo[cnt].dwRecordDataTime = 0;


	dwConnectCount++;



	if ( strstr( lpsmSock->szIPAddr , szAdminIP )!=0 ) rsPlayInfo[cnt].AdminIP = TRUE;
	else if ( strstr( lpsmSock->szIPAddr , szAdminIP2 )!=0 ) rsPlayInfo[cnt].AdminIP = TRUE;
	else {
		if ( rsCheckAdminIP( rsPlayInfo[cnt].lpsmSock->acc_sin.sin_addr.S_un.S_addr )==TRUE ) 
				rsPlayInfo[cnt].AdminIP = TRUE;
			else
				rsPlayInfo[cnt].AdminIP = FALSE;
	}


	//if ( AutoPlayServer ) {

		//버전 정보 전송
		TransCommand.code = smTRANSCODE_VERSION;
		TransCommand.size = sizeof( smTRANS_COMMAND );
		TransCommand.WParam = Server_LimitVersion;
		TransCommand.LParam = 0;

		if ( rsGetUserCounter(PlayerCount)>=rsConnectUserLimit ) {
			if ( !rsPlayInfo[cnt].AdminIP ) {
				TransCommand.LParam = PlayerCount;		//인원제한 접속 실패
			}
		}

		lpsmSock->Send2( (char *)&TransCommand , TransCommand.size , TRUE );
	//}

	return TRUE;
}

//지역 스테이지 포인터가 올바른지 확인
int IsStgArea( STG_AREA *lpStgArea )
{
	int cnt;

	for( cnt=0;cnt<STAGE_AREA_MAX;cnt++ ) {
		if ( lpStgArea==&StageArea[cnt] )
			return TRUE;
	}
	return FALSE;
}


//설정된 공지사항을 클라이언트에 보낸다
int	rsSendServerNoticeToUser( rsPLAYINFO *lpPlayInfo )
{
	TRANS_CHATMESSAGE	TransChatMessage;

	wsprintf( TransChatMessage.szMessage , srMsg_011 , rsNoticeMessage.szMessage ); 
	TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
	TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
	TransChatMessage.dwIP = 3;
	TransChatMessage.dwObjectSerial = 0;

	if ( lpPlayInfo->lpsmSock )
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

	lpPlayInfo->dwNoticeCount = rsNoticeMessage.Counter;

	return TRUE;
}

//공지사항을 설정한다
int	rsSetNoticeMessage( char *szMessage )
{
	lstrcpy( rsNoticeMessage.szMessage , szMessage );
	rsNoticeMessage.Counter++;

	return rsNoticeMessage.Counter;
}


//클라이언트에 데이타 저장 요구
int	SendSaveClientData( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND	smTransCommand;

	smTransCommand.code = smTRANSCODE_SAVECLIENT;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam = 0;
	smTransCommand.LParam = 0;
	smTransCommand.SParam = 0;
	smTransCommand.EParam = 0;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
	}

	return TRUE;
}

//클라이언트에 강제 저장후 종료 요구
int	rsSendCloseClient( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND	smTransCommand;

	smTransCommand.code = smTRANSCODE_CLOSECLIENT;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam = 0;
	smTransCommand.LParam = 0;
	smTransCommand.SParam = 0;
	smTransCommand.EParam = 0;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
	}

	return TRUE;
}

//고친 경험치를 기록으로 남긴다
int	rsRecordFixExp( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND	smTransCommand;
	int tExp;

	if ( lpPlayInfo->RecordWarningExp ) {

		tExp = lpPlayInfo->dwGameServerExp[0] + lpPlayInfo->dwGameServerExp[1] + lpPlayInfo->dwGameServerExp[2] + lpPlayInfo->dwGameServerExp[3] +
				lpPlayInfo->dwGameServerExp[4] + lpPlayInfo->dwGameServerExp[5] + lpPlayInfo->dwGameServerExp[6] + lpPlayInfo->dwGameServerExp[7];

		smTransCommand.WParam = 6630;
		smTransCommand.LParam = lpPlayInfo->smCharInfo.Level;
		smTransCommand.SParam = lpPlayInfo->RecordWarningExp/1000;
		smTransCommand.EParam = (int)((tExp+lpPlayInfo->spExp_Start)/1000);
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
/*
		/////////////////// 임시 디버깅을 위해서 ////////////////////////
		smTransCommand.WParam = 6630;
		smTransCommand.LParam = lpPlayInfo->spExp_Start;
		smTransCommand.SParam = lpPlayInfo->dwGameServerExp[1];
		smTransCommand.EParam = lpPlayInfo->dwGameServerExp[2];
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		smTransCommand.WParam = 6630;
		smTransCommand.LParam = lpPlayInfo->dwGameServerExp[3];
		smTransCommand.SParam = lpPlayInfo->dwGameServerExp[4];
		smTransCommand.EParam = lpPlayInfo->dwGameServerExp[5];
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		smTransCommand.WParam = 6630;
		smTransCommand.LParam = lpPlayInfo->dwGameServerExp[6];
		smTransCommand.SParam = lpPlayInfo->dwGameServerExp[7];
		smTransCommand.EParam = lpPlayInfo->dwGameServerExp[0];
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
*/

	}
	return TRUE;
}

//버려진 아이템중 제일 싸구려 코드를 찾아 지우고 재설정한다
int SaveThrowItemOver( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwKey , DWORD dwSum )
{
	int cnt;
	int LowCount;
	DWORD	LowCode;
	DWORD	Code;

	if ( lpPlayInfo->ThrowItemCount<=0 ) return FALSE;

	LowCount = 0;
	LowCode = lpPlayInfo->ThrowItemInfo[LowCount].dwCode & sinITEM_MASK3;

	for(cnt=1;cnt<lpPlayInfo->ThrowItemCount;cnt++) {
		Code = lpPlayInfo->ThrowItemInfo[cnt].dwCode & sinITEM_MASK3;
		if ( Code<LowCode ) {
			LowCode = Code;
			LowCount = cnt;
		}
	}

	lpPlayInfo->ThrowItemInfo[LowCount].dwCode = dwCode;
	lpPlayInfo->ThrowItemInfo[LowCount].dwKey = dwKey;
	lpPlayInfo->ThrowItemInfo[LowCount].dwSum = dwSum;

	return TRUE;
}


//던져진 아이템 저장
int SaveThrowItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode, DWORD dwKey , DWORD dwSum )
{
	int cnt;

	if ( (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) return TRUE;		//물약 제외

	for( cnt=0;cnt<lpPlayInfo->ThrowItemCount;cnt++ ) {
		if ( lpPlayInfo->ThrowItemInfo[cnt].dwCode==dwCode &&
			lpPlayInfo->ThrowItemInfo[cnt].dwKey==dwKey &&
			lpPlayInfo->ThrowItemInfo[cnt].dwSum==dwSum ) {

				return TRUE;
			}
	}


	if ( lpPlayInfo->ThrowItemCount>=THROW_ITEM_INFO_MAX-1 ) {
		//버퍼가 꽉참 버려진 아이템중 제일 싸구려 코드를 찾아 지우고 재설정한다
		return SaveThrowItemOver( lpPlayInfo , dwCode , dwKey , dwSum );
	}

	lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwCode = dwCode;
	lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwKey = dwKey;
	lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwSum = dwSum;

	if ( lpPlayInfo->ThrowItemCount<THROW_ITEM_INFO_MAX-1 ) {
		lpPlayInfo->ThrowItemCount++;

		if ( lpPlayInfo->ThrowItemCount==THROW_ITEM_INFO_MAX-32 ||
			lpPlayInfo->ThrowItemCount>THROW_ITEM_INFO_MAX-48 ) {
			//버퍼가 꽉참 클라이언트에 데이타 저장 요구
			SendSaveClientData( lpPlayInfo );
		}
	}

	return TRUE;
}

//던져진 아이템 저장( 버퍼가 차도 데이타 저장 요구 안함 )
int SaveThrowItem2( rsPLAYINFO *lpPlayInfo , DWORD dwCode, DWORD dwKey , DWORD dwSum )
{
	int cnt;

	if ( (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) return TRUE;		//물약 제외

	for( cnt=0;cnt<lpPlayInfo->ThrowItemCount;cnt++ ) {
		if ( lpPlayInfo->ThrowItemInfo[cnt].dwCode==dwCode &&
			lpPlayInfo->ThrowItemInfo[cnt].dwKey==dwKey &&
			lpPlayInfo->ThrowItemInfo[cnt].dwSum==dwSum ) {

				return TRUE;
			}
	}

	if ( lpPlayInfo->ThrowItemCount>=THROW_ITEM_INFO_MAX-1 ) {
		//버퍼가 꽉참 버려진 아이템중 제일 싸구려 코드를 찾아 지우고 재설정한다
		return SaveThrowItemOver( lpPlayInfo , dwCode , dwKey , dwSum );
	}

	lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwCode = dwCode;
	lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwKey = dwKey;
	lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwSum = dwSum;

	if ( lpPlayInfo->ThrowItemCount<THROW_ITEM_INFO_MAX-1 ) {
		lpPlayInfo->ThrowItemCount++;
	}

	return TRUE;
}

//던져진 아이템 저장 ( 다수 )
int SaveThrowItems( rsPLAYINFO *lpPlayInfo , TRANS_THROW_ITEMS	*lpTransThrowItems )
{
	int cnt;

	for( cnt=0;cnt<lpTransThrowItems->ThrowItemCount;cnt++) {
		if ( lpPlayInfo->ThrowItemCount>=THROW_ITEM_INFO_MAX-1 ) {
			//버퍼가 꽉참 버려진 아이템중 제일 싸구려 코드를 찾아 지우고 재설정한다
			SaveThrowItemOver( lpPlayInfo , 
				lpTransThrowItems->ThrowItems[cnt].dwCode , 
				lpTransThrowItems->ThrowItems[cnt].dwHead , 
				lpTransThrowItems->ThrowItems[cnt].dwChkSum );
		}
		else {
			lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwCode = lpTransThrowItems->ThrowItems[cnt].dwCode;
			lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwKey =  lpTransThrowItems->ThrowItems[cnt].dwHead;
			lpPlayInfo->ThrowItemInfo[lpPlayInfo->ThrowItemCount].dwSum =  lpTransThrowItems->ThrowItems[cnt].dwChkSum;
			lpPlayInfo->ThrowItemCount++;
		}
	}

	return TRUE;
}

//인벤 아이템 찾기
int	rsFindInvenItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum )
{
	int cnt;

	if ( !rsServerConfig.ServerInventoryMode ) return INVEN_ITEM_INFO_MAX;

	//물약이면 제외
	if ( (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) || dwCode==(sinGG1|sin01) ) return INVEN_ITEM_INFO_MAX;

	for( cnt=0;cnt<INVEN_ITEM_INFO_MAX;cnt++ ) {
		if ( lpPlayInfo->InvenItemInfo[cnt].dwCode && 
			lpPlayInfo->InvenItemInfo[cnt].dwCode==dwCode &&
			lpPlayInfo->InvenItemInfo[cnt].dwKey==dwHead &&
			lpPlayInfo->InvenItemInfo[cnt].dwSum==dwChkSum ) {

				return cnt;
			}
	}


	if ( lpPlayInfo->OpenWarehouseInfoFlag ) {
		for( cnt=0;cnt<100;cnt++ ) {
			if ( lpPlayInfo->WareHouseItemInfo[cnt].dwCode &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwCode==dwCode &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwKey==dwHead &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwSum==dwChkSum ) {

					return INVEN_ITEM_INFO_MAX;
			}
		}
	}

	return -1;
}

//같은 코드의 아이템 찾기
int	rsCheckInvenItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode )
{
	int cnt;

	if ( !rsServerConfig.ServerInventoryMode ) return INVEN_ITEM_INFO_MAX;

	//물약이면 제외
	if ( (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) || dwCode==(sinGG1|sin01) ) return INVEN_ITEM_INFO_MAX;

	for( cnt=0;cnt<INVEN_ITEM_INFO_MAX;cnt++ ) {
		if ( lpPlayInfo->InvenItemInfo[cnt].dwCode && 
			lpPlayInfo->InvenItemInfo[cnt].dwCode==dwCode ) {
				return cnt;
			}
	}


	if ( lpPlayInfo->OpenWarehouseInfoFlag ) {
		for( cnt=0;cnt<100;cnt++ ) {
			if ( lpPlayInfo->WareHouseItemInfo[cnt].dwCode &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwCode==dwCode ) {
					return INVEN_ITEM_INFO_MAX;
			}
		}
	}

	return -1;
}


//인벤 아이템 제거
int	rsDeleteInvenItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum )
{
	int cnt;

	if ( !rsServerConfig.ServerInventoryMode ) return INVEN_ITEM_INFO_MAX;

	//물약이면 제외
	if ( (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) || dwCode==(sinGG1|sin01) ) return INVEN_ITEM_INFO_MAX;

	for( cnt=0;cnt<INVEN_ITEM_INFO_MAX;cnt++ ) {
		if ( lpPlayInfo->InvenItemInfo[cnt].dwCode && 
			lpPlayInfo->InvenItemInfo[cnt].dwCode==dwCode &&
			lpPlayInfo->InvenItemInfo[cnt].dwKey==dwHead &&
			lpPlayInfo->InvenItemInfo[cnt].dwSum==dwChkSum ) {

				lpPlayInfo->InvenItemInfo[cnt].dwCode = 0;
				return cnt;
			}
	}

	if ( lpPlayInfo->OpenWarehouseInfoFlag ) {
		for( cnt=0;cnt<100;cnt++ ) {
			if ( lpPlayInfo->WareHouseItemInfo[cnt].dwCode &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwCode==dwCode &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwKey==dwHead &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwSum==dwChkSum ) {

					lpPlayInfo->WareHouseItemInfo[cnt].dwCode = 0;
					return INVEN_ITEM_INFO_MAX;
			}
		}
	}


	return -1;
}

//인벤 아이템 추가
int	rsAddInvenItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum )
{
	int	cnt;
	int	Empty;


	if ( !rsServerConfig.ServerInventoryMode ) return INVEN_ITEM_INFO_MAX;

	//물약이면 제외
	if ( (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) || dwCode==(sinGG1|sin01) ) return INVEN_ITEM_INFO_MAX;

	Empty = -1;

	for( cnt=0;cnt<INVEN_ITEM_INFO_MAX;cnt++ ) {
		if ( lpPlayInfo->InvenItemInfo[cnt].dwCode ){
			if (lpPlayInfo->InvenItemInfo[cnt].dwCode==dwCode &&
				lpPlayInfo->InvenItemInfo[cnt].dwKey==dwHead &&
				lpPlayInfo->InvenItemInfo[cnt].dwSum==dwChkSum ) {
			
				return cnt;
			}
		}
		else {
			Empty = cnt;
		}
	}

	if ( lpPlayInfo->OpenWarehouseInfoFlag ) {
		for( cnt=0;cnt<100;cnt++ ) {
			if ( lpPlayInfo->WareHouseItemInfo[cnt].dwCode &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwCode==dwCode &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwKey==dwHead &&
				lpPlayInfo->WareHouseItemInfo[cnt].dwSum==dwChkSum ) {

					return INVEN_ITEM_INFO_MAX;
			}
		}
	}

	if ( Empty>=0 ) {
		lpPlayInfo->InvenItemInfo[Empty].dwCode = dwCode;
		lpPlayInfo->InvenItemInfo[Empty].dwKey = dwHead;
		lpPlayInfo->InvenItemInfo[Empty].dwSum = dwChkSum;
		return Empty;
	}

	smTRANS_COMMAND	smTransCommand;
	//서버 인벤토리 버퍼 초과
	smTransCommand.WParam = 8050;
	smTransCommand.LParam = dwCode; 
	smTransCommand.SParam = Empty;
	smTransCommand.EParam = (int)lpPlayInfo->OpenWarehouseInfoFlag;
	RecordHackLogFile( lpPlayInfo , &smTransCommand );



	return -1;
}

//서버 포션에서 물약 구하기
int rsGetServerPotion( rsPLAYINFO *lpPlayInfo , DWORD dwPotionCode )
{
	int x=-1,y=-1;

	switch( dwPotionCode ) {
		case (sinPL1|sin01):		//생명(소)
			x = 0; y = 0;
			break;
		case (sinPL1|sin02):		//생명(중)
			x = 0; y = 1;
			break;
		case (sinPL1|sin03):		//생명(대)
			x = 0; y = 2;
			break;
		case (sinPL1|sin04):		//생명(신)
			x = 0; y = 3;
			break;

		case (sinPM1|sin01):		//기력(소)
			x = 1; y = 0;
			break;
		case (sinPM1|sin02):		//기력(중)
			x = 1; y = 1;
			break;
		case (sinPM1|sin03):		//기력(대)
			x = 1; y = 2;
			break;
		case (sinPM1|sin04):		//기력(신)
			x = 1; y = 3;
			break;

		case (sinPS1|sin01):		//근력(소)
			x = 2; y = 0;
			break;
		case (sinPS1|sin02):		//근력(중)
			x = 2; y = 1;
			break;
		case (sinPS1|sin03):		//근력(대)
			x = 2; y = 2;
			break;
		case (sinPS1|sin04):		//근력(신)
			x = 2; y = 3;
			break;
	}

	if ( x>=0 && y>=0 ) 
		return lpPlayInfo->ServerPotion[x][y];

	return 0;

}

//서버 포션에 물약 추가
int rsAddServerPotion( rsPLAYINFO *lpPlayInfo , DWORD dwPotionCode , int PotionCount )
{
	int Count=PotionCount;
	int x,y,pos;

	if ( !rsServerConfig.PotionMonitor ) return FALSE;

	x = -1;
	y = -1;
	pos = 0;

	switch( dwPotionCode ) {
		case (sinPL1|sin01):		//생명(소)
			x=0;y=0;
			break;
		case (sinPL1|sin02):		//생명(중)
			x=0;y=1;
			break;
		case (sinPL1|sin03):		//생명(대)
			x=0;y=2;
			break;
		case (sinPL1|sin04):		//생명(신)
			x=0;y=3;
			break;

		case (sinPM1|sin01):		//기력(소)
			x=1;y=0;
			break;
		case (sinPM1|sin02):		//기력(중)
			x=1;y=1;
			break;
		case (sinPM1|sin03):		//기력(대)
			x=1;y=2;
			break;
		case (sinPM1|sin04):		//기력(신)
			x=1;y=3;
			break;

		case (sinPS1|sin01):		//근력(소)
			x=2;y=0;
			break;
		case (sinPS1|sin02):		//근력(중)
			x=2;y=1;
			break;
		case (sinPS1|sin03):		//근력(대)
			x=2;y=2;
			break;
		case (sinPS1|sin04):		//근력(신)
			x=2;y=3;
			break;
	}

	pos = lpPlayInfo->ServerPotion[x][y] + Count;

	if ( pos<0 && Count<0 ) {
		lpPlayInfo->ServerPotion[x][y] = 0;
		return pos;
	}

	lpPlayInfo->ServerPotion[x][y] = pos;


/*
	switch( dwPotionCode ) {
		case (sinPL1|sin01):		//생명(소)
			lpPlayInfo->ServerPotion[0][0] += Count;
			break;
		case (sinPL1|sin02):		//생명(중)
			lpPlayInfo->ServerPotion[0][1] += Count;
			break;
		case (sinPL1|sin03):		//생명(대)
			lpPlayInfo->ServerPotion[0][2] += Count;
			break;
		case (sinPL1|sin04):		//생명(신)
			lpPlayInfo->ServerPotion[0][3] += Count;
			break;

		case (sinPM1|sin01):		//기력(소)
			lpPlayInfo->ServerPotion[1][0] += Count;
			break;
		case (sinPM1|sin02):		//기력(중)
			lpPlayInfo->ServerPotion[1][1] += Count;
			break;
		case (sinPM1|sin03):		//기력(대)
			lpPlayInfo->ServerPotion[1][2] += Count;
			break;
		case (sinPM1|sin04):		//기력(신)
			lpPlayInfo->ServerPotion[1][3] += Count;
			break;

		case (sinPS1|sin01):		//근력(소)
			lpPlayInfo->ServerPotion[2][0] += Count;
			break;
		case (sinPS1|sin02):		//근력(중)
			lpPlayInfo->ServerPotion[2][1] += Count;
			break;
		case (sinPS1|sin03):		//근력(대)
			lpPlayInfo->ServerPotion[2][2] += Count;
			break;
		case (sinPS1|sin04):		//근력(신)
			lpPlayInfo->ServerPotion[2][3] += Count;
			break;
	}
*/

	return pos;
}

//서버 포션 에러 로그 기록
int rsServerPotionErrorLog( rsPLAYINFO *lpPlayInfo ,  DWORD dwCode , int Count , int Position )
{
	smTRANS_COMMAND_EX	smTransCommandEx;

	if ( lpPlayInfo->WarningCount<3 ) {
		//로그에 기록
		smTransCommandEx.WParam = 8810;
		smTransCommandEx.LParam = dwCode;
		smTransCommandEx.SParam = Count;
		smTransCommandEx.EParam = Position;
		RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
	}

	return TRUE;
}


//물약 거래정보 확인
int	rsGetTradePotionInfo( rsPLAYINFO *lpPlayInfo , DWORD dwCode )
{
	int cnt;

	for(cnt=0;cnt<lpPlayInfo->TradePotionInfoCount;cnt++) {
		if ( lpPlayInfo->dwTradePotionInfo[cnt]==dwCode ) {
			return TRUE;
		}
	}

	return FALSE;
}

//물약 거래정보 저장
int	rsAddTradePotionInfo( rsPLAYINFO *lpPlayInfo, DWORD	dwCode )
{

	if ( lpPlayInfo->TradePotionInfoCount>=16 ) return FALSE;

	if ( rsGetTradePotionInfo( lpPlayInfo , dwCode )==TRUE ) return TRUE;

	lpPlayInfo->dwTradePotionInfo[ lpPlayInfo->TradePotionInfoCount++ ] = dwCode;

	return TRUE;
}



//아이템 트레이드 처리
int	rsTradeInvenItem( rsPLAYINFO *lpPlayInfo , rsPLAYINFO *lpPlayInfo2 , TRANS_TRADE_ITEMKEY *lpTransTradeItemKey )
{
	int cnt;
	int money;
	smTRANS_COMMAND_EX	smTransCommand;
	DWORD	dwTradeCode;
	DWORD	dwTradeTime;
	int	PotionCount;

	if ( !lpPlayInfo || !lpPlayInfo2 ) return FALSE;
	
	//트레이드 코드 구하여 확인
	dwTradeCode = ( lpTransTradeItemKey->Money * lpPlayInfo->dwObjectSerial + lpPlayInfo2->dwObjectSerial );
	for( cnt=0;cnt<MAX_TRADE_ITEM;cnt++) {
		if ( lpTransTradeItemKey->dwItemCode[cnt] ) {
			dwTradeCode +=(lpTransTradeItemKey->dwItemCode[cnt]+lpTransTradeItemKey->dwItemKey[cnt]+
				lpTransTradeItemKey->dwItemSum[cnt])*(cnt+2);
		}
	}
	dwTradeTime = dwPlayServTime;

	if ( (dwTradeTime-lpPlayInfo->dwLastTradeTime)<8000 && lpPlayInfo->dwLastTradeChksum==dwTradeCode ) {
		//이미 거래 성공 ( 한번 더확인 )
		for( cnt=0;cnt<MAX_TRADE_ITEM;cnt++) {
			if ( lpTransTradeItemKey->dwItemCode[cnt] ) {
				if ( (lpTransTradeItemKey->dwItemCode[cnt]&sinITEM_MASK1)!=(sinPM1&sinITEM_MASK1) )	{
					if ( rsDeleteInvenItem( lpPlayInfo , 
							lpTransTradeItemKey->dwItemCode[cnt] ,
							lpTransTradeItemKey->dwItemKey[cnt] ,
							lpTransTradeItemKey->dwItemSum[cnt] )>=0 ) {
								//이미 거래된서 사라져야할 아이템이 존재
								//로그에 기록
								smTransCommand.WParam = 8000;
								smTransCommand.WxParam = 31;
								smTransCommand.LxParam = (int)"*TRADE CHECKING ERROR*";
								smTransCommand.LParam = lpTransTradeItemKey->dwItemCode[cnt];
								smTransCommand.SParam = lpTransTradeItemKey->dwItemKey[cnt];
								smTransCommand.EParam = lpTransTradeItemKey->dwItemSum[cnt];
								RecordHackLogFile( lpPlayInfo , &smTransCommand );
							}
				}
			}
		}
		return TRUE;
	}

	lpPlayInfo->TradePotionInfoCount = 0;	//물약 거래 정보 초기화

	if ( lpTransTradeItemKey->Money ) {
		//거래시 돈 들어감
		money = lpTransTradeItemKey->Money-193;
		if ( lpPlayInfo->ServerMoney<money ) {

			//로그
			smTransCommand.WParam = 8010;
			smTransCommand.LParam = 30;
			smTransCommand.SParam = lpPlayInfo->ServerMoney;
			smTransCommand.EParam = money;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );

			//실제돈 보다 거래창의 돈이 많다
			return FALSE;
		}

		lpPlayInfo->SubServerMoney( money , WHERE_TRADE );
		lpPlayInfo2->AddServerMoney( money , WHERE_TRADE );
	}

	for( cnt=0;cnt<MAX_TRADE_ITEM;cnt++) {
		if ( lpTransTradeItemKey->dwItemCode[cnt] ) {
			//물약인 경우만 따로 저장하도록
			if ( (lpTransTradeItemKey->dwItemCode[cnt]&sinITEM_MASK1)!=(sinPM1&sinITEM_MASK1) )	{
				if ( rsDeleteInvenItem( lpPlayInfo , lpTransTradeItemKey->dwItemCode[cnt] , 
						lpTransTradeItemKey->dwItemKey[cnt] ,
						lpTransTradeItemKey->dwItemSum[cnt] )<0 ) {

							//로그에 기록
							smTransCommand.WParam = 8000;
							smTransCommand.WxParam = 30;
							smTransCommand.LxParam = (int)"*TRADE ITEM*";
							smTransCommand.LParam = lpTransTradeItemKey->dwItemCode[cnt];
							smTransCommand.SParam = lpTransTradeItemKey->dwItemKey[cnt];
							smTransCommand.EParam = lpTransTradeItemKey->dwItemSum[cnt];
							RecordHackLogFile( lpPlayInfo , &smTransCommand );

							//제거 아이템 오류
							lpTransTradeItemKey->dwItemKey[cnt] = 0;
							//return FALSE;
						}
			}
			else {
/*
			if ( (TransTradeItemKey.dwItemCode[cnt]&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
				//물약이다! ( 아이템 체크섬에 물약갯수를 설정 )
				TransTradeItemKey.dwItemSum[cnt] = lpTrade->TradeItem[cnt].sItemInfo.PotionCount&0xFFFF;
				TransTradeItemKey.dwItemSum[cnt] |= (lpTrade->TradeItem[cnt].sItemInfo.ItemHeader.dwChkSum)<<16;
				TransTradeItemKey.dwItemSum[cnt] ^= (TransTradeItemKey.dwItemSum[cnt]>>16)^0x5cbc;
			}
*/

				//물약갯수 유출하여 서버포션에서 추가및 삭제
				PotionCount = 0x5cbc^(lpTransTradeItemKey->dwItemSum[cnt]>>16)^lpTransTradeItemKey->dwItemSum[cnt];
				PotionCount &= 0xFFFF;

				if ( rsAddServerPotion( lpPlayInfo , lpTransTradeItemKey->dwItemCode[cnt] , -PotionCount )<0 ) {
					//서버 물약갯수 오류
					rsServerPotionErrorLog( lpPlayInfo ,  lpTransTradeItemKey->dwItemCode[cnt] , -PotionCount , 100 );
					return FALSE;
				}
				rsAddServerPotion( lpPlayInfo2 , lpTransTradeItemKey->dwItemCode[cnt] , PotionCount );

				//물약 거래 정보 저장
				rsAddTradePotionInfo( lpPlayInfo, lpTransTradeItemKey->dwItemCode[cnt] );
			}

			if ( lpTransTradeItemKey->dwItemKey[cnt] ) {
				rsAddInvenItem( lpPlayInfo2 , lpTransTradeItemKey->dwItemCode[cnt] , 
						lpTransTradeItemKey->dwItemKey[cnt] ,
						lpTransTradeItemKey->dwItemSum[cnt] );

				//던져진 아이템 저장
				SaveThrowItem2( lpPlayInfo ,lpTransTradeItemKey->dwItemCode[cnt], lpTransTradeItemKey->dwItemKey[cnt] , lpTransTradeItemKey->dwItemSum[cnt] );
			}

		}
	}

	lpPlayInfo->dwLastTradeTime = dwTradeTime;
	lpPlayInfo->dwLastTradeChksum = dwTradeCode;

	//아이템 로그 트레이드
	rsRecord_ItemLog_Trade( lpPlayInfo , lpPlayInfo2, lpTransTradeItemKey );

	return TRUE;
}

//채팅 데이타 클라이언트로 전송
int SendChatMessage()
{
	int cnt;
	TRANS_CHATBUFF	tChatBuff;
	rsPLAYINFO	*lpPlayInfo;
	CHATBUFF	*lpChatBuff;
	int len;

	for( cnt=0;cnt<CONNECTMAX;cnt++) {
		lpPlayInfo = &rsPlayInfo[cnt];
		if ( lpPlayInfo->lpsmSock && rsPlayInfo[cnt].dwObjectSerial && lpPlayInfo->ChatBuffCnt<ChatBuffCnt ) {

			if ( (ChatBuffCnt-lpPlayInfo->ChatBuffCnt)>32 ) {
				lpPlayInfo->ChatBuffCnt = ChatBuffCnt-8;
			}

			lpChatBuff = &ChatBuff[ lpPlayInfo->ChatBuffCnt & CHATBUFF_MASK ];

			len = sizeof( TRANS_CHATBUFF ) + lstrlen( lpChatBuff->szMessage ) +1;

			tChatBuff.code = smTRANSCODE_CHATMESSAGE;
			tChatBuff.dwIP = lpChatBuff->dwIP;
			tChatBuff.size = len;
			memcpy( TransTemp , &tChatBuff , sizeof( TRANS_CHATBUFF ) );
			lstrcpy( TransTemp+sizeof( TRANS_CHATBUFF ), lpChatBuff->szMessage );
			if ( lpPlayInfo->lpsmSock->Send( TransTemp , len , TRUE )==TRUE ) {
				lpPlayInfo->ChatBuffCnt++;
			}
		}
	}

	return TRUE;
}


//상점 아이템 목록 클라이언트에 전송
int SendShopItemList( smWINSOCK *lpsmSock , smCHAR *lpChar )
{
	int cnt;
	char szBuff[smSOCKBUFF_SIZE];
	smTRANS_SELL_ITEM	*lpTransSellItem;
	sDEF_ITEMINFO		*lpDefItem;
	char *lpBuff;
	int TransLen;
	int	ItemCount;



	lpTransSellItem = (smTRANS_SELL_ITEM *)szBuff;

	lpTransSellItem->code = smTRANSCODE_SHOP_ITEMLIST;

	if ( lpChar->smMonsterInfo.SellAttackItemCount ) {
		ItemCount = 0;
		//공격 아이템 판매 목록 작성
		lpBuff = ((char *)lpTransSellItem)+sizeof(smTRANS_SELL_ITEM);
		TransLen = sizeof(smTRANS_SELL_ITEM);
		for( cnt=0;cnt<lpChar->smMonsterInfo.SellAttackItemCount;cnt++) {
			lpDefItem = (sDEF_ITEMINFO *)lpChar->smMonsterInfo.SellAttackItem[cnt];
			if ( lpDefItem && (TransLen+lpDefItem->DefCompressDataLen)<smSOCKBUFF_SIZE ) {
				memcpy( lpBuff , lpDefItem->DefCompressData , lpDefItem->DefCompressDataLen );
				TransLen += lpDefItem->DefCompressDataLen;
				lpBuff += lpDefItem->DefCompressDataLen;
				ItemCount++;
			}
		}
		lpTransSellItem->size = TransLen;
		lpTransSellItem->ItemKind = 1;
		lpTransSellItem->ItemCounter = ItemCount;
		lpsmSock->Send( (char *)lpTransSellItem , lpTransSellItem->size , TRUE );
	}


	if ( lpChar->smMonsterInfo.SellDefenceItemCount ) {
		ItemCount = 0;
		//방어 아이템 판매 목록 작성
		lpBuff = ((char *)lpTransSellItem)+sizeof(smTRANS_SELL_ITEM);
		TransLen = sizeof(smTRANS_SELL_ITEM);
		for( cnt=0;cnt<lpChar->smMonsterInfo.SellDefenceItemCount;cnt++) {
			lpDefItem = (sDEF_ITEMINFO *)lpChar->smMonsterInfo.SellDefenceItem[cnt];
			if ( lpDefItem && (TransLen+lpDefItem->DefCompressDataLen)<smSOCKBUFF_SIZE ) {
				memcpy( lpBuff , lpDefItem->DefCompressData , lpDefItem->DefCompressDataLen );
				TransLen += lpDefItem->DefCompressDataLen;
				lpBuff += lpDefItem->DefCompressDataLen;
				ItemCount++;
			}
		}
		lpTransSellItem->size = TransLen;
		lpTransSellItem->ItemKind = 2;
		lpTransSellItem->ItemCounter = ItemCount;
		lpsmSock->Send( (char *)lpTransSellItem , lpTransSellItem->size , TRUE );
	}


	if ( lpChar->smMonsterInfo.SellEtcItemCount ) {
		ItemCount = 0;
		//방어 아이템 판매 목록 작성
		lpBuff = ((char *)lpTransSellItem)+sizeof(smTRANS_SELL_ITEM);
		TransLen = sizeof(smTRANS_SELL_ITEM);
		for( cnt=0;cnt<lpChar->smMonsterInfo.SellEtcItemCount;cnt++) {
			lpDefItem = (sDEF_ITEMINFO *)lpChar->smMonsterInfo.SellEtcItem[cnt];
			if ( lpDefItem && (TransLen+lpDefItem->DefCompressDataLen)<smSOCKBUFF_SIZE ) {
				memcpy( lpBuff , lpDefItem->DefCompressData , lpDefItem->DefCompressDataLen );
				TransLen += lpDefItem->DefCompressDataLen;
				lpBuff += lpDefItem->DefCompressDataLen;
				ItemCount++;
			}
		}
		lpTransSellItem->size = TransLen;
		lpTransSellItem->ItemKind = 3;
		lpTransSellItem->ItemCounter = ItemCount;
		lpsmSock->Send( (char *)lpTransSellItem , lpTransSellItem->size , TRUE );
	}


	return TRUE;
}

int SendSkillMenu( smWINSOCK *lpsmSock , smCHAR *lpChar , int Mode )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_SKILL_MENU;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam  = Mode;
	smTransCommand.LParam  = 0;
	smTransCommand.SParam  = 0;


	if ( rsServerConfig.Disable_Quest==Mode )
		smTransCommand.WParam  = FALSE;
	//else
	//	smTransCommand.WParam  = TRUE;


	return lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
}

//창고 데이타 송출
int SendWareHouseToClient( rsPLAYINFO *lpPlayInfo )
{

	if ( (lpPlayInfo->dwDataError&rsDATA_ERROR_WAREHOUSE)!=0 )
		return FALSE;

	if ( lpPlayInfo->szID[0] && !lpPlayInfo->szServerID[0] && ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size>0 ) {
		//창고 데이타 송출
		return rsLoadWareHouseData( lpPlayInfo );
	}

	return FALSE;
}

//창고 열기
int SendOpenWareHouse( smWINSOCK *lpsmSock )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_OPEN_WAREHOUSE;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam  = 0;
	smTransCommand.LParam  = 0;
	smTransCommand.SParam  = 0;

	return lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
}

//아이템 조합창 열기
int SendOpenMixItem( smWINSOCK *lpsmSock , int MixFlag )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_OPEN_MIXITEM;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam  = MixFlag;
	smTransCommand.LParam  = 0;
	smTransCommand.SParam  = 0;

	return lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
}

// pluto 아이템 제련
int SendOpenSmelting( smWINSOCK *lpsmSock )
{
	smTRANS_COMMAND smTransCommand;

	smTransCommand.code = smTRANSCODE_OPEN_SMELTING;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam = 0;
	smTransCommand.LParam = 0;
	smTransCommand.SParam = 0;

	return lpsmSock->Send2( (char *)&smTransCommand, smTransCommand.size, TRUE );
}
// pluto 아이템 제작
int SendOpenManufacture( smWINSOCK *lpsmSock )
{
	smTRANS_COMMAND smTransCommand;

	smTransCommand.code = smTRANSCODE_OPEN_MANUFACTURE;
	smTransCommand.size = sizeof( smTRANS_COMMAND );
	smTransCommand.WParam = 0;
	smTransCommand.LParam = 0;
	smTransCommand.SParam = 0;

	return lpsmSock->Send2( (char *)&smTransCommand, smTransCommand.size, TRUE );
}

//모금함 열기
int SendOpenCollectMoney( smWINSOCK *lpsmSock )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_OPEN_COLLECT;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam  = 0;
	smTransCommand.LParam  = 0;
	smTransCommand.SParam  = 0;

	return lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
}

//경품이벤트
int SendOpenEventGift( smWINSOCK *lpsmSock )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_OPEN_EVENTGIFT;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam  = 0;
	smTransCommand.LParam  = 0;
	smTransCommand.SParam  = 0;

	return lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
}


//선물 배달
int SendOpenGiftExpress( rsPLAYINFO *lpPlayInfo , DWORD	dwItemCode , DWORD dwPassCode_Param )
{
	if ( rsLoadPostBox( lpPlayInfo )==FALSE ) return FALSE;
	if ( !lpPlayInfo->lpPostBoxItem ) return FALSE;
	TRANS_CHATMESSAGE	TransChatMessage;

	if ( lpPlayInfo->PostPassFailCount>=5 ) {
		//아이템 배달 비밀번호 연속 5회 이상 틀린 경우 작동 중지

		lstrcpy( TransChatMessage.szMessage , srMsg_301 );
		TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return FALSE;
	}

	char	szBuff[ sizeof(TRANS_POST_ITEM)+sizeof(sITEMINFO)+64 ];
	TRANS_POST_ITEM	*lpTransPostItem = (TRANS_POST_ITEM *)szBuff;
	sITEMINFO *lpItem = (sITEMINFO *)(szBuff+sizeof(TRANS_POST_ITEM));
	int		cnt,cnt2;
	psITEM	psItem;
	int		spJobCode;
	DWORD	dwPassCode;
	DWORD	dwFormCode;
	char	*szPassCode;

	ZeroMemory( lpTransPostItem , sizeof(TRANS_POST_ITEM) );

	lpTransPostItem->code = smTRANSCODE_ITEM_EXPRESS;

	if ( dwItemCode ) {
		spJobCode = 0;
		dwPassCode = 0;
		dwFormCode = 0;
		szPassCode = 0;

		for(cnt=0;cnt<lpPlayInfo->lpPostBoxItem->ItemCounter;cnt++) {
			if ( lpPlayInfo->lpPostBoxItem->PostItem[cnt].Flag &&
				lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwItemCode==dwItemCode &&
				(lpPlayInfo->lpPostBoxItem->PostItem[cnt].szCharName[0]=='*' || 
				 lstrcmpi( lpPlayInfo->szName , lpPlayInfo->lpPostBoxItem->PostItem[cnt].szCharName )==0)	) {

				spJobCode = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwJobCode;
				dwFormCode = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwFormCode;
				dwPassCode = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwPassCode;
				szPassCode = lpPlayInfo->lpPostBoxItem->PostItem[cnt].szPassCode;

				if ( dwPassCode && dwPassCode!=dwPassCode_Param ) {
					//비밀 번호 틀림 ( 핸드폰 번호 )
					cnt = lpPlayInfo->lpPostBoxItem->ItemCounter;
					lpPlayInfo->PostPassFailCount ++;

					lstrcpy( TransChatMessage.szMessage , srMsg_300 );
					TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
					TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
					TransChatMessage.dwIP = 0;
					TransChatMessage.dwObjectSerial = 0;
					lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

					break;
				}

				lpPlayInfo->lpPostBoxItem->PostItem[cnt].Flag = 0;
				break;
			}
		}
		if ( cnt<lpPlayInfo->lpPostBoxItem->ItemCounter ) {

			lpPlayInfo->PostPassFailCount = 0;

			if ( dwItemCode==(sinGG1|sin01) ) {
				lpTransPostItem->dwItemFlag = TRUE;
				ZeroMemory( lpItem , sizeof(sITEMINFO) );
				lpItem->CODE = sinGG1|sin01;			//돈이다
				lpItem->Money = spJobCode;				//금액
				ReformItem( lpItem );					//아이템 인증
				lpPlayInfo->AddServerMoney ( spJobCode , WHERE_GIFT_EXPRESS );	//서버측 보유돈 추가

				//아이템 로그 증정 아이템
				rsRecord_ItemLog_Post( lpPlayInfo , lpItem->CODE , 0 , spJobCode , dwFormCode , szPassCode , ITEMLOG_EXPRESS );

			}
			else if ( dwItemCode==(sinGG1|sin02) ) {
				lpTransPostItem->dwItemFlag = TRUE;
				ZeroMemory( lpItem , sizeof(sITEMINFO) );
				lpItem->CODE = sinGG1|sin02;			//경험치
				lpItem->Money = spJobCode;				//금액
				ReformItem( lpItem );					//아이템 인증
				lpPlayInfo->dwGameServerExp[ rsServerConfig.ServerCode ] += spJobCode;	//서버측 경험치 추가

				//아이템 로그 증정 아이템
				rsRecord_ItemLog_Post( lpPlayInfo , lpItem->CODE , 0 , spJobCode , dwFormCode , szPassCode , ITEMLOG_EXPRESS );
			}
			else {
				for(cnt=0;cnt<DefaultItemCount;cnt++) {
					if ( DefaultItems[cnt].Item.CODE==dwItemCode && !DefaultItems[cnt].Item.UniqueItem ) {
						CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt] , spJobCode , 1 );
						lpTransPostItem->dwItemFlag = TRUE;
						memcpy( lpItem , &psItem.ItemInfo , sizeof(sITEMINFO) );

						if ( (dwItemCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
							//물약
							lpItem->PotionCount = spJobCode;			//물약 갯수 설정

							rsAddServerPotion( lpPlayInfo , dwItemCode , lpItem->PotionCount );	//서버포션 기록

							//아이템 로그 증정 아이템
							rsRecord_ItemLog_Post( lpPlayInfo , lpItem->CODE , 0 , spJobCode , dwFormCode , szPassCode , ITEMLOG_EXPRESS );
						}
						else {
							//인벤 아이템 추가
							rsAddInvenItem( lpPlayInfo , lpItem->CODE , lpItem->ItemHeader.Head , lpItem->ItemHeader.dwChkSum );

							//아이템 로그 증정 아이템
							rsRecord_ItemLog_Post( lpPlayInfo , lpItem->CODE , lpItem->ItemHeader.Head , lpItem->ItemHeader.dwChkSum , 
								dwFormCode , szPassCode , ITEMLOG_EXPRESS );

						}

						break;
					}
				}
			}
		}
	}


	for(cnt=0;cnt<lpPlayInfo->lpPostBoxItem->ItemCounter;cnt++) {
		if ( lpPlayInfo->lpPostBoxItem->PostItem[cnt].Flag &&
			(lpPlayInfo->lpPostBoxItem->PostItem[cnt].szCharName[0]=='*' || 
		     lstrcmpi( lpPlayInfo->szName , lpPlayInfo->lpPostBoxItem->PostItem[cnt].szCharName )==0)	) {	

			if ( lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwItemCode==(sinGG1|sin01) ||
				lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwItemCode==(sinGG1|sin02) ) {

					lstrcpy( lpTransPostItem->szItemName , lpPlayInfo->lpPostBoxItem->PostItem[cnt].szItemCode );	//아이템 이름
					lstrcpy( lpTransPostItem->szDoc , lpPlayInfo->lpPostBoxItem->PostItem[cnt].szDoc  );			//설명

					lpTransPostItem->dwItemCode = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwItemCode;
					lpTransPostItem->dwItemJobCode = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwJobCode;
					lpTransPostItem->dwParam[0] = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwParam[0];
					lpTransPostItem->dwParam[1] = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwParam[1];
					lpTransPostItem->dwParam[2] = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwParam[2];
					lpTransPostItem->dwParam[3] = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwParam[3];
					break;

				}
			else {
				//대기중인 다음 아이템 이름 찾기
				for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
					if ( DefaultItems[cnt2].Item.CODE==lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwItemCode && 
						!DefaultItems[cnt2].Item.UniqueItem ) {
							lstrcpy( lpTransPostItem->szItemName , DefaultItems[cnt2].Item.ItemName );				//아이템 이름
							lstrcpy( lpTransPostItem->szDoc , lpPlayInfo->lpPostBoxItem->PostItem[cnt].szDoc  );	//설명

							lpTransPostItem->dwItemCode = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwItemCode;
							lpTransPostItem->dwItemJobCode = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwJobCode;
							lpTransPostItem->dwParam[0] = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwParam[0];
							lpTransPostItem->dwParam[1] = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwParam[1];
							lpTransPostItem->dwParam[2] = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwParam[2];
							lpTransPostItem->dwParam[3] = lpPlayInfo->lpPostBoxItem->PostItem[cnt].dwParam[3];
							break;
						}
				}
				if ( cnt2<DefaultItemCount ) break;
			}
		}
	}


	lpTransPostItem->size = sizeof(TRANS_POST_ITEM);
	if ( lpTransPostItem->dwItemFlag ) lpTransPostItem->size+=sizeof(sITEMINFO);

	if ( lpPlayInfo->lpsmSock || ( lpTransPostItem->dwItemCode || lpTransPostItem->dwItemFlag ) ) {
		lpPlayInfo->lpsmSock->Send2( (char *)lpTransPostItem , lpTransPostItem->size , TRUE );
	}

	return TRUE;
}


//에이징 창 열기
int SendOpenAgingItem( smWINSOCK *lpsmSock )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_OPEN_AGING;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam  = 0;
	smTransCommand.LParam  = 0;
	smTransCommand.SParam  = 0;

	return lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
}

//배드 플레이어 게임서버에 설정
int rsSend_BadPlayerToGameServer( smWINSOCK *lpsmSock , int BadPlayer )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_BAD_PLAYER;
	smTransCommand.size = sizeof( smTRANS_COMMAND );
	smTransCommand.WParam = BadPlayer;
	smTransCommand.LParam = 0;
	smTransCommand.SParam = 0;
	smTransCommand.EParam = 0;

	return rsSendGameServer( lpsmSock , &smTransCommand );
}

//배드 플레이어 게임서버에 설정
int rsSend_PlayerKilling( smWINSOCK *lpsmSock )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_PLAYERKILLING;
	smTransCommand.size = sizeof( smTRANS_COMMAND );
	smTransCommand.WParam = 0;
	smTransCommand.LParam = 0;
	smTransCommand.SParam = 0;
	smTransCommand.EParam = 0;

	if ( lpsmSock )
		return lpsmSock->Send2( (char *)&smTransCommand , sizeof(smTRANS_COMMAND),  TRUE );

	return FALSE;
}


//클랜 메뉴 열기
int SendOpenClanMenu( smWINSOCK *lpsmSock )
{
	smTRANS_COMMAND		smTransCommand;

	smTransCommand.code = smTRANSCODE_OPEN_CLANMENU;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam  = 0;
	smTransCommand.LParam  = 0;
	smTransCommand.SParam  = 0;

	return lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
}

//퀘스트 진행 처리
int rsProcessQuest( rsPLAYINFO *lpPlayInfo , smCHAR *lpChar , int QuestCode , int QuestParam )
{
	smTRANS_COMMAND	smTransCommand;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	smTransCommand.code = smTRANSCODE_QUEST_MESSAGE;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam = lpChar->smMonsterInfo.QuestCode;
	smTransCommand.LParam = lpChar->smMonsterInfo.QuestParam;
	smTransCommand.SParam = 0;
	smTransCommand.EParam = 0;

	switch( QuestCode ) {
		case SIN_QUEST_CODE_CHANGEJOB2_NPC_M:
		case SIN_QUEST_CODE_CHANGEJOB2_NPC_D:
			//모리이온 전업 벌꿀 퀘스트 시작
			if ( QuestParam==1 ) {
				//아이템 특정 유저의 인벤토리보냄
				smTransCommand.SParam = rsPutItem( lpPlayInfo , sinMA1|sin01 );
			}
			break;

		case SIN_QUEST_CODE_CHANGEJOB4:
		case HAQUEST_CODE_FURYOFPHANTOM:
			smTransCommand.WParam = QuestCode;
			smTransCommand.LParam = QuestParam;
			break;
	}

	lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

	return TRUE;
}

//퀘스트 진행 처리
int rsGetQuestCommand( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	DWORD dwItemCode;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	switch( lpTransCommand->WParam ) {
		case SIN_QUEST_CODE_LEVEL85:
			//아이템 특정 유저의 인벤토리보냄
			if ( lpPlayInfo->smCharInfo.Level>=85 )
				rsPutItem( lpPlayInfo , sinQT1|sin08 );
			break;
		case SIN_QUEST_CODE_LEVEL90:
			//아이템 특정 유저의 인벤토리보냄
			if ( lpPlayInfo->smCharInfo.Level>=90 )
				rsPutItem( lpPlayInfo , sinQT1|sin07 );
			break;

		case SIN_QUEST_CODE_CHANGEJOB4:		
			if ( lpPlayInfo->smCharInfo.Level>=49 && lpTransCommand->LParam==QUEST_ARENA_FIELD ) {
				//퀘스트용 마스터 대전방 호출
				OpenMonster_QuestArena( lpPlayInfo , SIN_QUEST_CODE_CHANGEJOB4 );
			}
			break;

		case HAQUEST_CODE_FURYOFPHANTOM:		
			if ( lpPlayInfo->smCharInfo.Level>=99 && lpTransCommand->LParam==QUEST_ARENA_FIELD ) {
				//퀘스트용 마스터 대전방 호출
				OpenMonster_QuestArena( lpPlayInfo , HAQUEST_CODE_FURYOFPHANTOM , lpTransCommand->SParam );
			}
			break;

	}

#include "svrHaQuest.h"			//HAQUEST 아이템 지급 소스 파일

	return TRUE;
}



//클라이언트의 아이템 제거
int	rsDeleteClientItem( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpItem )
{
	TRANS_ITEM_CODE	TransItemCode;

	//오류 아이템 판정 제거 요구
	TransItemCode.code = smTRANSCODE_ERRORITEM;
	TransItemCode.size = sizeof(TRANS_ITEM_CODE);
	TransItemCode.dwFlag = FALSE;
	TransItemCode.dwHead = lpItem->ItemHeader.Head;
	TransItemCode.dwChkSum = lpItem->ItemHeader.dwChkSum;
	TransItemCode.dwItemCode = lpItem->CODE;
	TransItemCode.dwTime = 0;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)&TransItemCode , TransItemCode.size , TRUE );
	}

	return TRUE;
}


//클라이언트의 아이템 제거
int	rsDeleteClientItem( rsPLAYINFO *lpPlayInfo , DWORD dwCode ,DWORD dwHead , DWORD dwChkSum )
{
	TRANS_ITEM_CODE	TransItemCode;

	//오류 아이템 판정 제거 요구
	TransItemCode.code = smTRANSCODE_ERRORITEM;
	TransItemCode.size = sizeof(TRANS_ITEM_CODE);
	TransItemCode.dwFlag = FALSE;
	TransItemCode.dwHead = dwHead;
	TransItemCode.dwChkSum = dwChkSum;
	TransItemCode.dwItemCode = dwCode;
	TransItemCode.dwTime = 0;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)&TransItemCode , TransItemCode.size , TRUE );
	}

	return TRUE;
}

//에이징 아이템 업그레이드
int rsRecvAgingUpgradeItem( rsPLAYINFO	*lpPlayInfo , TRANS_ITEMINFO *lpTransItemInfo )
{
	sITEMINFO sItemInfo;

	if ( CheckItemForm( &lpTransItemInfo->Item )==FALSE ) return FALSE;

	//서버 이벤 아이템 수정
	if ( rsDeleteInvenItem( lpPlayInfo , lpTransItemInfo->Item.CODE , lpTransItemInfo->Item.ItemHeader.Head , lpTransItemInfo->Item.ItemHeader.dwChkSum )<0 )
		return FALSE;


	memcpy( &sItemInfo , &lpTransItemInfo->Item , sizeof( sITEMINFO ) );

	lpTransItemInfo->Item.dwCreateTime = 0;
	sinSetAgingItemIncreState( &lpTransItemInfo->Item );

	//서버 인벤 아이템 추가
	rsAddInvenItem( lpPlayInfo , lpTransItemInfo->Item.CODE , lpTransItemInfo->Item.ItemHeader.Head , lpTransItemInfo->Item.ItemHeader.dwChkSum );

	//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
	rsSaveAgingItemToHDD( &lpTransItemInfo->Item );

	//아이템 에이징 기록
	RecordAgingItem( lpPlayInfo , &sItemInfo , &lpTransItemInfo->Item , TRUE );

	//아이템 로그 믹스쳐 및 에이징으로 변경된 아이템 ( 출/입 기록 )
	rsRecord_ItemLog_Change( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum , 
			lpTransItemInfo->Item.CODE , lpTransItemInfo->Item.ItemHeader.Head , lpTransItemInfo->Item.ItemHeader.dwChkSum , ITEMLOG_AGINGUP );


	return lpPlayInfo->lpsmSock->Send2( (char *)lpTransItemInfo , lpTransItemInfo->size , TRUE );
}

//에이징 실행
int rsRecvAgingItem( rsPLAYINFO *lpPlayInfo , sCRAFTITEM_SERVER *pCraftItem_Server )
{
	cAGING		ccItem;
	sITEMINFO	sItemInfo;
	smTRANS_COMMAND	smTransCommand;
	smTRANS_COMMAND_EX	smTransCommandEx;
	//TRANS_ITEM_CODE	TransItemCode;
	int cnt;
	int	ErrorFlag;
	int Price;
	int	QuestMode;
	int	AgingCnt,AgingLog;

/*
#ifdef _LANGUAGE_CHINESE
	//중국 에이징 금지
	smTransCommand.WParam = 99000;
	smTransCommand.SParam = 0;
	smTransCommand.LParam = 1;
	RecordHackLogFile( lpPlayInfo , &smTransCommand );
*/
/*
	//오류 아이템 판정 제거 요구
	TransItemCode.code = smTRANSCODE_ERRORITEM;
	TransItemCode.size = sizeof(TRANS_ITEM_CODE);
	TransItemCode.dwFlag = FALSE;
	TransItemCode.dwHead = pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.Head;
	TransItemCode.dwChkSum = pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.dwChkSum;
	TransItemCode.dwItemCode = pCraftItem_Server->DesCraftItem.sItemInfo.CODE;
	TransItemCode.dwTime = 0;
	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)&TransItemCode , TransItemCode.size , TRUE );
	}
*/
//	return TRUE;
//#endif

	ErrorFlag = 0;

	//아이템 로그 일반 믹스쳐,에이징에 사용된 쉘텀 
	rsRecord_ItemLost( lpPlayInfo , pCraftItem_Server->SheltomCode , pCraftItem_Server->Head , pCraftItem_Server->CheckSum , ITEMLOG_AGINGLOST );

	for( cnt=0;cnt<12;cnt++ ) {
		//던져진 아이템 저장
		if ( pCraftItem_Server->SheltomCode[cnt] ) {

			//서버 이벤 아이템 수정
			if ( rsDeleteInvenItem( lpPlayInfo , pCraftItem_Server->SheltomCode[cnt] ,
				pCraftItem_Server->Head[cnt], pCraftItem_Server->CheckSum[cnt] )<0 ) {

					//로그에 기록
					smTransCommandEx.WParam = 8000;
					smTransCommandEx.WxParam = 70;
					smTransCommandEx.LxParam = (int)"*AGING SHELTON*";
					smTransCommandEx.LParam = pCraftItem_Server->SheltomCode[cnt];
					smTransCommandEx.SParam = pCraftItem_Server->Head[cnt];
					smTransCommandEx.EParam = pCraftItem_Server->CheckSum[cnt];
					RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
					ErrorFlag ++;

					pCraftItem_Server->SheltomCode[cnt] = 0;			//쉘텀제거
				}
/*
			else {
				//아이템이 복사 아이템인지 확인
				if ( pCraftItem_Server->DesCraftItem.sItemInfo.ItemAgingNum[0]>=3 && rsCheckCopiedItem( pCraftItem_Server->SheltomCode[cnt] , pCraftItem_Server->Head[cnt] , pCraftItem_Server->CheckSum[cnt] )==TRUE ) {
					//복사된 쉘텀
					smTransCommandEx.WParam = 8200;
					smTransCommandEx.LParam = pCraftItem_Server->SheltomCode[cnt];
					smTransCommandEx.SParam = pCraftItem_Server->Head[cnt];
					smTransCommandEx.EParam = pCraftItem_Server->CheckSum[cnt];
					RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
					ErrorFlag ++;

					pCraftItem_Server->SheltomCode[cnt] = 0;			//쉘텀제거
				}
			}
*/
			SaveThrowItem( lpPlayInfo , pCraftItem_Server->SheltomCode[cnt], 
				pCraftItem_Server->Head[cnt], pCraftItem_Server->CheckSum[cnt] );
		}
	}

	memcpy( &sItemInfo , &pCraftItem_Server->DesCraftItem.sItemInfo , sizeof( sITEMINFO ) );
/*
	//아이템이 복사 아이템인지 확인
	if (sItemInfo.ItemAgingNum[0]>=3 && rsCheckCopiedItem( &sItemInfo )==TRUE ) {
		//복사된 아이템 에이징 시도
		smTransCommandEx.WParam = 8210;
		smTransCommandEx.LParam = sItemInfo.CODE;
		smTransCommandEx.SParam = sItemInfo.ItemHeader.Head;
		smTransCommandEx.EParam = sItemInfo.ItemHeader.dwChkSum;
		smTransCommandEx.SxParam = sItemInfo.BackUpKey;
		smTransCommandEx.ExParam = sItemInfo.BackUpChkSum;
		RecordHackLogFile( lpPlayInfo , &smTransCommandEx );

		ErrorFlag ++;		//에이징 실패시킴
	}
*/

	Price = ((sItemInfo.ItemAgingNum[0]+1) * sItemInfo.Price)/2;

	CurrencyLog.int64_AgingMoney += Price;			//통화량 기록

	if ( rsServerConfig.ServerInventoryMode && sItemInfo.ItemKindCode!=ITEM_KIND_QUEST_WEAPON ) {
		if ( lpPlayInfo->ServerMoney<Price ) {
			//돈부족
			smTransCommand.WParam = 8010;
			smTransCommand.LParam = 70;
			smTransCommand.SParam = lpPlayInfo->ServerMoney;
			smTransCommand.EParam = Price;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );

			lpPlayInfo->SetServerMoney( 0 , WHERE_AGINGITEM );
			ErrorFlag ++;
		}
		else {
			lpPlayInfo->SubServerMoney ( Price , WHERE_AGINGITEM );
			lpPlayInfo->UnsaveMoney = lpPlayInfo->ServerMoney;
		}
	}

	if ( CheckItemForm( &sItemInfo )==FALSE || CheckMixItem(&sItemInfo )==FALSE ) {
		//아이템 오류

		sAging_Recv.Result = FALSE;
		sAging_Recv.size = 32;
		if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
			lpPlayInfo->lpsmSock->Send2( (char *)&sAging_Recv , sAging_Recv.size , TRUE );
		}

		//믹스쳐 아이템 조작 오류
		smTransCommand.WParam = 99000;
		smTransCommand.SParam = 0;
		smTransCommand.LParam = 1;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		return TRUE;
	}

	if ( (sItemInfo.CODE&sinITEM_MASK2)==sinMA1 ) 
		QuestMode = TRUE; 
	else {
		if ( lpPlayInfo->AdminMode==10 )		//에이징 완벽 성공
			QuestMode = -1;
		else
			QuestMode = FALSE;
	}

	//에이징 스톤 검사
	if ( pCraftItem_Server->A_StoneItemCode ) {
		if ( ( pCraftItem_Server->A_StoneItemCode==(sinBI1|sin10) || pCraftItem_Server->A_StoneItemCode==(sinBI1|sin11) ) && 
			rsDeleteInvenItem( lpPlayInfo , 
						pCraftItem_Server->A_StoneItemCode , 
						pCraftItem_Server->A_StoneHead ,
						pCraftItem_Server->A_StoneCheckSum )>=0 )
		{
			//아이템 로그 에이징스톤 분실 기록
			rsRecord_ItemLog2( lpPlayInfo , pCraftItem_Server->A_StoneItemCode , pCraftItem_Server->A_StoneHead , pCraftItem_Server->A_StoneCheckSum , ITEMLOG_AGINGLOST );

			SaveThrowItem( lpPlayInfo , 
				pCraftItem_Server->A_StoneItemCode , pCraftItem_Server->A_StoneHead , pCraftItem_Server->A_StoneCheckSum );
		}
		else {

			//로그에 기록 ( 잘못된 에이징 스톤 )
			smTransCommandEx.WParam = 8000;
			smTransCommandEx.WxParam = 70;
			smTransCommandEx.LxParam = (int)"Aging Stone";
			smTransCommandEx.LParam = pCraftItem_Server->A_StoneItemCode;
			smTransCommandEx.SParam = pCraftItem_Server->A_StoneHead;
			smTransCommandEx.EParam = pCraftItem_Server->A_StoneCheckSum;
			RecordHackLogFile( lpPlayInfo , &smTransCommandEx );

			pCraftItem_Server->A_StoneItemCode = 0;
		}
	}
	else {
		pCraftItem_Server->A_StoneItemCode = 0;
	}

	ccItem.sinRecvAgingItem( pCraftItem_Server );
	cnt = ccItem.AgingItem( QuestMode );

	//에러난경우 에이징 실패시킴
	if ( ErrorFlag ) sAging_Recv.Result=FALSE;

	//서버 이벤 아이템 수정
	if ( rsDeleteInvenItem( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum )<0 ) {

		sAging_Recv.size = 32;
		sAging_Recv.Result = FALSE;

		//로그에 기록
		smTransCommandEx.WParam = 8000;
		smTransCommandEx.WxParam = 70;
		smTransCommandEx.LxParam = (int)sItemInfo.ItemName;
		smTransCommandEx.LParam = sItemInfo.CODE;
		smTransCommandEx.SParam = sItemInfo.ItemHeader.Head;
		smTransCommandEx.EParam = sItemInfo.ItemHeader.dwChkSum;
		RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
	}

	sAging_Recv.code = smTRANSCODE_AGINGITEM;
	if ( sAging_Recv.Result ) {
		//sAging_Recv.DesCraftItem.sItemInfo.ItemAgingCount[0]=0;		//상렬씨가 초기화 안해서 임시로 했음

		if ( QuestMode==TRUE ) {
			for(cnt=0;cnt<DefaultItemCount;cnt++) {
				if ( DefaultItems[cnt].Item.CODE==sAging_Recv.DesCraftItem.sItemInfo.CODE ) {
					CreateDefItem( &sAging_Recv.DesCraftItem.sItemInfo , &DefaultItems[cnt] );
					break;
				}
			}
		}

		ReformItem( &sAging_Recv.DesCraftItem.sItemInfo);  //아이템 인증 받기 ( 다시 받기 )
		sAging_Recv.size = sizeof(sITEM)+32;

		rsAddInvenItem( lpPlayInfo , sAging_Recv.DesCraftItem.sItemInfo.CODE ,
			sAging_Recv.DesCraftItem.sItemInfo.ItemHeader.Head ,
			sAging_Recv.DesCraftItem.sItemInfo.ItemHeader.dwChkSum );

		if ( QuestMode!=TRUE ) {
			//아이템 에이징 기록
			RecordAgingItem( lpPlayInfo , &sItemInfo , &sAging_Recv.DesCraftItem.sItemInfo , FALSE );

			AgingCnt = sAging_Recv.DesCraftItem.sItemInfo.ItemAgingNum[0] - sItemInfo.ItemAgingNum[0];
			AgingLog = ITEMLOG_AGING;

			switch( sAging_Recv.Result ) {
				case 4:		//2배
					AgingLog = ITEMLOG_AGING_2UP;
					break;
				case 3:		//성공
					AgingLog = ITEMLOG_AGING;
					break;
				//case 0:
				//	AgingLog = ITEMLOG_AGING_KEEP;
				//	break;
				case 1:		//에이징 -1
					AgingLog = ITEMLOG_AGING_1DOWN;
					break;
				case 2:		//에이징 -2
					AgingLog = ITEMLOG_AGING_2DOWN;
					break;
			}

			//아이템 로그 믹스쳐 및 에이징으로 변경된 아이템 ( 출/입 기록 )
			rsRecord_ItemLog_Change( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum , 
					sAging_Recv.DesCraftItem.sItemInfo.CODE , sAging_Recv.DesCraftItem.sItemInfo.ItemHeader.Head , sAging_Recv.DesCraftItem.sItemInfo.ItemHeader.dwChkSum ,	AgingLog );

			//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
			rsSaveAgingItemToHDD( &sAging_Recv.DesCraftItem.sItemInfo );
		}

		SaveThrowItem( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum );

	}
	else {
		sAging_Recv.size = 32;

		if ( QuestMode!=TRUE ) {
			//아이템 에이징 기록 ( 실패 )
			RecordAgingItem( lpPlayInfo , &sItemInfo , 0 , FALSE );

			//아이템 로그 에이징 분실 기록
			rsRecord_ItemLog2( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum , ITEMLOG_AGINGLOST );
		}
	}

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)&sAging_Recv , sAging_Recv.size , TRUE );
	}

	return TRUE;
}


//믹스쳐를 실행
int rsRecvCraftItem( rsPLAYINFO *lpPlayInfo , sCRAFTITEM_SERVER *pCraftItem_Server )
{

	cCRAFTITEM	ccItem;
	sITEMINFO	sItemInfo;
	smTRANS_COMMAND	smTransCommand;
	smTRANS_COMMAND_EX	smTransCommandEx;
	//TRANS_ITEM_CODE	TransItemCode;
	int cnt;
	int	ErrorFlag;
	int Result;
	DWORD ItemCraftType = 0;
/*
#ifdef _LANGUAGE_CHINESE

	//중국 믹스쳐 금지
	smTransCommand.WParam = 99000;
	smTransCommand.SParam = 0;
	smTransCommand.LParam = 0;
	RecordHackLogFile( lpPlayInfo , &smTransCommand );
	return TRUE;

#endif

*/

	//sinSE1
	ErrorFlag = 0;

	for( cnt=0;cnt<12;cnt++ ) {
		if ( (pCraftItem_Server->SheltomCode[cnt]&sinITEM_MASK2)==sinSE1 ) {
			ItemCraftType = sinSE1;
			break;
		}
	}


	if ( ItemCraftType==sinSE1 ) {
		//아이템 로그 일반 재구성
		rsRecord_ItemLost( lpPlayInfo , pCraftItem_Server->SheltomCode , pCraftItem_Server->Head , pCraftItem_Server->CheckSum , ITEMLOG_LOST_RECON );
	}
	else {
		//아이템 로그 일반 믹스쳐,에이징에 사용된 쉘텀 
		rsRecord_ItemLost( lpPlayInfo , pCraftItem_Server->SheltomCode , pCraftItem_Server->Head , pCraftItem_Server->CheckSum , ITEMLOG_MIXLOST );
	}

	for( cnt=0;cnt<12;cnt++ ) {
		//던져진 아이템 저장
		if ( pCraftItem_Server->SheltomCode[cnt] ) {

			//서버 이벤 아이템 수정
			if ( rsDeleteInvenItem( lpPlayInfo , pCraftItem_Server->SheltomCode[cnt] ,
				pCraftItem_Server->Head[cnt], pCraftItem_Server->CheckSum[cnt] )<0 ) {

					//로그에 기록
					smTransCommandEx.WParam = 8000;
					smTransCommandEx.WxParam = 50;
					smTransCommandEx.LxParam = (int)"*MIXTRUE SHELTON*";
					smTransCommandEx.LParam = pCraftItem_Server->SheltomCode[cnt];
					smTransCommandEx.SParam = pCraftItem_Server->Head[cnt];
					smTransCommandEx.EParam = pCraftItem_Server->CheckSum[cnt];
					RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
					ErrorFlag ++;

					pCraftItem_Server->SheltomCode[cnt] = 0;			//쉘텀제거
				}

			SaveThrowItem( lpPlayInfo , pCraftItem_Server->SheltomCode[cnt], 
				pCraftItem_Server->Head[cnt], pCraftItem_Server->CheckSum[cnt] );
		}
	}

	memcpy( &sItemInfo , &pCraftItem_Server->DesCraftItem.sItemInfo , sizeof( sITEMINFO ) );

	CurrencyLog.int64_CraftMoney += sItemInfo.Price;		//통화량 기록

	if ( rsServerConfig.ServerInventoryMode ) {
		if ( lpPlayInfo->ServerMoney<sItemInfo.Price ) {
			//돈부족
			smTransCommand.WParam = 8010;
			smTransCommand.LParam = 50;
			smTransCommand.SParam = lpPlayInfo->ServerMoney;
			smTransCommand.EParam = sItemInfo.Price;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );

			lpPlayInfo->SetServerMoney( 0 , WHERE_CRAFTITEM );
			ErrorFlag ++;
		}
		else {
			lpPlayInfo->SubServerMoney ( sItemInfo.Price , WHERE_CRAFTITEM );
			lpPlayInfo->UnsaveMoney = lpPlayInfo->ServerMoney;
		}
	}


	if ( CheckItemForm( &sItemInfo )==FALSE || sItemInfo.ItemKindCode!=0 || CheckMixItem(&sItemInfo )==FALSE ) {
		//아이템 오류

		sCraftItem_Recv.Result = FALSE;
		sCraftItem_Recv.size = 32;
		if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
			lpPlayInfo->lpsmSock->Send2( (char *)&sCraftItem_Recv , sCraftItem_Recv.size , TRUE );
		}

		//믹스쳐 아이템 조작 오류
		smTransCommand.WParam = 99000;
		smTransCommand.SParam = 0;
		smTransCommand.LParam = 0;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
/*
		//오류 아이템 판정 제거 요구
		TransItemCode.code = smTRANSCODE_ERRORITEM;
		TransItemCode.size = sizeof(TRANS_ITEM_CODE);
		TransItemCode.dwFlag = FALSE;
		TransItemCode.dwHead = pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.Head;
		TransItemCode.dwChkSum = pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.dwChkSum;
		TransItemCode.dwItemCode = pCraftItem_Server->DesCraftItem.sItemInfo.CODE;
		TransItemCode.dwTime = 0;
		if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
			lpPlayInfo->lpsmSock->Send2( (char *)&TransItemCode , TransItemCode.size , TRUE );
		}
*/
		return TRUE;
	}


	ccItem.sinRecvCraftItem( pCraftItem_Server );
	Result = ccItem.MixingItem();

	//에러난경우 믹스쳐 실패시킴
	if ( ErrorFlag ) sCraftItem_Recv.Result=FALSE;

	if ( Result==2000 ) {
		//아이템 재정의
		for(cnt=0;cnt<DefaultItemCount;cnt++) {
			if ( DefaultItems[cnt].Item.CODE==sCraftItem_Recv.DesCraftItem.sItemInfo.CODE && !DefaultItems[cnt].Item.UniqueItem ) {
				CreateDefItem( &sCraftItem_Recv.DesCraftItem.sItemInfo , &DefaultItems[cnt] );
				break;
			}
		}
	}

	sCraftItem_Recv.code = smTRANSCODE_CRAFTITEM;
	if ( sCraftItem_Recv.Result==TRUE ) {
		ReformItem( &sCraftItem_Recv.DesCraftItem.sItemInfo);  //아이템 인증 받기 ( 다시 받기 )
		sCraftItem_Recv.size = sizeof(sITEM)+32;


		//서버 이벤 아이템 수정
		if ( rsDeleteInvenItem( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum )>=0 ) {
			rsAddInvenItem( lpPlayInfo , sCraftItem_Recv.DesCraftItem.sItemInfo.CODE ,
				sCraftItem_Recv.DesCraftItem.sItemInfo.ItemHeader.Head ,
				sCraftItem_Recv.DesCraftItem.sItemInfo.ItemHeader.dwChkSum );

			//아이템 믹스 기록
			RecordMixItem( lpPlayInfo , &sItemInfo , &sCraftItem_Recv.DesCraftItem.sItemInfo );

			if ( ItemCraftType==sinSE1 ) {
				//아이템 로그 재구성으로 변경된 아이템 ( 출/입 기록 )
				rsRecord_ItemLog_Change( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum , 
						sCraftItem_Recv.DesCraftItem.sItemInfo.CODE , sCraftItem_Recv.DesCraftItem.sItemInfo.ItemHeader.Head , sCraftItem_Recv.DesCraftItem.sItemInfo.ItemHeader.dwChkSum ,	ITEMLOG_GET_RECON );
			}
			else {
				//아이템 로그 믹스쳐 및 에이징으로 변경된 아이템 ( 출/입 기록 )
				rsRecord_ItemLog_Change( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum , 
						sCraftItem_Recv.DesCraftItem.sItemInfo.CODE , sCraftItem_Recv.DesCraftItem.sItemInfo.ItemHeader.Head , sCraftItem_Recv.DesCraftItem.sItemInfo.ItemHeader.dwChkSum ,	ITEMLOG_MIXING );
			}

			//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
			rsSaveAgingItemToHDD( &sCraftItem_Recv.DesCraftItem.sItemInfo );


		}
		else {
			sCraftItem_Recv.size = 32;
			sCraftItem_Recv.Result = FALSE;

			//로그에 기록
			smTransCommandEx.WParam = 8000;
			smTransCommandEx.WxParam = 50;
			smTransCommandEx.LxParam = (int)sItemInfo.ItemName;
			smTransCommandEx.LParam = sItemInfo.CODE;
			smTransCommandEx.SParam = sItemInfo.ItemHeader.Head;
			smTransCommandEx.EParam = sItemInfo.ItemHeader.dwChkSum;
			RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
		}
		SaveThrowItem( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum );

	}
	else {
		sCraftItem_Recv.size = 32;
	}

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)&sCraftItem_Recv , sCraftItem_Recv.size , TRUE );
	}

	return TRUE;
}

// pluto 제련 데이타 받음
int rsRecvSmeltingItem( rsPLAYINFO *lpPlayInfo, sSMELTINGITEM_SERVER *pSmeltingItem_Server )
{
	CSmeltingItem ccItem;
	//sITEMINFO	sItemInfo;
	//smTRANS_COMMAND	smTransCommand;
	smTRANS_COMMAND_EX	smTransCommandEx;

	int cnt;
	int	ErrorFlag;
	//int Result;
	DWORD ItemSmeltingType = 0;

	bool bFirst_Ore = TRUE;	
	bool bOre_OK = TRUE;
	DWORD first_Ore = 0;
	DWORD Next_Ore = 0;
	int ore_num = 0;
	int crystal_num = 0;

	bool bFirst_Sheltom = TRUE;
	bool bSheltom_OK = TRUE;
	DWORD first_Sheltom = 0;
	DWORD Next_Sheltom = 0;

	ErrorFlag = 0;

	//아이템 로그 제련에 사용된 쉘텀 
	rsRecord_SmeltingItemLog( lpPlayInfo , pSmeltingItem_Server->SmeltingCode , pSmeltingItem_Server->Head , pSmeltingItem_Server->CheckSum , ITEMLOG_SMELTING_LOST );
	for( cnt = 0; cnt < 4; cnt++ )
	{
		if( pSmeltingItem_Server->SmeltingCode[cnt] )
		{
			if( (pSmeltingItem_Server->SmeltingCode[cnt] & sinITEM_MASK2) == sinPR1 )	// 광석
			{
				ItemSmeltingType = sinPR1;
				ore_num++; // 4미만 이면 실패다
			}
			else if( (pSmeltingItem_Server->SmeltingCode[cnt] & sinITEM_MASK2) == sinPR2 )	// 수정
			{
				ItemSmeltingType = sinPR2;
				crystal_num++;

			}
			if ( rsDeleteInvenItem( lpPlayInfo , pSmeltingItem_Server->SmeltingCode[cnt],
				pSmeltingItem_Server->Head[cnt], pSmeltingItem_Server->CheckSum[cnt] )<0 )
			{
				if( ItemSmeltingType == sinPR1 )
				{
					//로그에 기록
					smTransCommandEx.WParam = 8000;
					smTransCommandEx.WxParam = 50;
					smTransCommandEx.LxParam = (int)"*SMELTING ORE*";
					smTransCommandEx.LParam = pSmeltingItem_Server->SmeltingCode[cnt];
					smTransCommandEx.SParam = pSmeltingItem_Server->Head[cnt];
					smTransCommandEx.EParam = pSmeltingItem_Server->CheckSum[cnt];
					RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
				}
				else if( ItemSmeltingType == sinPR2 )
				{
					//로그에 기록
					smTransCommandEx.WParam = 8000;
					smTransCommandEx.WxParam = 50;
					smTransCommandEx.LxParam = (int)"*SMELTING CRYSTAL*";
					smTransCommandEx.LParam = pSmeltingItem_Server->SmeltingCode[cnt];
					smTransCommandEx.SParam = pSmeltingItem_Server->Head[cnt];
					smTransCommandEx.EParam = pSmeltingItem_Server->CheckSum[cnt];
					RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
				}
				ErrorFlag ++;

				pSmeltingItem_Server->SmeltingCode[cnt] = 0;			//광석제거
			}
			else
			{
				if( bFirst_Ore )	// 첫 번째 광석만
				{
					first_Ore = pSmeltingItem_Server->SmeltingCode[cnt];
					Next_Ore = pSmeltingItem_Server->SmeltingCode[cnt];
					bFirst_Ore = FALSE;
				}
				else // 두번째 광석부터 쭉~~
				{
					Next_Ore = pSmeltingItem_Server->SmeltingCode[cnt];
				}
				if( first_Ore != Next_Ore ) // 광석 섞여 있으면 실패
				{
					bOre_OK = FALSE;
					ErrorFlag++;
				}
			}
			SaveThrowItem( lpPlayInfo , pSmeltingItem_Server->SmeltingCode[cnt], 
				pSmeltingItem_Server->Head[cnt], pSmeltingItem_Server->CheckSum[cnt] );
		}
	}

	if(  ItemSmeltingType == sinPR1 && ore_num < 4 ) // 광석 4개미만이면 실패다
	{
		bOre_OK = FALSE;
		ErrorFlag++;
	}
	else if(ItemSmeltingType == sinPR2 && crystal_num < 4 ) // 수정 4개미만이면 실패
	{
		bOre_OK = FALSE;
		ErrorFlag++;
	}

	if( pSmeltingItem_Server->SmeltingCode[4] )
	{
		if ( rsDeleteInvenItem( lpPlayInfo , pSmeltingItem_Server->SmeltingCode[4],
			pSmeltingItem_Server->Head[4], pSmeltingItem_Server->CheckSum[4] )<0 )
		{
			//로그에 기록
			smTransCommandEx.WParam = 8000;
			smTransCommandEx.WxParam = 50;
			smTransCommandEx.LxParam = (int)"*SMELTING SHELTON*";
			smTransCommandEx.LParam = pSmeltingItem_Server->SmeltingCode[4];
			smTransCommandEx.SParam = pSmeltingItem_Server->Head[4];
			smTransCommandEx.EParam = pSmeltingItem_Server->CheckSum[4];
			RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
			ErrorFlag ++;

			pSmeltingItem_Server->SmeltingCode[4] = 0;			//쉘텀제거
		}
		if( bFirst_Sheltom )		// 쉘텀 여러개 일때 지금은 필요 없는데... -_- 
		{
			first_Sheltom = pSmeltingItem_Server->SmeltingCode[4];
			Next_Sheltom = pSmeltingItem_Server->SmeltingCode[4];
			bFirst_Sheltom = FALSE;
		}
		else
		{
			Next_Sheltom = pSmeltingItem_Server->SmeltingCode[4];
		}
		if( first_Sheltom != Next_Sheltom ) // 쉘텀 섞여 있으면 실패한다
		{
			bSheltom_OK = FALSE;
			ErrorFlag++;
		}
		SaveThrowItem( lpPlayInfo , pSmeltingItem_Server->SmeltingCode[4], 
			pSmeltingItem_Server->Head[4], pSmeltingItem_Server->CheckSum[4] );
	}


	//memcpy( &sItemInfo , &pSmeltingItem_Server->DesCraftItem.sItemInfo , sizeof( sITEMINFO ) );

	//CurrencyLog.int64_CraftMoney += sItemInfo.Price;		//통화량 기록

	//if ( rsServerConfig.ServerInventoryMode ) {
	//	if ( lpPlayInfo->ServerMoney<sItemInfo.Price ) {
	//		//돈부족
	//		smTransCommand.WParam = 8010;
	//		smTransCommand.LParam = 50;
	//		smTransCommand.SParam = lpPlayInfo->ServerMoney;
	//		smTransCommand.EParam = sItemInfo.Price;
	//		RecordHackLogFile( lpPlayInfo , &smTransCommand );

	//		lpPlayInfo->SetServerMoney( 0 , WHERE_CRAFTITEM );
	//		ErrorFlag ++;
	//	}
	//	else {
	//		lpPlayInfo->SubServerMoney ( sItemInfo.Price , WHERE_CRAFTITEM );
	//		lpPlayInfo->UnsaveMoney = lpPlayInfo->ServerMoney;
	//	}
	//}

	DWORD code = 0;//(sinSE1|sin03);
	if( bOre_OK && bSheltom_OK )
	{
		if( (Next_Ore & sinITEM_MASK2) == sinPR1 )
		{
			if( Next_Ore == (sinPR1|sin01) && Next_Sheltom == (sinOS1|sin06) )		// 보라빛 광석 + 트랜스패로 쉘텀
			{
				code = (sinPR2|sin01);		// 보라빛 수정
			}
			else if( Next_Ore == (sinPR1|sin02) && Next_Sheltom == (sinOS1|sin07) )	// 은빛 광석 + 머키 쉘텀
			{
				code = (sinPR2|sin02);		// 은빛 수정
			}
			else if( Next_Ore == (sinPR1|sin03) && Next_Sheltom == (sinOS1|sin08) )	// 금빛 광석 + 데비네 쉘텀
			{
				code = (sinPR2|sin03);		// 금빛 수정
			}
			else if( Next_Ore == (sinPR1|sin04) && Next_Sheltom == (sinOS1|sin09) )	// 하늘빛 광석 + 쎌레스토 쉘텀
			{
				code = (sinPR2|sin04);		// 하늘빛 수정
			}
			else if( Next_Ore == (sinPR1|sin05) && Next_Sheltom == (sinOS1|sin10) )	// 남빛 광석 + 미라지 쉘텀
			{
				code = (sinPR2|sin05);		// 남빛 수정
			}
			else if( Next_Ore == (sinPR1|sin06) && Next_Sheltom == (sinOS1|sin11) )	// 주황빛 광석 + 인페르나 쉘텀
			{
				code = (sinPR2|sin06);		// 주황빛 수정
			}
			else if( Next_Ore == (sinPR1|sin07) && Next_Sheltom == (sinOS1|sin12) )	// 붉은빛 광석 + 이니그마 쉘텀
			{
				code = (sinPR2|sin07);		// 붉은빛 수정
			}
			else if( Next_Ore == (sinPR1|sin07) && Next_Sheltom == (sinOS1|sin13) )	// 초록빛 광석 + 벨룸 쉘텀
			{
				code = (sinPR2|sin08);		// 초록빛 수정
			}
		}

		else if( (Next_Ore & sinITEM_MASK2) == sinPR2 )
		{
			if( Next_Ore == (sinPR2|sin01) && Next_Sheltom == (sinOS1|sin07) )		// 보라빛 수정 + 머키 쉘텀
			{
				switch( rand()%2 )
				{
					case 0:
						code = (sinPR3|sin01);		// 보라빛 룬(A)
						break;
					case 1:
						code = (sinPR4|sin01);		// 보라빛 룬(B)
						break;
				}
			}
			else if( Next_Ore == (sinPR2|sin02) && Next_Sheltom == (sinOS1|sin08) )	// 은빛수정 + 데비네 쉘텀
			{
				switch( rand()%2 )
				{
					case 0:
						code = (sinPR3|sin02);		// 은빛 룬(A)
						break;
					case 1:
						code = (sinPR4|sin02);		// 은빛 룬(B)
						break;
				}
			}
			else if( Next_Ore == (sinPR2|sin03) && Next_Sheltom == (sinOS1|sin09) )	// 금빛 수정 + 쎌레스토 쉘텀
			{
				switch( rand()%2 )
				{
					case 0:
						code = (sinPR3|sin03);		// 금빛 룬(A)
						break;
					case 1:
						code = (sinPR4|sin03);		// 금빛 룬(B)
						break;
				}
			}
			else if( Next_Ore == (sinPR2|sin04) && Next_Sheltom == (sinOS1|sin10) )	// 하늘빛 수정 + 미라지 쉘텀
			{
				switch( rand()%2 )
				{
					case 0:
						code = (sinPR3|sin04);		// 하늘빛 룬(A)
						break;
					case 1:
						code = (sinPR4|sin04);		// 하늘빛 룬(B)
						break;
				}
			}
			else if( Next_Ore == (sinPR2|sin05) && Next_Sheltom == (sinOS1|sin11) )	// 남빛 수정 + 인페르나 쉘텀
			{
				switch( rand()%2 )
				{
					case 0:
						code = (sinPR3|sin05);		// 남빛 룬(A)
						break;
					case 1:
						code = (sinPR4|sin05);		// 남빛 룬(B)
						break;
				}
			}
			else if( Next_Ore == (sinPR2|sin06) && Next_Sheltom == (sinOS1|sin12) )	// 주황빛 수정 + 이니그마 쉘텀
			{
				switch( rand()%2 )
				{
				case 0:
					code = (sinPR3|sin06);		// 주황빛 룬(A)
					break;
				case 1:
					code = (sinPR4|sin06);		// 주황빛 룬(B)
					break;
				}
			}
			else if( Next_Ore == (sinPR2|sin07) && Next_Sheltom == (sinOS1|sin13) )	// 붉은빛 수정 + 벨룸 쉘텀
			{
				switch( rand()%2 )
				{
					case 0:
						code = (sinPR3|sin07);		// 붉은빛 룬(A)
						break;
					case 1:
						code = (sinPR4|sin07);		// 붉은빛 룬(B)
						break;
				}
			}
			//else if( Next_Ore == (sinPR2|sin08) && Next_Sheltom == (sinOS1|sin14) )	// 초록빛 수정 + 오르도 쉘텀
			//{
			//	switch( rand()%2 )
			//	{
			//	case 0:
			//		code = (sinPR3|sin08);		// 초록빛 룬(A)
			//		break:
			//	case 1:
			//		code = (sinPR4|sin08);		// 초록빛 룬(B)
			//		break;
			//	}
			//}
		}
		else
		{
			ErrorFlag++;
		}

		if( code != 0)
		{
			for(cnt=0;cnt<DefaultItemCount;cnt++)
			{
				if ( DefaultItems[cnt].Item.CODE == code )
				{
					//memcpy( &pSmeltingItem_Server->DesSmeltingItem, &sItem[cnt], sizeof(sITEM));
					CreateDefItem( &pSmeltingItem_Server->DesSmeltingItem.sItemInfo , &DefaultItems[cnt] );
					break;
				}
			}
		}

	}

	ccItem.sinRecvSmeltingItem( pSmeltingItem_Server );	

	if( ErrorFlag )
	{
		sSmeltingItem_Recv.Result = FALSE;
	}
	else
	{
		sSmeltingItem_Recv.Result = TRUE;
	}
	//memcpy( &sSmeltingItem_Recv.DesSmeltingItem.sItemInfo, &psItem.ItemInfo, sizeof(sITEMINFO));
	if( sSmeltingItem_Recv.Result == TRUE )
	{
		ReformItem( &sSmeltingItem_Recv.DesSmeltingItem.sItemInfo );
		sSmeltingItem_Recv.size = sizeof(sITEM)+32;

		rsAddInvenItem( lpPlayInfo , sSmeltingItem_Recv.DesSmeltingItem.sItemInfo.CODE ,
			sSmeltingItem_Recv.DesSmeltingItem.sItemInfo.ItemHeader.Head ,
			sSmeltingItem_Recv.DesSmeltingItem.sItemInfo.ItemHeader.dwChkSum );

		rsRecord_ItemLog2( lpPlayInfo, sSmeltingItem_Recv.DesSmeltingItem.sItemInfo.CODE, sSmeltingItem_Recv.DesSmeltingItem.sItemInfo.ItemHeader.Head,
							sSmeltingItem_Recv.DesSmeltingItem.sItemInfo.ItemHeader.dwChkSum,  ITEMLOG_SMELTING_GET);
		// 제련 기록
		RecordSmeltingItem( lpPlayInfo, &sSmeltingItem_Recv.DesSmeltingItem.sItemInfo );
		
	}
	else
	{
		sSmeltingItem_Recv.size = 32;
	}

	sSmeltingItem_Recv.code = smTRANSCODE_SMELTINGITEM;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock )
	{
		lpPlayInfo->lpsmSock->Send2( (char *)&sSmeltingItem_Recv , sSmeltingItem_Recv.size , TRUE );
	}

	return TRUE;
}

// pluto 제작 아이템 정보
int ManufactureItemInfo( rsPLAYINFO *lpPlayInfo )
{
	DWORD CreateItemCode[144] = {	(sinWA1|sin14), (sinWC1|sin14), (sinWH1|sin15), (sinWP1|sin15), (sinWS1|sin16), (sinWS2|sin17), (sinWT1|sin15), (sinWM1|sin15),  // 잊혀진 레시피 무구
									(sinWA1|sin15), (sinWC1|sin15), (sinWH1|sin16), (sinWP1|sin16), (sinWS1|sin17), (sinWS2|sin18), (sinWT1|sin16), (sinWM1|sin16), // 고대의 레시피 무구
									(sinWA1|sin16), (sinWC1|sin16), (sinWH1|sin17), (sinWP1|sin17), (sinWS1|sin18), (sinWS2|sin19), (sinWT1|sin17), (sinWM1|sin17), // 대지의 무구
									(sinWA1|sin17), (sinWC1|sin17), (sinWH1|sin18), (sinWP1|sin18), (sinWS1|sin19), (sinWS2|sin20), (sinWT1|sin18), (sinWM1|sin18), // 어둠의 레시피 무구
									(sinWA1|sin18), (sinWC1|sin18), (sinWH1|sin19), (sinWP1|sin19), (sinWS1|sin20), (sinWS2|sin21), (sinWT1|sin19), (sinWM1|sin19), // 화염의 레시피 무구
									(sinWA1|sin19), (sinWC1|sin19), (sinWH1|sin20), (sinWP1|sin20), (sinWS1|sin21), (sinWS2|sin22), (sinWT1|sin20), (sinWM1|sin20), // 바람의 레시피 무구
									(sinWA1|sin21), (sinWC1|sin21), (sinWH1|sin22), (sinWP1|sin22), (sinWS1|sin23), (sinWS2|sin24), (sinWT1|sin22), (sinWM1|sin22), // 태양의 레시피 무구
									(sinWA1|sin22), (sinWC1|sin22), (sinWH1|sin23), (sinWP1|sin23), (sinWS1|sin24), (sinWS2|sin25), (sinWT1|sin23), (sinWM1|sin23), // 광포한 레시피 무구
									0, 0, 0, 0, 0, 0, 0, 0, // 천상의 레시피 무구
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									(sinDA1|sin16), (sinDA2|sin16), (sinDS1|sin14), (sinOM1|sin15), (sinDG1|sin14), (sinOA2|sin14), (sinDB1|sin14), 0, // 잊혀진 레시피 갑주
									(sinDA1|sin17), (sinDA2|sin17), (sinDS1|sin15), (sinOM1|sin16), (sinDG1|sin15), (sinOA2|sin15), (sinDB1|sin15), 0, // 고대의 레시피 갑주
									(sinDA1|sin18), (sinDA2|sin18), (sinDS1|sin16), (sinOM1|sin17), (sinDG1|sin16), (sinOA2|sin16), (sinDB1|sin16), 0, // 대지의 레시피 갑주
									(sinDA1|sin19), (sinDA2|sin19), (sinDS1|sin17), (sinOM1|sin18), (sinDG1|sin17), (sinOA2|sin17), (sinDB1|sin17), 0, // 어둠의 레시피 갑주
									(sinDA1|sin20), (sinDA2|sin20), (sinDS1|sin18), (sinOM1|sin19), (sinDG1|sin18), (sinOA2|sin18), (sinDB1|sin18), 0, // 화염의 레시피 갑주
									(sinDA1|sin21), (sinDA2|sin21), (sinDS1|sin19), (sinOM1|sin20), (sinDG1|sin19), (sinOA2|sin19), (sinDB1|sin19), 0, // 바람의 레시피 갑주
									(sinDA1|sin23), (sinDA2|sin23), (sinDS1|sin21), (sinOM1|sin22), (sinDG1|sin21), (sinOA2|sin21), (sinDB1|sin21), 0, // 태양의 레시피 갑주
									(sinDA1|sin24), (sinDA2|sin24), (sinDS1|sin22), (sinOM1|sin23), (sinDG1|sin22), (sinOA2|sin22), (sinDB1|sin22), 0, // 광포한 레시피 갑주
									0, 0, 0, 0, 0, 0, 0, 0  // 천상의 레시피 갑주
	};
	int num = 0;
	SManufacture_ResultItemInfo_Server Item_Recv;
	ZeroMemory( &Item_Recv, sizeof(SManufacture_ResultItemInfo_Server) );
	Item_Recv.smTransCommand.code = smTRANSCODE_MANUFACTURE_WEIGHT_PRICE;
	Item_Recv.smTransCommand.size = sizeof(SManufacture_ResultItemInfo_Server);
	for( int i = 0; i < 144; i++ )
	{
		for(int cnt=0;cnt<DefaultItemCount;cnt++)
		{
			if( CreateItemCode[i] > 0 &&  CreateItemCode[i] == DefaultItems[cnt].Item.CODE )
			{
				Item_Recv.ItemCode[num] = DefaultItems[cnt].Item.CODE;
				lstrcpy( Item_Recv.ItemName[num], DefaultItems[cnt].Item.ItemName );//pluto 해외
				Item_Recv.Weight[num] = DefaultItems[cnt].Item.Weight;
				Item_Recv.Price[num] = DefaultItems[cnt].Item.Price;
				num++;
			}
		}
	}
	if ( lpPlayInfo && lpPlayInfo->lpsmSock )
	{
		lpPlayInfo->lpsmSock->Send2( (char *)&Item_Recv , Item_Recv.smTransCommand.size , TRUE );
	}
	return TRUE;
}
// pluto 제작 데이타 받음
int rsRecvManufactureItem( rsPLAYINFO *lpPlayInfo, SManufactureItem_Server *pManufactureItem_Server )
{
	CManufacture ccItem;
	//smTRANS_COMMAND	smTransCommand;
	smTRANS_COMMAND_EX	smTransCommandEx;

	int cnt;
	int	ErrorFlag;
	DWORD ItemSmeltingType = 0;
	bool  bProbability = FALSE;
	ErrorFlag = 0;

	if( pManufactureItem_Server->RuneCode[0] ) // pluto 첫번째 값은 제작서에 대한 코드다
	{
		if ( rsDeleteInvenItem( lpPlayInfo , pManufactureItem_Server->RuneCode[0],
			pManufactureItem_Server->Head[0], pManufactureItem_Server->CheckSum[0] )<0 )
		{
			//로그에 기록
			smTransCommandEx.WParam = 8000;
			smTransCommandEx.WxParam = 50;
			smTransCommandEx.LxParam = (int)"*Manufacture Recipe*";
			smTransCommandEx.LParam = pManufactureItem_Server->RuneCode[0];
			smTransCommandEx.SParam = pManufactureItem_Server->Head[0];
			smTransCommandEx.EParam = pManufactureItem_Server->CheckSum[0];
			RecordHackLogFile( lpPlayInfo , &smTransCommandEx );

			ErrorFlag ++;

			pManufactureItem_Server->RuneCode[0] = 0;			// 룬 제거
		}
		SaveThrowItem( lpPlayInfo , pManufactureItem_Server->RuneCode[0], 
			pManufactureItem_Server->Head[0], pManufactureItem_Server->CheckSum[0] );
	}

	for( cnt = 1; cnt < 4; cnt++ ) // pluto 여기서 부터는 룬 코드다
	{
		if( pManufactureItem_Server->RuneCode[cnt] )
		{
			if ( rsDeleteInvenItem( lpPlayInfo , pManufactureItem_Server->RuneCode[cnt],
				pManufactureItem_Server->Head[cnt], pManufactureItem_Server->CheckSum[cnt] )<0 )
			{
				//로그에 기록
				smTransCommandEx.WParam = 8000;
				smTransCommandEx.WxParam = 50;
				smTransCommandEx.LxParam = (int)"*Manufacture Rune*";
				smTransCommandEx.LParam = pManufactureItem_Server->RuneCode[cnt];
				smTransCommandEx.SParam = pManufactureItem_Server->Head[cnt];
				smTransCommandEx.EParam = pManufactureItem_Server->CheckSum[cnt];
				RecordHackLogFile( lpPlayInfo , &smTransCommandEx );

				ErrorFlag ++;

				pManufactureItem_Server->RuneCode[cnt] = 0;			// 룬 제거
			}
			SaveThrowItem( lpPlayInfo , pManufactureItem_Server->RuneCode[cnt], 
				pManufactureItem_Server->Head[cnt], pManufactureItem_Server->CheckSum[cnt] );
			// 레시피와 룬 조합을 검사한다
			
			//if( ManufactureCheckRune( pManufactureItem_Server->DesManufactureItem.CODE /*& sinITEM_MASK3*/, pManufactureItem_Server->RuneCode[cnt]) )
			//{
			//	RuneCnt++;		// 룬 3개 있어야 함
			//}
			//else
			//{
			//	ErrorFlag++;
			//}
			
		}
	}

	DWORD ResultItemCode = 0;

	//if( ErrorFlag == 0 && RuneCnt == 3 )
	if( ErrorFlag == 0 )
	{
		// 레시피와 룬 조합이 일치하면 해당 아이템을 만든다
		ResultItemCode = ManufactureCheckRune( pManufactureItem_Server->RuneCode[0] /*& sinITEM_MASK3*/, pManufactureItem_Server->RuneCode );
		if( ResultItemCode !=0 )
		{
			if( (rand()%100) < 20 ) // 20% 확률
			{
				for(cnt=0;cnt<DefaultItemCount;cnt++)
				{
					if ( DefaultItems[cnt].Item.CODE == ResultItemCode )
					{
						//memcpy( &pSmeltingItem_Server->DesSmeltingItem, &sItem[cnt], sizeof(sITEM));
						CreateDefItem( &pManufactureItem_Server->DesManufactureItem.sItemInfo, &DefaultItems[cnt] );
						bProbability = TRUE;
						break;
					}
				}
			}
			else
			{
				ErrorFlag++;
			}
		}
		else
		{
			ErrorFlag++;
		}
	}
	else
	{
		ErrorFlag++;
	}
	ccItem.sinRecvManufactureItem( pManufactureItem_Server );

	if( bProbability )
	{
		g_sManufactureItem_Recv.Result = TRUE;
	}

	if( ErrorFlag )
	{
		g_sManufactureItem_Recv.Result = FALSE;
	}


	if( g_sManufactureItem_Recv.Result == TRUE )
	{
		ReformItem( &g_sManufactureItem_Recv.DesManufactureItem.sItemInfo );
		g_sManufactureItem_Recv.size = sizeof(sITEM)+32;
		//아이템 로그 제작에 사용된 룬 
		rsRecord_ManufactureItemLog( lpPlayInfo, pManufactureItem_Server->RuneCode, pManufactureItem_Server->Head, pManufactureItem_Server->CheckSum, ITEMLOG_MANUFACTURE_LOST );

		rsAddInvenItem( lpPlayInfo , g_sManufactureItem_Recv.DesManufactureItem.sItemInfo.CODE ,
			g_sManufactureItem_Recv.DesManufactureItem.sItemInfo.ItemHeader.Head ,
			g_sManufactureItem_Recv.DesManufactureItem.sItemInfo.ItemHeader.dwChkSum );

		rsRecord_ItemLog2( lpPlayInfo, g_sManufactureItem_Recv.DesManufactureItem.sItemInfo.CODE, g_sManufactureItem_Recv.DesManufactureItem.sItemInfo.ItemHeader.Head,
			g_sManufactureItem_Recv.DesManufactureItem.sItemInfo.ItemHeader.dwChkSum,  ITEMLOG_MANUFACTURE_GET);

		// pluto 제작 기록
		RecordManufactureItem( lpPlayInfo, &g_sManufactureItem_Recv.DesManufactureItem.sItemInfo );

	}
	else
	{
		g_sManufactureItem_Recv.size = 32;
		rsRecord_ManufactureItemLog( lpPlayInfo, pManufactureItem_Server->RuneCode, pManufactureItem_Server->Head, pManufactureItem_Server->CheckSum, ITEMLOG_MANUFACTURE_FAIL );
	}

	g_sManufactureItem_Recv.code = smTRANSCODE_MANUFACTURE;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock )
	{
		lpPlayInfo->lpsmSock->Send2( (char *)&g_sManufactureItem_Recv , g_sManufactureItem_Recv.size , TRUE );
	}

	return TRUE;
}
//윙 아이템 확득 과정
int rsRecvWingItem( rsPLAYINFO *lpPlayInfo , sCRAFTITEM_SERVER *pCraftItem_Server )
{

	sITEMINFO	sItemInfo;
	smTRANS_COMMAND	smTransCommand;
	smTRANS_COMMAND_EX	smTransCommandEx;

	int cnt;
	int	ErrorFlag;
	int	PotionCount = 0;
	int result;
	int	Money;
	int	ForceMode = 0;

	ErrorFlag = 0;

	if ( pCraftItem_Server->DesCraftItem.CODE == 1000 )
		ForceMode = TRUE;


	if ( ForceMode ) 
		rsRecord_ItemLost( lpPlayInfo , pCraftItem_Server->SheltomCode , pCraftItem_Server->Head , pCraftItem_Server->CheckSum , ITEMLOG_LOST_ALCHMY );
	else
		//윙아이템 획득에 사용된 사용된 크리스탈
		rsRecord_ItemLost( lpPlayInfo , pCraftItem_Server->SheltomCode , pCraftItem_Server->Head , pCraftItem_Server->CheckSum , ITEMLOG_WINGLOST );

	for( cnt=0;cnt<12;cnt++ ) {
		//던져진 아이템 저장
		if ( pCraftItem_Server->SheltomCode[cnt] ) {

			//서버 이벤 아이템 수정
			if ( rsDeleteInvenItem( lpPlayInfo , pCraftItem_Server->SheltomCode[cnt] ,
				pCraftItem_Server->Head[cnt], pCraftItem_Server->CheckSum[cnt] )<0 ) {

					//로그에 기록
					smTransCommandEx.WParam = 8000;
					smTransCommandEx.WxParam = 50;
					smTransCommandEx.LxParam = (int)"*WING CRISTAL*";
					smTransCommandEx.LParam = pCraftItem_Server->SheltomCode[cnt];
					smTransCommandEx.SParam = pCraftItem_Server->Head[cnt];
					smTransCommandEx.EParam = pCraftItem_Server->CheckSum[cnt];
					RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
					ErrorFlag ++;
				}

			SaveThrowItem( lpPlayInfo , pCraftItem_Server->SheltomCode[cnt], 
				pCraftItem_Server->Head[cnt], pCraftItem_Server->CheckSum[cnt] );
		}
	}

	memcpy( &sItemInfo , &pCraftItem_Server->DesCraftItem.sItemInfo , sizeof( sITEMINFO ) );
	Money = pCraftItem_Server->Money;
/*
	if ( rsServerConfig.ServerInventoryMode ) {
		if ( lpPlayInfo->ServerMoney<sItemInfo.Price ) {
			//돈부족
			smTransCommand.WParam = 8010;
			smTransCommand.LParam = 50;
			smTransCommand.SParam = lpPlayInfo->ServerMoney;
			smTransCommand.EParam = sItemInfo.Price;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );

			lpPlayInfo->ServerMoney = 0;
			ErrorFlag ++;
		}
		else {
			lpPlayInfo->ServerMoney -= sItemInfo.Price;
			lpPlayInfo->UnsaveMoney = lpPlayInfo->ServerMoney;
		}
	}
*/

	if ( sItemInfo.CODE && CheckItemForm( &sItemInfo )==FALSE ) {
		//아이템 오류

		pCraftItem_Server->Result = FALSE;
		pCraftItem_Server->size = 32;
		if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
			lpPlayInfo->lpsmSock->Send2( (char *)pCraftItem_Server , pCraftItem_Server->size , TRUE );
		}

		//윙 아이템 조작 오류
		smTransCommand.WParam = 99000;
		smTransCommand.SParam = 1;
		smTransCommand.LParam = sItemInfo.CODE;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		return TRUE;
	}


	rsDeleteInvenItem( lpPlayInfo , pCraftItem_Server->DesCraftItem.sItemInfo.CODE ,
		pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.Head,
		pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.dwChkSum );


	result = 0;

	if ( !ErrorFlag )
		result = sinWingItemQuestServer( pCraftItem_Server, &lpPlayInfo->smCharInfo );
	else
		pCraftItem_Server->Result=FALSE;

	if ( result==0x100 ) {
		//포스오브
		TRANS_ITEMINFO_GROUP	TransItemGroup;
		TRANS_ITEMINFO_GROUP2	TransItemGroup2;
		int cnt2,ItemCnt,LenSize;

		if ( lpPlayInfo->ServerMoney>=Money ) {
			lpPlayInfo->SubServerMoney ( Money , WHERE_FORECORB );
			CurrencyLog.int64_ForceOrbMoney+=Money;			//포스오브 제련비용
		}
		else {
			//로그에 기록
			smTransCommandEx.WParam = 8000;
			smTransCommandEx.WxParam = 50;
			smTransCommandEx.LxParam = (int)"*FORCE MONEY ERROR*";
			smTransCommandEx.LParam = (sinGG1|sin01);
			smTransCommandEx.SParam = Money;
			smTransCommandEx.EParam = lpPlayInfo->ServerMoney;
			RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
			return FALSE;
		}

		ZeroMemory( &TransItemGroup2 , sizeof(TRANS_ITEMINFO_GROUP2) );

		ItemCnt = 0;

		for( cnt=0;cnt<12;cnt++ ) {
			if ( pCraftItem_Server->SheltomCode[cnt] ) {
				for(cnt2=0;cnt2<DefaultItemCount;cnt2++) {
					if ( DefaultItems[cnt2].Item.CODE==pCraftItem_Server->SheltomCode[cnt] && !DefaultItems[cnt2].Item.UniqueItem ) {
						CreateDefItem( &TransItemGroup.sItemInfo[ItemCnt] , &DefaultItems[cnt2] );

						rsAddInvenItem( lpPlayInfo , TransItemGroup.sItemInfo[ItemCnt].CODE ,
							TransItemGroup.sItemInfo[ItemCnt].ItemHeader.Head,
							TransItemGroup.sItemInfo[ItemCnt].ItemHeader.dwChkSum );

						//아이템 로그 윙 획득
						rsRecord_ItemLog2( lpPlayInfo , 
							TransItemGroup.sItemInfo[ItemCnt].CODE ,
							TransItemGroup.sItemInfo[ItemCnt].ItemHeader.Head , 
							TransItemGroup.sItemInfo[ItemCnt].ItemHeader.dwChkSum,
							ITEMLOG_GET_ALCHMY );

						ItemCnt++;
						break;
					}
				}
			}
		}

		LenSize = EecodeCompress( (BYTE *)TransItemGroup.sItemInfo , (BYTE *)TransItemGroup2.szBuff , sizeof(sITEMINFO)*ItemCnt , sizeof(sITEMINFO)*TRANS_GROUPITEM_MAX );
		TransItemGroup2.ItemCount = ItemCnt;
		TransItemGroup2.Result = pCraftItem_Server->Result;
		TransItemGroup2.size = LenSize+TRANS_GROUPITEM_HEADER_SIZE;
		TransItemGroup2.code = smTRANSCODE_ITEM_FORCEORB;

		if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
			lpPlayInfo->lpsmSock->Send2( (char *)&TransItemGroup2 , TransItemGroup2.size , TRUE );
		}

		return TRUE;
	}

	if ( pCraftItem_Server->Result==SIN_WINGRESULT_CRISTAL ) {
		//크리스탈 응모 유저 DB에 통보 (추가예정)
		bSql_EventJoin( lpPlayInfo );
		pCraftItem_Server->Result=TRUE;
	}

	if ( pCraftItem_Server->Result==TRUE && pCraftItem_Server->DesCraftItem.sItemInfo.CODE && !ErrorFlag ) {
		//성공

		if ( pCraftItem_Server->DesCraftItem.sItemInfo.ItemKindCode==ITEM_KIND_QUEST_WEAPON ) {
			//퀘스트 유니크 무기 생성
			for(cnt=0;cnt<DefaultItemCount;cnt++) {
				if ( DefaultItems[cnt].Item.CODE==pCraftItem_Server->DesCraftItem.sItemInfo.CODE && DefaultItems[cnt].Item.UniqueItem==ITEM_UNIQUE_CODE_QUEST ) { 
					CreateDefItem( &pCraftItem_Server->DesCraftItem.sItemInfo , &DefaultItems[cnt] );
					pCraftItem_Server->DesCraftItem.sItemInfo.ItemKindCode=ITEM_KIND_QUEST_WEAPON;
					SetChangeJob3QuestItem(&pCraftItem_Server->DesCraftItem.sItemInfo);
					break;
				}
			}
		}
		else {
			for(cnt=0;cnt<DefaultItemCount;cnt++) {
				if ( DefaultItems[cnt].Item.CODE==pCraftItem_Server->DesCraftItem.sItemInfo.CODE && !DefaultItems[cnt].Item.UniqueItem ) {

					if ( DefaultItems[cnt].sGenDay[0] && DefaultItems[cnt].sGenDay[1]>=DefaultItems[cnt].sGenDay[0] ) {
						//아이템 발생제한 초과
						//물약으로 대신 보낸다
						pCraftItem_Server->DesCraftItem.sItemInfo.CODE = (sinPM1|sin04);
						pCraftItem_Server->DesCraftItem.sItemInfo.PotionCount = 30;

						///////////////////////////////////////////////////////////////////////////////////////
#ifdef	_TEST_SERVER
						if ( lpPlayInfo->AdminMode ) {
							TRANS_CHATMESSAGE	TransChatMessage;
							wsprintf( TransChatMessage.szMessage, "오늘 발생할수 있는 아이템수를 초과했습니다(%d/%d)",
								DefaultItems[cnt].sGenDay[1] , DefaultItems[cnt].sGenDay[0] );

							TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
							TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
							TransChatMessage.dwIP = 0;
							TransChatMessage.dwObjectSerial = 0;

							lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
						}
#endif
						///////////////////////////////////////////////////////////////////////////////////////

						for(cnt=0;cnt<DefaultItemCount;cnt++) {
							if ( DefaultItems[cnt].Item.CODE==pCraftItem_Server->DesCraftItem.sItemInfo.CODE ) {
								break;
							}
						}
						if ( cnt>=DefaultItemCount )
							return FALSE;
					}

					DefaultItems[cnt].sGenDay[1]++;		//아이템 발생 카운터 증가

					if ( (DefaultItems[cnt].Item.CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
						//물약 카운터 설정 하여 생성
						PotionCount = pCraftItem_Server->DesCraftItem.sItemInfo.PotionCount;
						CreateDefItem( &pCraftItem_Server->DesCraftItem.sItemInfo , &DefaultItems[cnt] ); 
						pCraftItem_Server->DesCraftItem.sItemInfo.PotionCount = PotionCount;

						rsAddServerPotion( lpPlayInfo , pCraftItem_Server->DesCraftItem.sItemInfo.CODE , PotionCount );			//서버포션 기록
					}
					else {
						CreateDefItem( &pCraftItem_Server->DesCraftItem.sItemInfo , &DefaultItems[cnt] , -1 ); //-1 은 특화아이템 생성
					}
					break;
				}
			}
		}
		if ( cnt<DefaultItemCount ) {

			//아이템 생성후 보내기

			ReformItem( &pCraftItem_Server->DesCraftItem.sItemInfo);  //아이템 인증 받기 ( 다시 받기 )

			rsAddInvenItem( lpPlayInfo , pCraftItem_Server->DesCraftItem.sItemInfo.CODE ,
				pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.Head,
				pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.dwChkSum );
/*
			//아이템 로그 윙 변경된 아이템 ( 출/입 기록 )
			rsRecord_ItemLog_Change( lpPlayInfo , sItemInfo.CODE , sItemInfo.ItemHeader.Head , sItemInfo.ItemHeader.dwChkSum , 
					pCraftItem_Server->DesCraftItem.sItemInfo.CODE , pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.Head , pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.dwChkSum ,	ITEMLOG_GETWING );
*/
			//아이템 로그 윙 획득
			rsRecord_ItemLog2( lpPlayInfo , 
				pCraftItem_Server->DesCraftItem.sItemInfo.CODE ,
				pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.Head , 
				pCraftItem_Server->DesCraftItem.sItemInfo.ItemHeader.dwChkSum,
				ITEMLOG_GETWING );

			pCraftItem_Server->size = sizeof(sCRAFTITEM_SERVER);
			if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
				lpPlayInfo->lpsmSock->Send2( (char *)pCraftItem_Server , pCraftItem_Server->size , TRUE );
			}

			return TRUE;
		}
	}

	//실패시 로그 남길 예정

	//윙 아이템 조작 오류
	smTransCommand.WParam = 99000;
	smTransCommand.SParam = 1;
	smTransCommand.LParam = sItemInfo.CODE;
	RecordHackLogFile( lpPlayInfo , &smTransCommand );

	pCraftItem_Server->size = sizeof(sCRAFTITEM_SERVER);;
	pCraftItem_Server->Result = FALSE;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)pCraftItem_Server , pCraftItem_Server->size , TRUE );
	}

	return TRUE;
}

#ifdef _W_SERVER

//링크 코어 등록 요청
int rsRecvMakeLinkCore( rsPLAYINFO *lpPlayInfo , TRANS_ITEMINFO *lpTransItemInfo )
{
	int len,len2;

	if ( !lpPlayInfo->szName[0] || CheckItemForm( &lpTransItemInfo->Item )==FALSE ) return FALSE;

	//서버 이벤 아이템 수정
	if ( rsDeleteInvenItem( lpPlayInfo , lpTransItemInfo->Item.CODE , lpTransItemInfo->Item.ItemHeader.Head , lpTransItemInfo->Item.ItemHeader.dwChkSum )<0 )
		return FALSE;


	lpTransItemInfo->Item.BackUpKey = lpTransItemInfo->Item.ItemHeader.Head;
	lpTransItemInfo->Item.BackUpChkSum = lpTransItemInfo->Item.ItemHeader.dwChkSum;

	len = lstrlen( lpTransItemInfo->Item.ItemName )+1;
	len2 = lstrlen( lpPlayInfo->szName );
	if ( (len+len2)>32 ) return FALSE;		//이름이 너무 길다 실패

	lstrcpy( lpTransItemInfo->Item.ItemName+len , lpPlayInfo->szName );

	ReformItem( &lpTransItemInfo->Item );

	//서버 인벤 아이템 추가
	rsAddInvenItem( lpPlayInfo , lpTransItemInfo->Item.CODE , lpTransItemInfo->Item.ItemHeader.Head , lpTransItemInfo->Item.ItemHeader.dwChkSum );

	lpPlayInfo->lpsmSock->Send2( (char *)lpTransItemInfo , lpTransItemInfo->size , TRUE );

	return TRUE;
}

//링크 코어 사용
int rsRecvUseLinkCore( rsPLAYINFO *lpPlayInfo , TRANS_ITEMINFO *lpTransItemInfo )
{
	char *szName;
	int len;
	rsPLAYINFO *lpPlayInfo2;
	TRANS_CHATMESSAGE	TransChatMessage;
	smTRANS_COMMAND_EX	smTransCommandEx;
	STG_AREA	*lpStgArea;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;
	if ( CheckItemForm( &lpTransItemInfo->Item )==FALSE ) return FALSE;


	lpTransItemInfo->Item.ItemName[31] = 0;
	len = lstrlen( lpTransItemInfo->Item.ItemName );

	szName = &lpTransItemInfo->Item.ItemName[len+1];
	if ( !szName[0] ) return FALSE;

	lpPlayInfo2=FindUserFromName( szName );

	if ( !lpPlayInfo2 || !lpPlayInfo2->dwObjectSerial || !lpPlayInfo->dwClanCode || lpPlayInfo->EventMode || lpPlayInfo2->EventMode || 
		rsCheckHardCoreEventArea( lpPlayInfo2->Position.x,lpPlayInfo2->Position.y,lpPlayInfo2->Position.z )==TRUE ||
		lpPlayInfo->Position.Area==QUEST_ARENA_FIELD || lpPlayInfo2->Position.Area==rsCASTLE_FIELD ) {

		lstrcpy( TransChatMessage.szMessage , szNotLinkCore );
		TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		TransChatMessage.size = 32+lstrlen( TransChatMessage.szMessage );

		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		return FALSE;
	}

	if ( lpPlayInfo2->dwClanCode!=lpPlayInfo->dwClanCode ) {
		lstrcpy( TransChatMessage.szMessage , szNotLinkCore2 );
		TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		TransChatMessage.size = 32+lstrlen( TransChatMessage.szMessage );

		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		return FALSE;
	}

	lpStgArea = FindStageField( lpPlayInfo2->Position.x, lpPlayInfo2->Position.z );

	if ( lpStgArea ) {

		if ( lpStgArea->lpField ) {	
			if ( lpPlayInfo->smCharInfo.Level<FieldLimitLevel_Table[lpStgArea->lpField->FieldCode] ||
				lpStgArea->lpField->FieldCode==QUEST_ARENA_FIELD ) {
				//레벨 제한 필드
				lstrcpy( TransChatMessage.szMessage , szNotLinkCore3 );
				TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				TransChatMessage.size = 32+lstrlen( TransChatMessage.szMessage );

				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				return FALSE;
			}
		}

		smTransCommandEx.code = smTRANSCODE_USE_LINKCORE;
		smTransCommandEx.size = sizeof(smTRANS_COMMAND_EX);
		smTransCommandEx.WxParam = lpTransItemInfo->Item.CODE;
		smTransCommandEx.LxParam = lpTransItemInfo->Item.ItemHeader.Head;
		smTransCommandEx.SxParam = lpTransItemInfo->Item.ItemHeader.dwChkSum;
		smTransCommandEx.ExParam = 0;
		smTransCommandEx.WParam = lpPlayInfo2->Position.x;
		smTransCommandEx.LParam = lpPlayInfo2->Position.y;
		smTransCommandEx.SParam = lpPlayInfo2->Position.z;
		smTransCommandEx.EParam = lpStgArea->lpField->FieldCode;

		lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommandEx , smTransCommandEx.size , TRUE );
		return TRUE;
	}

	return FALSE;
}

#endif


//힐링
int	rsPlayHealing( smTRANS_COMMAND *lpTransCommand )
{
	smCHAR	*lpChar;
	rsPLAYINFO *lpPlayInfo;

	lpChar = srFindCharFromSerial( lpTransCommand->SParam );
	if ( lpChar ) {
		//몬스터 치료
		if ( lpChar && lpChar->smCharInfo.Life[0]>0 ) {
			if ( !lpChar->DontMoveFlag || lpChar->smCharInfo.dwCharSoundCode!=snCHAR_SOUND_CASTLE_TOWER_B ) 
			{
				if(lpChar->smCharInfo.dwCharSoundCode == snCHAR_SOUND_CASTLE_DOOR			//공성문
				//	lpChar->smCharInfo.dwCharSoundCode == snCHAR_SOUND_CASTLE_CRYSTAL_R	||	//공성크리스탈
				//	lpChar->smCharInfo.dwCharSoundCode == snCHAR_SOUND_CASTLE_CRYSTAL_G	||
				//	lpChar->smCharInfo.dwCharSoundCode == snCHAR_SOUND_CASTLE_CRYSTAL_B	||
				//	lpChar->smCharInfo.dwCharSoundCode == snCHAR_SOUND_CASTLE_CRYSTAL_N
					)
					return TRUE;// 공성문 힐 금지(해외)

				lpChar->smCharInfo.Life[0] += lpTransCommand->WParam;
				if ( lpChar->smCharInfo.Life[0]>lpChar->smCharInfo.Life[1] )
					lpChar->smCharInfo.Life[0] = lpChar->smCharInfo.Life[1];
			}
		}
		return TRUE;
	}
	lpPlayInfo = srFindUserFromSerial( lpTransCommand->SParam );
	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {

		if ( lpPlayInfo->dwSkill_VirtualLife_Time && lpPlayInfo->dwSkill_VirtualLife_Time>dwPlayServTime ) {
			//버쳘라이프 (수치보정 )
			lpTransCommand->WParam -= (lpTransCommand->WParam*lpPlayInfo->dwSkill_VirtualLife_Param)/100;
		}

		//다른 유저 치료
		lpPlayInfo->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
		return TRUE;
	}

	return	FALSE;
}
//그랜드힐링
int rsPlayGrandHealing( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	int cnt;
	rsPLAYINFO *lpPartyMaster;
	smTRANS_COMMAND	smTransCommand;

	if ( lpPlayInfo->dwPartyInfo && lpPlayInfo->lpPartyMaster ) {
		lpPartyMaster = lpPlayInfo->lpPartyMaster;

		memcpy( &smTransCommand , lpTransCommand , sizeof(smTRANS_COMMAND) );

		for( cnt=0;cnt<lpPartyMaster->PartyUserCount;cnt++ ) {
			if ( lpPartyMaster->lpPartyPlayers[cnt] && lpPartyMaster->lpPartyPlayers[cnt]->lpsmSock ) {

				if ( lpPlayInfo!=lpPartyMaster->lpPartyPlayers[cnt] ) {

					if ( lpPlayInfo->dwSkill_VirtualLife_Time && lpPlayInfo->dwSkill_VirtualLife_Time>dwPlayServTime ) {
						//버쳘라이프 (수치보정 )
						smTransCommand.LParam = lpTransCommand->LParam;
						smTransCommand.LParam -= (lpTransCommand->LParam*lpPlayInfo->dwSkill_VirtualLife_Param)/100;
						lpPartyMaster->lpPartyPlayers[cnt]->lpsmSock->Send2((char *)&smTransCommand , smTransCommand.size , TRUE );
					}
					else {
						lpPartyMaster->lpPartyPlayers[cnt]->lpsmSock->Send2((char *)lpTransCommand , lpTransCommand->size , TRUE );
					}
				}

			}
		}
	}
	/*
	else {
		if ( lpPlayInfo->lpsmSock ) {
			lpPlayInfo->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
		}
	}
	*/

	return TRUE;
}

//홀리 마인드
int	rsPlayHolyMind( smTRANS_COMMAND *lpTransCommand )
{
	smCHAR	*lpChar;
	int time;
	int bio;

	lpChar = srFindCharFromSerial( lpTransCommand->SParam );
	if ( lpChar ) {
		time = lpTransCommand->LParam<<4;
		bio = lpChar->smCharInfo.Resistance[sITEMINFO_BIONIC];		//생 속성 적용
		if ( bio<0 ) bio=0;
		if ( bio>100 ) bio=100;
		time = (time*(100-bio))/100;
		if ( time>0 ) {
			lpChar->PlayHolyMind[0] = lpTransCommand->WParam;
			lpChar->PlayHolyMind[1] = time;
		}
		return TRUE;
	}

/*
							//생속성 에 따르 중립상태 유지 
							rs = lpChar->smCharInfo.Resistance[sITEMINFO_BIONIC];
							if ( rs<0 ) rs = 0;
							if ( rs>=100 ) rs=100;

							if ( (rand()%100)>rs ) {
								lpChar->PlayStunCount = lpTransSkilAttackData->Power<<4;		//중립상태 설정
								rs = 100-rs;
								lpChar->PlayStunCount = ( lpChar->PlayStunCount * rs )/100;
							}
*/

	return FALSE;
}

//SoD 결과용 체크섬 생성
int rsCheck_ResulSOD( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommandEx )
{
	DWORD Code;

#ifdef _W_SERVER
	Code = 0x0c5c55cc;

	Code ^= lpTransCommandEx->WParam<<1;
	Code ^= lpTransCommandEx->LParam<<2;
	Code ^= lpTransCommandEx->SParam<<3;
	Code ^= lpTransCommandEx->EParam<<4;

	Code ^= lpTransCommandEx->WxParam<<16;
	Code ^= lpTransCommandEx->LxParam<<17;
	Code ^= lpTransCommandEx->SxParam<<18;

	Code ^= lpPlayInfo->dwObjectSerial<<16;

#else
	Code = 0x3ea832ff;
#endif

	return Code&0x7FFFFFFF;
}

//SOD 결과를 데이타 서버로 보냄
int rsSend_ResultSOD( rsPLAYINFO *lpPlayInfo , int Point , int KillCount , int TotalPoint , int TotalSucessUser , int TotalUser , int SoDCode )
{
	smTRANS_COMMAND_EX	smTransCommand;

	smTransCommand.code = smTRANSCODE_SOD_RESULT;
	smTransCommand.size = sizeof( smTRANS_COMMAND_EX );
	smTransCommand.WParam = lpPlayInfo->smCharInfo.Level;
	smTransCommand.LParam = Point;
	smTransCommand.SParam = KillCount;
	smTransCommand.EParam = SoDCode;
	smTransCommand.WxParam = TotalPoint;
	smTransCommand.LxParam = TotalSucessUser;
	smTransCommand.SxParam = TotalUser;
	smTransCommand.ExParam = rsCheck_ResulSOD( lpPlayInfo , &smTransCommand );
	rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );

	return TRUE;
}



//공격 데이타를 비교 하여 기록
int rsCompAttackData( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	int avg1, avg2;
	smTRANS_COMMAND	smTransCommand;

	if ( lpPlayInfo->Send_AttackCount>255 ) {
		avg1 = lpPlayInfo->Send_AttackDamage/lpPlayInfo->Send_AttackCount;
		if ( lpTransCommand->WParam )
			avg2 = (-lpTransCommand->LParam)/(-lpTransCommand->WParam);
		else
			avg2 = 0;

		if ( avg1>(((avg2*340)>>8)+16) && lpPlayInfo->WarningCount<10 ) {

			//오류 ( 로그에 기록 )
			smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = 8110;
			smTransCommand.LParam = avg1;
			smTransCommand.SParam = avg2;
			smTransCommand.EParam = lpPlayInfo->Send_AttackCount;
			if ( lpPlayInfo ) {
				rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
			}
			lpPlayInfo->WarningCount++;
		}
	}
/*
	if ( lpPlayInfo->Recv_AttackCount>255 ) {
		avg1 = lpPlayInfo->Recv_AttackDamage/lpPlayInfo->Recv_AttackCount;
		if ( lpTransCommand->SParam )
			avg2 = (-lpTransCommand->EParam)/(-lpTransCommand->SParam);
		else
			avg2 = 0x7FFFFFFF;

		if ( avg2>(((avg1*340)>>8)+16) && lpPlayInfo->WarningCount<20 ) {

			//오류 ( 로그에 기록 )
			smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = 8120;
			smTransCommand.LParam = avg1;
			smTransCommand.SParam = avg2;
			smTransCommand.EParam = lpPlayInfo->Recv_AttackCount;
			if ( lpPlayInfo ) {
				rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
			}
			lpPlayInfo->WarningCount++;
		}
	}
*/

	return TRUE;
}

//인벤토리 아이템 위치 정보
int CheckInvenItemPosition( rsPLAYINFO *lpPlayInfo , TRANS_USINGITEM *lpTransUsingItem )
{

#ifdef _W_SERVER

	int cnt,cnt2;
	int Pos;
	DWORD dwCode;
	int	MaxAttack;
	smTRANS_COMMAND	smTransCommand;

	MaxAttack = 4;

	int	PosOk;

	for( cnt=0;cnt<lpTransUsingItem->ItemListCount;cnt++ ) {
		dwCode = lpTransUsingItem->ItemList[cnt].dwCode&sinITEM_MASK2;
		Pos = lpTransUsingItem->ItemList[cnt].Performance[0]&0xFF;
		PosOk = TRUE;


		if ( lpTransUsingItem->ItemList[cnt].Performance[1]>MaxAttack )
			MaxAttack = lpTransUsingItem->ItemList[cnt].Performance[1];

		if ( (dwCode&sinITEM_MASK1)==0x01000000 ) 
			dwCode=sinWA1;
		if ( (dwCode&sinITEM_MASK1)==0x04000000 ) 
			dwCode=sinPM1;


		switch( dwCode ) {
		case sinWA1:		//공격무기
			if ( Pos!=1 ) 
				PosOk = FALSE;
			break;
		case sinDA1:		//갑옷
		case sinDA2:
			if ( Pos!=3 )
				PosOk = FALSE;
			break;

		case sinDB1:		//신발
			if ( Pos!=10 )
				PosOk = FALSE;
			break;

		case sinDG1:		//장갑
			if ( Pos!=9 )
				PosOk = FALSE;
			break;

		case sinDS1:		//방패
		case sinOM1:		//수정 구술
			if ( Pos!=2 )
				PosOk = FALSE;
			break;


		case sinPM1:		//물약
			if ( Pos<11 || Pos>13 )
				PosOk = FALSE;
			break;

		case sinOS1:		//쉘텀
			if ( Pos!=7 )
				PosOk = FALSE;
			break;

		case sinOA1:		//목걸이
			if ( Pos!=4 )
				PosOk = FALSE;
			break;
		case sinOA2:		//암릿
			if ( Pos!=8 )
				PosOk = FALSE;
			break;
		case sinOR1:		//반지
			if ( Pos!=5 && Pos!=6 )
				PosOk = FALSE;
			break;
		}

		if ( PosOk==FALSE ) {

			//오류 ( 로그에 기록 )
			smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = 8040;
			smTransCommand.LParam = lpTransUsingItem->ItemList[cnt].dwCode;
			smTransCommand.SParam = 0;
			smTransCommand.EParam = lpTransUsingItem->ItemList[cnt].Performance[0];

			if ( lpPlayInfo ) {
				rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
			}

			return FALSE;
		}

		for( cnt2=0;cnt2<lpTransUsingItem->ItemListCount;cnt2++ ) {
			if ( cnt!=cnt2 ) {
				if (lpTransUsingItem->ItemList[cnt].Performance[0]==lpTransUsingItem->ItemList[cnt2].Performance[0] ) {
					//아이템 겹침
					//오류 ( 로그에 기록 )
					smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
					smTransCommand.size = sizeof( smTRANS_COMMAND );
					smTransCommand.WParam = 8040;
					smTransCommand.LParam = lpTransUsingItem->ItemList[cnt].dwCode;
					smTransCommand.SParam = lpTransUsingItem->ItemList[cnt2].dwCode;
					smTransCommand.EParam = lpTransUsingItem->ItemList[cnt2].Performance[0];

					if ( lpPlayInfo ) {
						rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
					}

					return FALSE;
				}
			}
		}
	}

#endif
	return TRUE;
}

//인벤토리 아이템 위치 정보
int CheckInvenItemPosition2( rsPLAYINFO *lpPlayInfo , TRANS_USINGITEM *lpTransUsingItem )
{

#ifdef _W_SERVER

	int cnt,cnt2;
	int Pos;
	DWORD dwCode;
	int	MaxAttack;
	smTRANS_COMMAND	smTransCommand;
	int	eWeapon , eShield;
	DWORD eWeaponCode,eShieldCode;

	MaxAttack = 4;
	eWeapon = 0;
	eShield = 0;

	int	PosOk;

	for( cnt=0;cnt<lpTransUsingItem->ItemListCount;cnt++ ) {
		dwCode = lpTransUsingItem->ItemList[cnt].dwCode&sinITEM_MASK2;
		Pos = lpTransUsingItem->ItemList[cnt].Performance[0]&0xFF;
		PosOk = TRUE;


		if ( lpTransUsingItem->ItemList[cnt].Performance[1]>MaxAttack )
			MaxAttack = lpTransUsingItem->ItemList[cnt].Performance[1];

		if ( (dwCode&sinITEM_MASK1)==0x01000000 ) 
			dwCode=sinWA1;
		if ( (dwCode&sinITEM_MASK1)==0x04000000 ) 
			dwCode=sinPM1;


		switch( dwCode ) {
		case sinWA1:		//공격무기
			if ( Pos!=1 ) 
				PosOk = FALSE;

			eWeapon ++;
			eWeaponCode = lpTransUsingItem->ItemList[cnt].dwCode;
			break;
		case sinDA1:		//갑옷
		case sinDA2:
			if ( Pos!=3 )
				PosOk = FALSE;
			break;

		case sinDB1:		//신발
			if ( Pos!=10 )
				PosOk = FALSE;
			break;

		case sinDG1:		//장갑
			if ( Pos!=9 )
				PosOk = FALSE;
			break;

		case sinDS1:		//방패
		case sinOM1:		//수정 구술
			if ( Pos!=2 )
				PosOk = FALSE;

			eShield ++;
			eShieldCode = lpTransUsingItem->ItemList[cnt].dwCode;
			break;


		case sinPM1:		//물약
			if ( Pos<11 || Pos>13 )
				PosOk = FALSE;
			break;

		case sinOS1:		//쉘텀
			if ( Pos!=7 )
				PosOk = FALSE;
			break;

		case sinOA1:		//목걸이
			if ( Pos!=4 )
				PosOk = FALSE;
			break;
		case sinOA2:		//암릿
			if ( Pos!=8 )
				PosOk = FALSE;
			break;
		case sinOR1:		//반지
			if ( Pos!=5 && Pos!=6 )
				PosOk = FALSE;
			break;
		}

		if ( PosOk==FALSE ) {

			//오류 ( 로그에 기록 )
			smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = 8040;
			smTransCommand.LParam = lpTransUsingItem->ItemList[cnt].dwCode;
			smTransCommand.SParam = 0;
			smTransCommand.EParam = lpTransUsingItem->ItemList[cnt].Performance[0];

			if ( lpPlayInfo ) {
				rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
			}

			return FALSE;
		}

		for( cnt2=0;cnt2<lpTransUsingItem->ItemListCount;cnt2++ ) {
			if ( cnt!=cnt2 ) {
				if (lpTransUsingItem->ItemList[cnt].Performance[0]==lpTransUsingItem->ItemList[cnt2].Performance[0] ) {
					//아이템 겹침
					//오류 ( 로그에 기록 )
					smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
					smTransCommand.size = sizeof( smTRANS_COMMAND );
					smTransCommand.WParam = 8040;
					smTransCommand.LParam = lpTransUsingItem->ItemList[cnt].dwCode;
					smTransCommand.SParam = lpTransUsingItem->ItemList[cnt2].dwCode;
					smTransCommand.EParam = lpTransUsingItem->ItemList[cnt2].Performance[0];

					if ( lpPlayInfo ) {
						rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
					}

					return FALSE;
				}
			}
		}
	}

	//양손무기에 방패 겹쳤는지 확인
	if ( eShield && eWeapon ) {
		for( cnt=0;cnt<MAX_ITEM;cnt++ ) {
			if ( sItem[cnt].CODE==(sinGG1|sin01) ) break;

			if ( sItem[cnt].CODE==eWeaponCode ) {
				if ( sItem[cnt].Class==ITEM_CLASS_WEAPON_TWO ) {
					smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
					smTransCommand.size = sizeof( smTRANS_COMMAND );
					smTransCommand.WParam = 8040;
					smTransCommand.LParam = eWeaponCode;
					smTransCommand.SParam = eShieldCode;
					smTransCommand.EParam = -1;

					if ( lpPlayInfo ) {
						rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
					}
					return FALSE;
				}
				break;
			}
		}
	}



#endif
	return TRUE;
}


//아이템 거래 완료 기록
int rsRecvRecordTradeItem( rsPLAYINFO *lpPlayInfo , TRANS_RECORD_TRADE_ITEMS *lpTransRecordTradeItems )
{
/*
	int cnt;
	rsPLAYINFO *lpPlayInfo2;
	DWORD	dwCodeName;

	if ( lpTransRecordTradeItems->ThrowItemCount<=0 || lpTransRecordTradeItems->ThrowItemCount>=THROW_ITEM_INFO_MAX) return FALSE;

	dwCodeName = GetSpeedSum( lpTransRecordTradeItems->szTradeUserName );
	lpPlayInfo2 = 0;

	//거래한 대상을 찾는다
	for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szName && rsPlayInfo[cnt].dwCode_Name==dwCodeName ) {
			lpPlayInfo2 = &rsPlayInfo[cnt];
			break;
		}
	}

	if ( lpPlayInfo2 ) {
		//상대방 존재 ( 상대방에 버린 아이템들 기록 / 복사방지 )
		for( cnt=0;cnt<lpTransRecordTradeItems->ThrowItemCount;cnt++ ) {
			SaveThrowItem( lpPlayInfo2 ,
				lpTransRecordTradeItems->Items[cnt].dwCode, 
				lpTransRecordTradeItems->Items[cnt].dwHead,
				lpTransRecordTradeItems->Items[cnt].dwChkSum );
		}
	}
	else {
		//거래한 상대방이 접속이 끈어진 상태 ( 그래도 파일을 찾아 제거해준다 / 복사방지 )
		rsRECORD_DBASE	RecordBase;
		sTHROW_ITEM_INFO	ThrowItemInfo[THROW_ITEM_INFO_MAX];			//버려진 아이템 정보

		for(cnt=0;cnt<lpTransRecordTradeItems->ThrowItemCount;cnt++) {
			ThrowItemInfo[cnt].dwCode = lpTransRecordTradeItems->Items[cnt].dwCode;
			ThrowItemInfo[cnt].dwKey  = lpTransRecordTradeItems->Items[cnt].dwHead;
			ThrowItemInfo[cnt].dwSum  = lpTransRecordTradeItems->Items[cnt].dwChkSum;
		}

		return RecordBase.SaveThrowData( lpTransRecordTradeItems->szTradeUserName , ThrowItemInfo  , lpTransRecordTradeItems->ThrowItemCount , 0 );
	}
*/
	return TRUE;
}


//아이템 임시 체크섬 확인
int rsCheckItemTempCode( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpItem )
{

#ifdef _W_SERVER
	if ( lpItem->ItemHeader.dwChkSum==(lpItem->Temp0-lpItem->CODE) ) {
		return TRUE;
	}
	if ( (lpItem->CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
		return TRUE;
	}

	//오류 ( 로그에 기록 )
	smTRANS_COMMAND	smTransCommand;
	smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
	smTransCommand.size = sizeof( smTRANS_COMMAND );
	smTransCommand.WParam = 6810;
	smTransCommand.LParam = lpItem->CODE;
	smTransCommand.SParam = lpItem->ItemHeader.Head;
	smTransCommand.EParam = lpItem->ItemHeader.dwChkSum;

	if ( lpPlayInfo ) {
		rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
	}

#endif
	return FALSE;
}

/*
struct	TRANS_ITEM_CODE {
	int size,code;

	DWORD	dwFlag;

	DWORD	dwItemCode;
	DWORD	dwHead;
	DWORD	dwChkSum;
	DWORD	dwTime;
};
*/

//smTRANSCODE_CHECKITEM
int	rsCheckItemCode( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpItem )
{
#ifdef _W_SERVER
	int result;

	TRANS_ITEM_CODE	TransItemCode;

	if ( !lpItem->ItemName[0] ) return TRUE;			//껍데기 아이템

	result = CheckItemForm( lpItem );

	if ( result==TRUE ) result = CheckMixItem( lpItem );		//믹스 아이템 코드 확인
/*
#ifdef _LANGUAGE_CHINESE

	//중국판은 유니크 와 이펙트 아이템 없음 ( 무조건 불량 아이템 처리 )
	int cnt;

	cnt = 0;
	cnt |= lpItem->ScaleBlink[0];
	cnt |= lpItem->ScaleBlink[1];
	cnt |= lpItem->UniqueItem;
	cnt |= lpItem->EffectBlink[0];
	cnt |= lpItem->EffectBlink[1];

	if ( cnt ) result=FALSE;

#endif
*/

	if ( result==TRUE ) {
		//아이템 임시 체크섬 확인
		rsCheckItemTempCode( lpPlayInfo , lpItem );

		return TRUE;
	}

#ifndef	_NEW_ITEM_FORMCODE

	return TRUE;

#endif

/*
	case 0x100:
		//아이템 재인증 된경우
		TransItemCode.code = smTRANSCODE_CHECKITEM;
		TransItemCode.size = sizeof(TRANS_ITEM_CODE);
		TransItemCode.dwFlag = TRUE;
		TransItemCode.dwHead = lpItem->ItemHeader.Head;
		TransItemCode.dwChkSum = lpItem->ItemHeader.dwChkSum;
		TransItemCode.dwItemCode = lpItem->CODE;
		TransItemCode.dwTime = lpItem->ItemHeader.dwTime;

		if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
			lpPlayInfo->lpsmSock->Send2( (char *)&TransItemCode , TransItemCode.size , TRUE );
		}

		//아이템 임시 체크섬 확인
		rsCheckItemTempCode( lpPlayInfo , lpItem );

		return TRUE;
*/

	//교환중인 아이템일 가능성때문에 우선 허가 (나중에 수정예정)
	if ( lpItem->ItemHeader.Head==0 || (lpItem->CODE&sinITEM_MASK2)==sinQT1 ) {
		return TRUE;
	}


	//오류 아이템 판정 제거 요구
	TransItemCode.code = smTRANSCODE_ERRORITEM;
	TransItemCode.size = sizeof(TRANS_ITEM_CODE);
	TransItemCode.dwFlag = FALSE;
	TransItemCode.dwHead = lpItem->ItemHeader.Head;
	TransItemCode.dwChkSum = lpItem->ItemHeader.dwChkSum;
	TransItemCode.dwItemCode = lpItem->CODE;
	TransItemCode.dwTime = 0;
	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->lpsmSock->Send2( (char *)&TransItemCode , TransItemCode.size , TRUE );
	}

	//오류 ( 로그에 기록 )
	smTRANS_COMMAND	smTransCommand;
	smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
	smTransCommand.size = sizeof( smTRANS_COMMAND );
	smTransCommand.WParam = 6800;
	smTransCommand.LParam = lpItem->CODE;
	smTransCommand.SParam = lpItem->ItemHeader.Head;
	smTransCommand.EParam = lpItem->ItemHeader.dwChkSum;
	rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );

	char	*szErrorItemDir = "ItemError";
	char	szBuff[256];
	FILE	*fp;

	CreateDirectory( szErrorItemDir, NULL ); 
	wsprintf( szBuff , "%s\\%s(%d).itm" , szErrorItemDir , lpPlayInfo->smCharInfo.szName , lpItem->ItemHeader.dwChkSum );
	fp = fopen( szBuff , "wb" );
	if ( fp ) {
		fwrite( lpItem , sizeof( sITEMINFO ) , 1, fp );
		fclose( fp );
	}


#endif

	return TRUE;
}


/*
struct TRANS_ITEMINFO {
	int	size,code;

	//char	szItemName[32];
	//DWORD	ItemCode;

	sITEMINFO	Item;

	int x,y,z;

	DWORD	dwSeCode[4];		//보안 코드
};
*/


#ifdef	_W_SERVER

//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
int	rsRegist_ItemSecCode( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommandEx )
{

	if ( !rsServerConfig.ServerInventoryMode ) return 1;

	DWORD	cnt;
	DWORD	Key;

	DWORD	dwOs		= lpPlayInfo->dwObjectSerial;
	DWORD	dwCode_Name = lpPlayInfo->dwCode_Name;
	DWORD	dwSvCode	= rsServerConfig.ServerCode;
	DWORD	dwSndCount	= lpPlayInfo->SndItemSecCodeCount;
	DWORD	dwItemChkSum = lpTransCommandEx->LParam^lpTransCommandEx->SParam;
	DWORD	dwSeCode[4];

	Key = (dwPlayServTime&0xFFFF)^lpTransCommandEx->SParam;
	Key = Key^(Key<<10);

	if ((lpTransCommandEx->WParam&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1)) {
		//물약인경우 ( 물약 갯수를 키에 숨긴다 )
		Key &= 0xFFFF0000;
		cnt = lpTransCommandEx->EParam^lpTransCommandEx->SParam^lpTransCommandEx->code;
		if ( cnt==0 ) cnt=1;
		Key |= (cnt&0xFFFF)^0x3c15; 
	}


	dwSeCode[0] = (dwSvCode<<16)|(dwSndCount&0xFFFF);
	dwSeCode[0]&=0x7FFFFFFF;

	dwSeCode[1] = dwItemChkSum^((dwCode_Name&0xFFFF)|(lpPlayInfo->dwObjectSerial<<16));
	dwSeCode[2] = lpTransCommandEx->ExParam^dwSeCode[0]^dwSeCode[1];
	dwSeCode[3] = Key;

	lpTransCommandEx->WxParam = dwSeCode[0] ^ (XOR_ITEM_SeCode_0^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,0));
	lpTransCommandEx->LxParam = dwSeCode[1] ^ (XOR_ITEM_SeCode_1^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,1));
	lpTransCommandEx->SxParam = dwSeCode[2] ^ (XOR_ITEM_SeCode_2^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,2));
	lpTransCommandEx->ExParam = dwSeCode[3];

	lpPlayInfo->SndItemSecCodeCount ++;

	return TRUE;
}



//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
int	rsRegist_ItemSecCode( rsPLAYINFO *lpPlayInfo , TRANS_ITEMINFO *lpTransItemInfo , int NewItem )
{
	//lpPlayInfo 해당 유저
	//ObjectSerial 비교 , 보낸카운터 비교 , 서버코드 , 신규

	if ( !rsServerConfig.ServerInventoryMode ) return 1;

	DWORD	cnt;
	DWORD	Key;

	DWORD	dwOs		= lpPlayInfo->dwObjectSerial;
	DWORD	dwCode_Name = lpPlayInfo->dwCode_Name;
	DWORD	dwSvCode	= rsServerConfig.ServerCode;
	DWORD	dwSndCount	= lpPlayInfo->SndItemSecCodeCount;
	DWORD	dwItemChkSum = lpTransItemInfo->Item.ItemHeader.dwChkSum^lpTransItemInfo->Item.ItemHeader.Head;


	Key = (dwPlayServTime&0xFFFF)^dwItemChkSum;
	Key = Key^(Key<<10);

	if ((lpTransItemInfo->Item.CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1)) {
		//물약인경우 ( 물약 갯수를 키에 숨긴다 )
		Key &= 0xFFFF0000;
		cnt = lpTransItemInfo->Item.PotionCount;
		if ( cnt==0 ) cnt=1;
		Key |= (cnt&0xFFFF)^0x3c15; 
	}

	lpTransItemInfo->dwSeCode[0] = (dwSvCode<<16)|(dwSndCount&0xFFFF);
	if ( NewItem ) lpTransItemInfo->dwSeCode[0]|=0x8000000;			//신규 생성 아이템 ( 몬스터에서 발생 )
	else lpTransItemInfo->dwSeCode[0]&=0x7FFFFFFF;					//누가 버린 아이템

	lpTransItemInfo->dwSeCode[1] = dwItemChkSum^((dwCode_Name&0xFFFF)|(lpPlayInfo->dwObjectSerial<<16));
	lpTransItemInfo->dwSeCode[2] = lpTransItemInfo->Item.Money^lpTransItemInfo->dwSeCode[0]^lpTransItemInfo->dwSeCode[1];
	lpTransItemInfo->dwSeCode[3] = Key;

	lpTransItemInfo->dwSeCode[0] ^= (XOR_ITEM_SeCode_0^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,0));
	lpTransItemInfo->dwSeCode[1] ^= (XOR_ITEM_SeCode_1^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,1));
	lpTransItemInfo->dwSeCode[2] ^= (XOR_ITEM_SeCode_2^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,2));

	lpPlayInfo->SndItemSecCodeCount ++;

	return TRUE;
}

/////////////////////////// 이사님 07_12_10
int rsDEBUG_SecCode_SvCode;
int rsDEBUG_SecCode_SndCount;
////////////////////////////////////

//아이템 정보송수신 구조체에 보안코드 해독 비교 ( 컴파일시 서버에서만 존재 )
int	rsCheck_ItemSecCode( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum , int Money , DWORD dwSeCode_0, DWORD dwSeCode_1, DWORD dwSeCode_2, DWORD dwSeCode_3 , int *pPotionCount )
{
	DWORD	cnt;
	DWORD	Key;

	DWORD	dwSeCode[4];
	smTRANS_COMMAND	smTransCommand;

	//	8020

	if ( !rsServerConfig.ServerInventoryMode ) return 1;

	Key = dwSeCode_3;

	if ( (dwCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) )
		*pPotionCount = (Key&0xFFFF)^0x3c15;			//숨겨진 물약
	else
		*pPotionCount = 0;

	dwSeCode[0] = dwSeCode_0^(XOR_ITEM_SeCode_0^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,0));
	dwSeCode[1] = dwSeCode_1^(XOR_ITEM_SeCode_1^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,1));
	dwSeCode[2] = dwSeCode_2^(XOR_ITEM_SeCode_2^rsRegist_EnterKey(Key^lpPlayInfo->dwObjectSerial,2));

	DWORD	dwSvCode;
	DWORD	dwCmpCode;
	int SndCount;

	dwCmpCode = (dwHead^dwChkSum)^((lpPlayInfo->dwCode_Name&0xFFFF)|(lpPlayInfo->dwObjectSerial<<16));
	if ( dwSeCode[1]!=dwCmpCode ) {

		smTransCommand.WParam = 8020;
		smTransCommand.LParam = 1;
		smTransCommand.SParam = dwSeCode[1];
		smTransCommand.EParam = dwCmpCode;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
		//코드비교 실패
		return NULL;
	}

	dwCmpCode = Money^dwSeCode[0]^dwSeCode[1];
	if ( dwCmpCode!=dwSeCode[2] ) {

		smTransCommand.WParam = 8020;
		smTransCommand.LParam = 2;
		smTransCommand.SParam = dwSeCode[2];
		smTransCommand.EParam = dwCmpCode;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
		//코드비교 실패
		return NULL;
	}

	dwSvCode = (dwSeCode[0]&0x7FFFFFF)>>16;
	SndCount = dwSeCode[0]&0xFFFF;
	if ( dwSvCode>=8 ) {
		return NULL;
	}

	/////////////////////////// 이사님 07_12_10 
	rsDEBUG_SecCode_SvCode = dwSvCode;
	rsDEBUG_SecCode_SndCount = SndCount;
	////////////////////////////////////

	int	Min,Max,sCnt;
	int	MinCnt;

	Min = 0xFFFF;
	Max = 0;

	for(cnt=0;cnt<16;cnt++) {
		sCnt = lpPlayInfo->RcvItemSecCodeBuff[dwSvCode][cnt];

		if ( sCnt>Max ) Max=sCnt;
		if ( sCnt<Min ) { Min=sCnt; MinCnt=cnt; }
		if ( SndCount==sCnt ) {
			//이미 받은 패킷 카운터를 또 발견
			smTransCommand.WParam = 8020;
			smTransCommand.LParam = 3;
			smTransCommand.SParam = dwSvCode;
			smTransCommand.EParam = SndCount;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			return NULL;
		}
	}

	if ( (Max-16)>SndCount ) {
		//패킷 카운터가 너무 오래됬음
		smTransCommand.WParam = 8020;
		smTransCommand.LParam = 4;
		smTransCommand.SParam = Max;
		smTransCommand.EParam = SndCount;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
		return NULL;
	}

	if ( SndCount>Max ) {
		lpPlayInfo->RcvItemSecCodeBuff[dwSvCode][MinCnt] = SndCount;
	}

	if ( dwSeCode[0]&0x7FFFFFF ) return 2;			//신규 아이템

	return 1;
}

#else

//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
int	rsRegist_ItemSecCode( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommandEx )
{
	return	TRUE;
}
//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
int	rsRegist_ItemSecCode( rsPLAYINFO *lpPlayInfo , TRANS_ITEMINFO *lpTransItemInfo , int NewItem )
{
	return	TRUE;
}
//아이템 정보송수신 구조체에 보안코드 해독 비교 ( 컴파일시 서버에서만 존재 )
int	rsCheck_ItemSecCode( rsPLAYINFO *lpPlayInfo , DWORD dwCode , DWORD dwHead , DWORD dwChkSum , int Money , DWORD dwSeCode_0, DWORD dwSeCode_1, DWORD dwSeCode_2, DWORD dwSeCode_3 , int *pPotionCount )
{
	return	TRUE;
}

#endif


//상점 아이템 구입 받음
int rsRecvBuyShopItem( rsPLAYINFO *lpPlayInfo  , TRANS_BUY_SHOPITEM *lpTransBuyShopItem )
{
	int money;

	if ( !rsServerConfig.ServerInventoryMode ) {
		lpPlayInfo->ServerMoney = 90000000;
	}

	//기력약 못사도록 금지 ( 테섭제외)
	if ( !rsServerConfig.TestSeverMode ) {
		if ( (lpTransBuyShopItem->sItem.sItemInfo.CODE&sinITEM_MASK2)==sinPM1 ) return FALSE;
		//if ( lpTransBuyShopItem->sItem.sItemInfo.CODE==(sinPL1|sin04) ) return FALSE;
	}

	if ( CheckItemForm( &lpTransBuyShopItem->sItem.sItemInfo )==TRUE &&
		lpTransBuyShopItem->sItem.sItemInfo.Price<=lpPlayInfo->ServerMoney &&
		lpTransBuyShopItem->sItem.sItemInfo.dwCreateTime==0 ) {


		ReformItem( &lpTransBuyShopItem->sItem.sItemInfo );
		if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {

			//인벤 아이템 추가
			rsAddInvenItem( lpPlayInfo , lpTransBuyShopItem->sItem.sItemInfo.CODE , 
				lpTransBuyShopItem->sItem.sItemInfo.ItemHeader.Head ,
				lpTransBuyShopItem->sItem.sItemInfo.ItemHeader.dwChkSum );


			//아이템 로그 일반 아이템 ( 출/입 기록 )
			rsRecord_ItemLog( lpPlayInfo , 
				lpTransBuyShopItem->sItem.sItemInfo.CODE , 
				lpTransBuyShopItem->sItem.sItemInfo.ItemHeader.Head ,
				lpTransBuyShopItem->sItem.sItemInfo.ItemHeader.dwChkSum ,
				ITEMLOG_BUYSHOP );


			if ( lpTransBuyShopItem->ItemCount>0 && (lpTransBuyShopItem->sItem.sItemInfo.CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
				//물약은 갯수 만큼 곱한다
				money = lpTransBuyShopItem->sItem.sItemInfo.Price*lpTransBuyShopItem->ItemCount;
				lpPlayInfo->SubServerMoney ( money , WHERE_BUY_POTION );		//물건산돈 제하기
				rsAddServerPotion( lpPlayInfo , lpTransBuyShopItem->sItem.sItemInfo.CODE , lpTransBuyShopItem->ItemCount );	//서버 포션에 물약 추가
	
				switch( (lpTransBuyShopItem->sItem.sItemInfo.CODE&sinITEM_MASK2) ) {
				case sinPL1:
					CurrencyLog.int64_ShopPotionMoney[0] += money;		//생명약
					break;
				case sinPM1:
					CurrencyLog.int64_ShopPotionMoney[1] += money;
					break;
				case sinPS1:
					CurrencyLog.int64_ShopPotionMoney[2] += money;
					break;
				}

			}
			else {
				lpPlayInfo->SubServerMoney ( lpTransBuyShopItem->sItem.sItemInfo.Price , WHERE_BUY_ITEM );		//물건산돈 제하기
				CurrencyLog.int64_ShopMoney += lpTransBuyShopItem->sItem.sItemInfo.Price; //통화량 기록
			}

			return lpPlayInfo->lpsmSock->Send2( (char *)lpTransBuyShopItem , lpTransBuyShopItem->size , TRUE );
		}
	}

	if ( lpTransBuyShopItem->sItem.sItemInfo.Price>lpPlayInfo->ServerMoney ) {
		smTRANS_COMMAND	smTransCommand;
		//로그에 기록
		smTransCommand.WParam = 8010;
		smTransCommand.LParam = 10;
		smTransCommand.SParam = lpPlayInfo->ServerMoney;
		smTransCommand.EParam = lpTransBuyShopItem->sItem.sItemInfo.Price;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

	}

	return FALSE;
}

//상점 아이템 판매
int rsRecvSellShopItem( rsPLAYINFO *lpPlayInfo , TRANS_ITEMINFO *lpTransItemInfo )
{
	smTRANS_COMMAND		smTransCommand;
	smTRANS_COMMAND_EX	smTransCommandEx;

	float Dur[2];		//내구력 
	float Price;		//현재 가격 
	int	  Price2,PriceMax;
	int	  PriceDiv;


	if ( (lpTransItemInfo->Item.CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) || lpTransItemInfo->Item.CODE==(sinGF1|sin01) ) {
		//물약은 팔수 없도록
		return FALSE;
	}

	//팔릴 아이템 검사
	if ( CheckItemForm( &lpTransItemInfo->Item )==FALSE ) {

		//로그에 기록 ( 위조불량 아이템 판매 시도 발견 )
		smTransCommandEx.WParam = 8830;
		smTransCommandEx.LParam = lpTransItemInfo->Item.CODE;
		smTransCommandEx.SParam = lpTransItemInfo->Item.Price;
		smTransCommandEx.EParam = 0;
		RecordHackLogFile( lpPlayInfo , &smTransCommandEx );

		return FALSE;
	}

	//인벤 아이템 제거
	if ( rsDeleteInvenItem( lpPlayInfo , lpTransItemInfo->Item.CODE , 
			lpTransItemInfo->Item.ItemHeader.Head ,
			lpTransItemInfo->Item.ItemHeader.dwChkSum )>=0 ) {


		//내구력을 고려하여 가격 산정
		Dur[0] = lpTransItemInfo->Item.Durability[0];
		Dur[1] = lpTransItemInfo->Item.Durability[1];
		Price  = (float)lpTransItemInfo->Item.Price;

		if(Dur[0] == 0)Dur[0] = 1; //값이 0이되는것을 보정한다 
		if(Dur[1] == 0)Dur[1] = 1;

	
#ifdef	_PLAY_MORYON 
		PriceDiv = 5;
#else
		PriceDiv = 4;
#endif

		Price2 = (int)((Price*(Dur[0]/Dur[1]))+(Price-(Price*(Dur[0]/Dur[1])))*0.25);
		Price2 = Price2/PriceDiv;
		PriceMax = lpTransItemInfo->Item.Price/PriceDiv;

		smTransCommand.code = smTRANSCODE_SHOP_SELLITEM;
		smTransCommand.size = sizeof( smTRANS_COMMAND );
		smTransCommand.WParam = lpTransItemInfo->Item.CODE;
		smTransCommand.LParam = lpTransItemInfo->Item.ItemHeader.Head;
		smTransCommand.SParam = lpTransItemInfo->Item.ItemHeader.dwChkSum;

		if ( PriceMax<Price2 )
			smTransCommand.EParam = PriceMax;
		else
			smTransCommand.EParam = Price2;


		if ( lpPlayInfo->lpsmSock ) {
			lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
		}

		lpPlayInfo->UnsaveMoney = lpTransItemInfo->y - smTransCommand.EParam;
		lpPlayInfo->AddServerMoney( smTransCommand.EParam , WHERE_SELL_ITEM );		//물건판돈 추가

		SaveThrowItem( lpPlayInfo , lpTransItemInfo->Item.CODE, 
			lpTransItemInfo->Item.ItemHeader.Head , 
			lpTransItemInfo->Item.ItemHeader.dwChkSum );

		//아이템 로그 일반 아이템
		rsRecord_ItemLog( lpPlayInfo , 
			lpTransItemInfo->Item.CODE , 
			lpTransItemInfo->Item.ItemHeader.Head , 
			lpTransItemInfo->Item.ItemHeader.dwChkSum , 
			ITEMLOG_SELLSHOP );


	}
	else {

		//로그에 기록
		smTransCommandEx.WParam = 8000;
		smTransCommandEx.WxParam = 10;
		smTransCommandEx.LxParam = (int)lpTransItemInfo->Item.ItemName;
		smTransCommandEx.LParam = lpTransItemInfo->Item.CODE;
		smTransCommandEx.SParam = lpTransItemInfo->Item.ItemHeader.Head;
		smTransCommandEx.EParam = lpTransItemInfo->Item.ItemHeader.dwChkSum;
		RecordHackLogFile( lpPlayInfo , &smTransCommandEx );

	}

	return TRUE;
}


//아이템이 복템인지 검사
int	rsCompareItems( sITEMINFO	*lpItem1 , sITEMINFO	*lpItem2 )
{
	if ( lpItem1->CODE && lpItem1->CODE==lpItem2->CODE ) {
		if ( lpItem1->ItemHeader.dwTime==lpItem2->ItemHeader.dwTime &&
			lpItem1->ItemHeader.dwChkSum==lpItem2->ItemHeader.dwChkSum &&
			lpItem1->ItemHeader.Head ==lpItem2->ItemHeader.Head ) {

				return TRUE;
			}

		if ( lpItem1->ItemHeader.dwChkSum==lpItem2->BackUpChkSum &&
			lpItem1->ItemHeader.Head==lpItem2->BackUpKey ) {

				return TRUE;
			}

		if ( lpItem2->ItemHeader.dwChkSum==lpItem1->BackUpChkSum &&
			lpItem2->ItemHeader.Head==lpItem1->BackUpKey ) {

				return TRUE;
			}

		if ( lpItem1->BackUpChkSum && lpItem1->BackUpKey && 
			lpItem2->BackUpChkSum==lpItem1->BackUpChkSum &&
			lpItem2->BackUpKey==lpItem1->BackUpKey ) {

				return TRUE;
			}
	}

	return FALSE;
}

//땅에 떨어질 아이템 검사
int rsCheckStgAreaItem( STG_AREA *lpStgArea , sITEMINFO	*lpItem )
{
	int cnt;

	if ( lpItem->CODE<sinPM1 && (lpItem->CODE&sinITEM_MASK3)>=sin08 ) {

		for( cnt=0;cnt<STG_ITEM_MAX;cnt++ ) {
			if ( lpStgArea->StgItems[cnt].state ) {
				if ( rsCompareItems( lpItem , &lpStgArea->StgItems[cnt].Item.ItemInfo )==TRUE ) {
					lpStgArea->StgItems[cnt].state = 0;
					return FALSE;
				}
			}
		}

	}

	return TRUE;
}

//데이타 서버로 클라이언트 경유 전송
int rsSendDataServer( smWINSOCK *lpsmSock , void *szData )
{
	TRANS_SEND_DATASERVER	TransSendDataServer;
	int size;


	if ( !lpsmSock ) return FALSE;

	size = ((smTRANS_COMMAND *)szData)->size;

	if ( size>4096 || size<0 ) return FALSE;

	memcpy( TransSendDataServer.szBuff , szData , size );
	TransSendDataServer.code = smTRANSCODE_SEND_DATASERVER;
	TransSendDataServer.size = size+16;

	return lpsmSock->Send2( (char *)&TransSendDataServer , TransSendDataServer.size , TRUE );
}

//게임 서버로 클라이언트 경유 전송
int rsSendGameServer( smWINSOCK *lpsmSock , void *szData )
{
	TRANS_SEND_DATASERVER	TransSendDataServer;
	int size;


	if ( !lpsmSock ) return FALSE;

	size = ((smTRANS_COMMAND *)szData)->size;

	if ( size>4096 || size<0 ) return FALSE;

	memcpy( TransSendDataServer.szBuff , szData , size );
	TransSendDataServer.code = smTRANSCODE_SEND_GAMESERVER;
	TransSendDataServer.size = size+16;

	return lpsmSock->Send2( (char *)&TransSendDataServer , TransSendDataServer.size , TRUE );
}

//게임 지역 서버로 클라이언트 경유 전송
int rsSendAreaServer( smWINSOCK *lpsmSock , void *szData )
{
	TRANS_SEND_DATASERVER	TransSendDataServer;
	int size;


	if ( !lpsmSock ) return FALSE;

	size = ((smTRANS_COMMAND *)szData)->size;

	if ( size>4096 || size<0 ) return FALSE;

	memcpy( TransSendDataServer.szBuff , szData , size );
	TransSendDataServer.code = smTRANSCODE_SEND_AREASERVER;
	TransSendDataServer.size = size+16;

	return lpsmSock->Send2( (char *)&TransSendDataServer , TransSendDataServer.size , TRUE );
}


//게임 지역-메인 서버로 클라이언트 경유 전송
int rsSendAGameServer( smWINSOCK *lpsmSock , void *szData )
{
	TRANS_SEND_DATASERVER	TransSendDataServer;
	int size;


	if ( !lpsmSock ) return FALSE;

	size = ((smTRANS_COMMAND *)szData)->size;

	if ( size>4096 || size<0 ) return FALSE;

	memcpy( TransSendDataServer.szBuff , szData , size );
	TransSendDataServer.code = smTRANSCODE_SEND_AGAME_SERVER;
	TransSendDataServer.size = size+16;

	return lpsmSock->Send2( (char *)&TransSendDataServer , TransSendDataServer.size , TRUE );
}

// pluto 마나 리듀스 포션
//게임 지역-메인 서버로 클라이언트 경유 전송
int rsSendAGameServer_PrimeItem2( smWINSOCK *lpsmSock , void *szData )
{
	TRANS_SEND_DATASERVER	TransSendDataServer;
	int size;


	if ( !lpsmSock ) return FALSE;

	size = ((smTRANS_COMMAND *)szData)->size;

	if ( size>4096 || size<0 ) return FALSE;

	memcpy( TransSendDataServer.szBuff , szData , size );
	TransSendDataServer.code = smTRANSCODE_SEND_AGAME_PRIMEITEM_DATA2;
	TransSendDataServer.size = size+16;

	return lpsmSock->Send2( (char *)&TransSendDataServer , TransSendDataServer.size , TRUE );
}




//보낸 경험치를 돈을 주기적으로 다시 받아서 맞는지 확인
int	rsCheckTotalExpMoney( rsPLAYINFO *lpPlayInfo , TRANS_TOTAL_EXPMONEY *TransTotalExpMoney )
{
	//int Money , Exp;
	int Exp;
	int	ErrorFlag;
	smTRANS_COMMAND	smTransCommand;
/*
	ErrorFlag = 0;

	Money = (TransTotalExpMoney->sServerMoney.TotalX+TransTotalExpMoney->sServerMoney.TotalY)^
		TransTotalExpMoney->sServerMoney.TotalZ;

	if ( Money>lpPlayInfo->spMoney_Out ) ErrorFlag ++;
	if ( TransTotalExpMoney->sServerMoney.InputMoney>lpPlayInfo->spMoney_Out ) ErrorFlag++;
	if ( abs(lpPlayInfo->spMoney_Out-TransTotalExpMoney->sServerMoney.InputMoney)>TOTAL_CHECK_MONEY_MAX ) ErrorFlag++;

	if ( ErrorFlag ) {
		//군서버로 경유 데이타 전송
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
		smTransCommand.WParam = 6510;
		smTransCommand.LParam = TransTotalExpMoney->sServerMoney.InputMoney;
		smTransCommand.SParam = lpPlayInfo->spMoney_Out;
		smTransCommand.EParam = rsServerConfig.ServerCode;
		rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );			//군서버에 보고

		if ( !lpPlayInfo->dwHopeDisconnectTime ) {
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+20*1000;
		}
	}
*/
	ErrorFlag = 0;

	Exp = TransTotalExpMoney->sServerExp.Total1^TransTotalExpMoney->sServerExp.Total2;

	if ( Exp>lpPlayInfo->spEXP_Out ) ErrorFlag ++;
	if ( TransTotalExpMoney->sServerExp.InputExp>lpPlayInfo->spEXP_Out ) ErrorFlag++;
	if ( abs(lpPlayInfo->spEXP_Out-TransTotalExpMoney->sServerExp.InputExp)>(lpPlayInfo->smCharInfo.Level*TOTAL_CHECK_EXP_MAX) ) ErrorFlag++;

	if ( ErrorFlag ) {
		//군서버로 경유 데이타 전송
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
		smTransCommand.WParam = 6500;
		smTransCommand.LParam = TransTotalExpMoney->sServerExp.InputExp;
		smTransCommand.SParam = lpPlayInfo->spEXP_Out;
		smTransCommand.EParam = rsServerConfig.ServerCode;
		rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );			//군서버에 보고

		if ( !lpPlayInfo->dwHopeDisconnectTime ) {
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+20*1000;
		}
	}


	lpPlayInfo->dwLastExpMoneyCheckTime = dwPlayServTime;	//경험치 돈 클라이언트라 비교시간

	return TRUE;
}

#ifdef	_W_SERVER

//군서버로 경험치 정보 보냄
int rsSendGameServerExp( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND	smTransCommand;
	DWORD	dwCodeKey;

	dwCodeKey = dwPlayServTime&0x3FFFFFFF;

	if ( lpPlayInfo->spEXP_Out>0 && (dwPlayServTime-lpPlayInfo->dwLastExpMoneyTransServer)>60*1000 ) {	//60초 간격

		//군 서버로 현재 경험치 내역 전송		
		smTransCommand.code = smTRANSCODE_CHECK_EXPDATA;
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.WParam = rsServerConfig.ServerCode;
		smTransCommand.SParam = (lpPlayInfo->spEXP_Out+11223344)^0x55cc55cc^((dwCodeKey<<17)|(dwCodeKey>>8));
		smTransCommand.EParam = dwCodeKey;

		//보호 코드
		smTransCommand.LParam = (97531*smTransCommand.SParam)^((smTransCommand.EParam<<21)^(smTransCommand.EParam>>5));

		//smTransCommand.SParam = 54321*smTransCommand.LParam+((smTransCommand.EParam<<24)^smTransCommand.EParam);

		rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );			//군서버에 보고
		lpPlayInfo->dwLastExpMoneyTransServer = dwPlayServTime;
	}

	return TRUE;
}

//게임 서버로 부터 경험치 정보 입수
int rsRecvGameServerExp( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	int cnt,code;
	int	sfcode;
	smTRANS_COMMAND	smTransCommand;

	cnt = lpTransCommand->WParam;
	if ( cnt>=0 && cnt<8 ) {

		//보호 코드
		sfcode = (97531*lpTransCommand->SParam)^((lpTransCommand->EParam<<21)^(lpTransCommand->EParam>>5));

		//smTransCommand.LParam = 97531*smTransCommand.SParam+((smTransCommand.EParam<<21)^(smTransCommand.EParam>>5));

		code = lpTransCommand->SParam^0x55cc55cc^((lpTransCommand->EParam<<17)|(lpTransCommand->EParam>>8));
		code -= 11223344;

		//	smTransCommand.SParam = lpPlayInfo->spEXP_Out^0x55cc55cc55^((dwPlayServTime<<16)|(dwPlayServTime>>8));

		if ( lpTransCommand->LParam!=sfcode ) {

			smTransCommand.WParam = 7120;
			smTransCommand.LParam = lpTransCommand->SParam;
			smTransCommand.SParam = sfcode;
			smTransCommand.EParam = code;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			return FALSE;
		}

		if ( (int)lpPlayInfo->dwGameServerExp[cnt]<code )
			lpPlayInfo->dwGameServerExp[cnt] = code;			//서버측 경험치 세팅

		return TRUE;
	}

	return FALSE;
}


//메인 서버로 시간제 빌링 아이템 정보 보냄
int rsSendGameServer_PrimeItem( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND_EX	smTransCommand;
	DWORD	dwCodeKey;
	DWORD	dwMaskKey;
	DWORD	dwServTime_T = (DWORD)tServerTime;

	if ( lpPlayInfo->dwPrimeItem_NextSetTime<dwPlayServTime ) {

		if ( lpPlayInfo->dwTime_PrimeItem_X2<dwServTime_T && lpPlayInfo->dwTime_PrimeItem_ExpUp<dwServTime_T &&
 			 lpPlayInfo->dwTime_PrimeItem_VampCuspid<dwServTime_T && lpPlayInfo->dwTime_PrimeItem_ManaRecharg<dwServTime_T &&
			 lpPlayInfo->dwTime_PrimeItem_ManaReduce < dwServTime_T && lpPlayInfo->dwTime_PrimeItem_MightofAwell < dwServTime_T && 
			 lpPlayInfo->dwTime_PrimeItem_MightofAwell2 < dwServTime_T) // pluto 마나 리듀스 포션 마이트 오브 아웰 마이트 오브 아웰2
		{
			return FALSE;
		}

		dwCodeKey = dwPlayServTime&0x3FFFFFFF;
		lpPlayInfo->dwPrimeItem_NextSetTime = dwPlayServTime+1000*60;		//60초 단위로 보낸다

		dwMaskKey = lpPlayInfo->dwObjectSerial*(lpPlayInfo->dwCode_Name<<3);
		dwMaskKey ^= dwCodeKey;


		//군 서버로 현재 경험치 내역 전송		
		smTransCommand.code = smTRANSCODE_PRIMEITEM_DATA;
		smTransCommand.size = sizeof(smTRANS_COMMAND_EX);
		smTransCommand.WParam = (lpPlayInfo->dwTime_PrimeItem_X2)^dwMaskKey;
		smTransCommand.LParam = (lpPlayInfo->dwTime_PrimeItem_ExpUp)^dwMaskKey;
		smTransCommand.SParam = (lpPlayInfo->dwTime_PrimeItem_X2+lpPlayInfo->dwTime_PrimeItem_ExpUp+smTransCommand.code)^dwMaskKey;
		smTransCommand.EParam = dwCodeKey;
		smTransCommand.WxParam = (lpPlayInfo->dwTime_PrimeItem_VampCuspid)^dwMaskKey;
		smTransCommand.LxParam = (lpPlayInfo->dwTime_PrimeItem_ManaRecharg)^dwMaskKey;
		smTransCommand.SxParam = (lpPlayInfo->dwTime_PrimeItem_VampCuspid+lpPlayInfo->dwTime_PrimeItem_ManaRecharg+smTransCommand.code)^dwMaskKey;
		smTransCommand.ExParam = (lpPlayInfo->dwPrimeItem_PackageCode^((smTransCommand.WParam+smTransCommand.LParam))^dwMaskKey);

		rsSendAGameServer( lpPlayInfo->lpsmSock , &smTransCommand );

		//군 서버로 현재 경험치 내역 전송		
		smTransCommand.code = smTRANSCODE_PRIMEITEM_DATA2;
		smTransCommand.size = sizeof(smTRANS_COMMAND_EX);
		smTransCommand.WParam = (lpPlayInfo->dwTime_PrimeItem_ManaReduce)^dwMaskKey;	// pluto 마나 리듀스 포션
		smTransCommand.LParam = (lpPlayInfo->dwTime_PrimeItem_MightofAwell)^dwMaskKey;	// pluto 마이트 오브 아웰
		smTransCommand.SParam = (lpPlayInfo->dwTime_PrimeItem_ManaReduce+lpPlayInfo->dwTime_PrimeItem_MightofAwell+smTransCommand.code)^dwMaskKey;
		smTransCommand.EParam = dwCodeKey;
		smTransCommand.WxParam = (lpPlayInfo->dwTime_PrimeItem_MightofAwell2)^dwMaskKey;
		smTransCommand.LxParam = (0)^dwMaskKey;
		smTransCommand.SxParam = (0)^dwMaskKey;
		//smTransCommand.ExParam = (lpPlayInfo->dwPrimeItem_PackageCode^((smTransCommand.WParam+smTransCommand.LParam))^dwMaskKey);

		rsSendAGameServer_PrimeItem2( lpPlayInfo->lpsmSock , &smTransCommand );
	}

	return TRUE;
}


// pluto 마나 리듀스
// pluto 서버로 시간제 빌링 아이템 정보 보냄
int rsSendGameServer_PrimeItem2( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND_EX	smTransCommand;
	DWORD	dwCodeKey;
	DWORD	dwMaskKey;
	DWORD	dwServTime_T = (DWORD)tServerTime;

	if ( lpPlayInfo->dwPrimeItem_NextSetTime<dwPlayServTime ) {

		if ( lpPlayInfo->dwTime_PrimeItem_X2<dwServTime_T && lpPlayInfo->dwTime_PrimeItem_ExpUp<dwServTime_T &&
			lpPlayInfo->dwTime_PrimeItem_VampCuspid<dwServTime_T && lpPlayInfo->dwTime_PrimeItem_ManaRecharg<dwServTime_T &&
			lpPlayInfo->dwTime_PrimeItem_ManaReduce < dwServTime_T && lpPlayInfo->dwTime_PrimeItem_MightofAwell < dwServTime_T &&
			lpPlayInfo->dwTime_PrimeItem_MightofAwell2 < dwServTime_T ) // pluto 마나 리듀스 포션 마이트 오브 아웰 마이트 오브 아웰2
		{
			return FALSE;
		}

		dwCodeKey = dwPlayServTime&0x3FFFFFFF;
		lpPlayInfo->dwPrimeItem_NextSetTime = dwPlayServTime+1000*60;		//60초 단위로 보낸다

		dwMaskKey = lpPlayInfo->dwObjectSerial*(lpPlayInfo->dwCode_Name<<3);
		dwMaskKey ^= dwCodeKey;


		//군 서버로 현재 경험치 내역 전송		
		smTransCommand.code = smTRANSCODE_PRIMEITEM_DATA2;
		smTransCommand.size = sizeof(smTRANS_COMMAND_EX);
		smTransCommand.WParam = (lpPlayInfo->dwTime_PrimeItem_ManaReduce)^dwMaskKey;
		smTransCommand.LParam = (lpPlayInfo->dwTime_PrimeItem_MightofAwell)^dwMaskKey;	// pluto 마이트 오브 아웰
		smTransCommand.SParam = (lpPlayInfo->dwTime_PrimeItem_ManaReduce+lpPlayInfo->dwTime_PrimeItem_MightofAwell+smTransCommand.code)^dwMaskKey;
		smTransCommand.EParam = dwCodeKey;
		smTransCommand.WxParam = (lpPlayInfo->dwTime_PrimeItem_MightofAwell2)^dwMaskKey;
		smTransCommand.LxParam = (0)^dwMaskKey;
		smTransCommand.SxParam = (0)^dwMaskKey;
		//smTransCommand.ExParam = (lpPlayInfo->dwPrimeItem_PackageCode^((smTransCommand.WParam+smTransCommand.LParam))^dwMaskKey);

		rsSendAGameServer_PrimeItem2( lpPlayInfo->lpsmSock , &smTransCommand );
	}

	return TRUE;
}

//게임 서버로 부터 빌링아이템 정보 입수
int rsRecvGameServer_PrimeItem( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommand )
{

	DWORD	dwCodeKey;
	DWORD	dwMaskKey;

	smTRANS_COMMAND_EX	smTransCommand;

	memcpy( &smTransCommand , lpTransCommand , sizeof(smTRANS_COMMAND_EX) );

	dwCodeKey = lpTransCommand->EParam;
	dwMaskKey = lpPlayInfo->dwObjectSerial*(lpPlayInfo->dwCode_Name<<3);
	dwMaskKey ^= dwCodeKey;

	smTransCommand.WParam ^= dwMaskKey;
	smTransCommand.LParam ^= dwMaskKey;
	smTransCommand.SParam ^= dwMaskKey;
	smTransCommand.WxParam ^= dwMaskKey;
	smTransCommand.LxParam ^= dwMaskKey;
	smTransCommand.SxParam ^= dwMaskKey;
	smTransCommand.ExParam ^= (lpTransCommand->WParam+lpTransCommand->LParam)^dwMaskKey;

	if ( smTransCommand.SParam==((smTransCommand.WParam+smTransCommand.LParam+smTransCommand.code)) ) {
		lpPlayInfo->dwTime_PrimeItem_X2 = smTransCommand.WParam;
		lpPlayInfo->dwTime_PrimeItem_ExpUp = smTransCommand.LParam;
	}
	if ( smTransCommand.SxParam==((smTransCommand.WxParam+smTransCommand.LxParam+smTransCommand.code)) ) {
		lpPlayInfo->dwTime_PrimeItem_VampCuspid = smTransCommand.WxParam;
		lpPlayInfo->dwTime_PrimeItem_ManaRecharg = smTransCommand.LxParam;
	}

	if ( smTransCommand.WParam || smTransCommand.LParam ) {
		lpPlayInfo->dwPrimeItem_PackageCode = smTransCommand.ExParam;
	}

	return TRUE;
}

// pluto 마나 리듀스 포션
// pluto 마이트 오브 아웰	마이트 오브 아웰2
// pluto 게임 서버로 부터 빌링아이템 정보 입수
int rsRecvGameServer_PrimeItem2( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommand )
{

	DWORD	dwCodeKey;
	DWORD	dwMaskKey;

	smTRANS_COMMAND_EX	smTransCommand;

	memcpy( &smTransCommand , lpTransCommand , sizeof(smTRANS_COMMAND_EX) );

	dwCodeKey = lpTransCommand->EParam;
	dwMaskKey = lpPlayInfo->dwObjectSerial*(lpPlayInfo->dwCode_Name<<3);
	dwMaskKey ^= dwCodeKey;

	smTransCommand.WParam ^= dwMaskKey;
	smTransCommand.LParam ^= dwMaskKey;
	smTransCommand.SParam ^= dwMaskKey;
	smTransCommand.WxParam ^= dwMaskKey;
	smTransCommand.LxParam ^= dwMaskKey;
	smTransCommand.SxParam ^= dwMaskKey;
	smTransCommand.ExParam ^= (lpTransCommand->WParam+lpTransCommand->LParam)^dwMaskKey;

	if( smTransCommand.SParam == (smTransCommand.WParam+smTransCommand.LParam+smTransCommand.code) )
	{
		lpPlayInfo->dwTime_PrimeItem_ManaReduce = smTransCommand.WParam;
		lpPlayInfo->dwTime_PrimeItem_MightofAwell = smTransCommand.LParam;
	}
	if ( smTransCommand.SxParam==((smTransCommand.WxParam+smTransCommand.LxParam+smTransCommand.code)) )
	{
		lpPlayInfo->dwTime_PrimeItem_MightofAwell2 = smTransCommand.WxParam;
		//lpPlayInfo->dwTime_PrimeItem_ManaRecharg = smTransCommand.LxParam;
	}
	if ( smTransCommand.WParam || smTransCommand.LParam )
	{
		lpPlayInfo->dwPrimeItem_PackageCode = smTransCommand.ExParam;
	}
	return TRUE;
}

///
//게임 서버로 피시방펫 정보 보냄
int rsSendAreaServer_PCBangPet( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND	smTransCommand;
	DWORD	dwCodeKey;
	DWORD	dwMaskKey;


	if ( lpPlayInfo->dwObjectSerial && lpPlayInfo->dwPCBang_Pet_NextSetTime<dwPlayServTime && lpPlayInfo->Bl_RNo>0 ) {

		if ( !lpPlayInfo->dwPCBang_Pet_NextSetTime ) {
			//펫 클라이언트에 생성
			ZeroMemory( &smTransCommand , sizeof(smTRANS_COMMAND) );
			smTransCommand.code = smTRANSCODE_PCBANG_PET;
			smTransCommand.size = sizeof(smTRANS_COMMAND);
			lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
		}


		dwCodeKey = dwPlayServTime&0x3FFFFFFF;
		lpPlayInfo->dwPCBang_Pet_NextSetTime = dwPlayServTime+1000*17;		//17초 단위로 보낸다

		dwMaskKey = lpPlayInfo->dwObjectSerial*(lpPlayInfo->dwCode_Name<<3);
		dwMaskKey ^= dwCodeKey;


		//지역서버로 피시방 정보 전송		
		smTransCommand.code = smTRANSCODE_PCBANG_PET;
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.WParam = (lpPlayInfo->Bl_RNo)^dwMaskKey;
		smTransCommand.LParam = (lpPlayInfo->dwPCBang_Pet_NextSetTime)^dwMaskKey;
		smTransCommand.SParam = (lpPlayInfo->Bl_RNo+lpPlayInfo->dwPCBang_Pet_NextSetTime+smTransCommand.code)^dwMaskKey;
		smTransCommand.EParam = dwCodeKey;

		rsSendAGameServer( lpPlayInfo->lpsmSock , &smTransCommand );			//게임서버에 보고
	}

	return TRUE;
}

//게임 서버로 부터 피시방펫 정보 입수
int rsRecvAreaServer_PCBangPet( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{

	DWORD	dwCodeKey;
	DWORD	dwMaskKey;

	smTRANS_COMMAND	smTransCommand;

	memcpy( &smTransCommand , lpTransCommand , sizeof(smTRANS_COMMAND) );

	dwCodeKey = lpTransCommand->EParam;
	dwMaskKey = lpPlayInfo->dwObjectSerial*(lpPlayInfo->dwCode_Name<<3);
	dwMaskKey ^= dwCodeKey;

	smTransCommand.WParam ^= dwMaskKey;
	smTransCommand.LParam ^= dwMaskKey;
	smTransCommand.SParam ^= dwMaskKey;

	if ( smTransCommand.SParam==((smTransCommand.WParam+smTransCommand.LParam+smTransCommand.code)) ) {
		lpPlayInfo->Bl_RNo = smTransCommand.WParam;
		return TRUE;
	}

	return FALSE;
}

///


//지역서버로 포스오브 정보 보냄
int rsSendAreaServerForceOrb( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND	smTransCommand;
	DWORD	dwCodeKey;
	DWORD	dwMaskKey;

	if ( lpPlayInfo->dwForceOrb_SaveTime && lpPlayInfo->dwForceOrb_SaveTime>dwPlayServTime ) {

		if ( lpPlayInfo->dwForceOrb_NextSetTime && lpPlayInfo->dwForceOrb_NextSetTime>dwPlayServTime ) 
			return FALSE;

		dwCodeKey = dwPlayServTime&0x3FFFFFFF;
		lpPlayInfo->dwForceOrb_NextSetTime = dwPlayServTime+1000*30;		//30초 단위로 보낸다

		dwMaskKey = lpPlayInfo->dwObjectSerial*(lpPlayInfo->dwCode_Name<<3);
		dwMaskKey ^= dwCodeKey;


		//군 서버로 현재 경험치 내역 전송		
		smTransCommand.code = smTRANSCODE_FORCEORB_DATA;
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.WParam = (lpPlayInfo->dwForceOrb_SaveCode)^dwMaskKey;
		smTransCommand.LParam = (lpPlayInfo->dwForceOrb_SaveTime-dwPlayServTime)^dwMaskKey;
		smTransCommand.SParam = lpPlayInfo->dwForceOrb_SaveDamage^dwMaskKey;
		smTransCommand.EParam = dwCodeKey;

		rsSendAreaServer( lpPlayInfo->lpsmSock , &smTransCommand );			//군서버에 보고
	}
	else {
		lpPlayInfo->dwForceOrb_NextSetTime = 0;
		lpPlayInfo->dwForceOrb_SaveCode = 0;
		lpPlayInfo->dwForceOrb_SaveTime = 0;
		lpPlayInfo->dwForceOrb_SaveDamage = 0;
	}

	//메인 서버로 시간제 빌링 아이템 정보 보냄
	rsSendGameServer_PrimeItem( lpPlayInfo );

	if ( rsServerConfig.Event_PCBangPet ) {
		//지역 서버로 피시방 펫정보 보냄
		rsSendAreaServer_PCBangPet( lpPlayInfo );
	}

	return TRUE;
}

//게임 서버로 부터 경험치 정보 입수
int rsRecvAreaServerForceOrb( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{

	DWORD	dwCodeKey;
	DWORD	dwMaskKey;
	int		cnt;
	smTRANS_COMMAND	smTransCommand;

	memcpy( &smTransCommand , lpTransCommand , sizeof(smTRANS_COMMAND) );

	dwCodeKey = lpTransCommand->EParam;
	dwMaskKey = lpPlayInfo->dwObjectSerial*(lpPlayInfo->dwCode_Name<<3);
	dwMaskKey ^= dwCodeKey;

	smTransCommand.WParam ^= dwMaskKey;
	smTransCommand.LParam ^= dwMaskKey;
	smTransCommand.SParam ^= dwMaskKey;

	if ( (smTransCommand.WParam&sinITEM_MASK2)!=sinFO1 ) return FALSE;

	cnt = (smTransCommand.WParam&sinITEM_MASK3)>>8;
	cnt --;
	if ( cnt>=0 && cnt<10 && smTransCommand.SParam<=ForceOrbDamage[cnt] && smTransCommand.LParam<=(ForceOrbUseTime[cnt]*1000)) {
		//포스오브 수치 갱신
		lpPlayInfo->dwForceOrb_Code = smTransCommand.WParam;
		lpPlayInfo->dwForceOrb_Time  = dwPlayServTime+smTransCommand.LParam;
		lpPlayInfo->dwForceOrb_Damage  = smTransCommand.SParam;
		return TRUE;
	}

	return FALSE;
}





#else

//군서버로 경험치 정보 보냄
int rsSendGameServerExp( rsPLAYINFO *lpPlayInfo )
{
	return TRUE;
}
//게임 서버로 부터 경험치 정보 입수
int rsRecvGameServerExp( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	return TRUE;
}

#endif






////////////////////////// 이벤트 몬스터 관련 함수 /////////////////////////////
// 같은 종류의 이벤트 몬스터 생성
int rsReOpenEventMonster( STG_AREA *lpStgArea , smCHAR *lpChar )
{
	STG_CHAR_INFO StgCharInfo;
	int cnt;

	if ( !lpChar->smMonsterInfo.EventCode || !lpStgArea ) return FALSE;

	if ( lpChar->smMonsterInfo.EventCode==100 && !dwServ_NightDay ) 
		return FALSE;


	for(cnt=0;cnt<chrMonsterCnt;cnt++) {
		if ( chrMonsterList[cnt].lpMonInfo->EventCode==lpChar->smMonsterInfo.EventCode &&
			chrMonsterList[cnt].lpMonInfo->EventInfo==lpChar->smMonsterInfo.EventInfo &&
			lstrcmp( chrMonsterList[cnt].szName , lpChar->smCharInfo.szName )==0 ) {

				memcpy(	&StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) ); 
				lpStgArea->EvnMonster = TRUE;
				lpStgArea->OpenMonster( &StgCharInfo , 0 );
				break;
		}
	}


	return TRUE;
}



//이벤트 몬스터 생성
int rsOpenEventMonster( int EventCode , int wParam , int lParam , int sParam )
{

	STG_CHAR_INFO StgCharInfo;
	STG_AREA	*lpStgArea;

	int cnt;
//	for( cnt=0;cnt<STAGE_AREA_MAX;cnt++ ) {
//		if ( lpStgArea==&StageArea[cnt] )

	switch( EventCode ) {
		case 100:
			for(cnt=0;cnt<chrMonsterCnt;cnt++) {
				if ( chrMonsterList[cnt].lpMonInfo && chrMonsterList[cnt].lpMonInfo->EventCode==EventCode ) {
					memcpy(	&StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) ); 

					lpStgArea = &StageArea[chrMonsterList[cnt].lpMonInfo->EventInfo];

					lpStgArea->EvnMonster = TRUE;
					lpStgArea->OpenMonster( &StgCharInfo , 0 );
					lpStgArea->StartPosRandomize();
				}
			}
			break;

		case 110:


			break;
	}


	return FALSE;
}

//이벤트 몬스터 제거
int rsCloseEventMonster( int EventCode )
{
	int cnt;

	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag && chrAutoPlayer[cnt].smMonsterInfo.EventCode==EventCode ) {
			/*
			chrAutoPlayer[cnt].Close();
			*/
			if ( chrAutoPlayer[cnt].MotionInfo->State!=CHRMOTION_STATE_DEAD ) {
				if ( chrAutoPlayer[cnt].SetMotionFromCode(CHRMOTION_STATE_WARP)==FALSE ) {
					chrAutoPlayer[cnt].Close();
				}

				if ( chrAutoPlayer[cnt].lpExt1 ) {
					((STG_AREA *)chrAutoPlayer[cnt].lpExt1)->MonsterCount--;
					((STG_AREA *)chrAutoPlayer[cnt].lpExt1)->DeleteMonTable( &chrAutoPlayer[cnt] );
				}
			}
			else {
				chrAutoPlayer[cnt].Close();
				if ( chrAutoPlayer[cnt].lpExt1 ) {
					((STG_AREA *)chrAutoPlayer[cnt].lpExt1)->MonsterCount--;
					((STG_AREA *)chrAutoPlayer[cnt].lpExt1)->DeleteMonTable( &chrAutoPlayer[cnt] );
				}
			}
		}
	}

	return TRUE;
}


//int rsReOpenEventMonster( STG_AREA *lpStgArea , smCHAR *lpChar )
/*
struct sBOSS_MONSTER {
	smCHAR_INFO		*MasterMonster;			//보스급 몬스터
	smCHAR_INFO		*SlaveMonster;			//수행 몬스터
	int				SlaveCount;				//수행 몬스터 숫자
	BYTE			bOpenTime[32];			//나타나는 시간
	int				OpenTimeCount;			//시간 수
};
*/

//보스 몬스터세트 생성
int rsOpenBossMonster( STG_AREA *lpStgArea , sBOSS_MONSTER *lpBossMonster )
{

	STG_CHAR_INFO StgCharInfo;
	int cnt;
	POINT3D	pos3D;
	smCHAR	*lpChar;

	if ( lpBossMonster->MasterMonster->dwCharSoundCode==snCHAR_SOUND_BABEL && 
		lpStgArea->lpField ) {//&& lpStgArea->lpField->FieldCode==rsBABEL_FIELD ) {
			//보스몬스터 바벨은 특정 위치에서 출현하도록 설정

			if ( dwBabelPlayTime>dwPlayServTime ) {
				//현재 이미 바벨이 출현중..
				return FALSE;
			}


			if ( lpStgArea->lpField->FieldCode==rsBABEL_FIELD ) {
				//아이언1
				pos3D.x = 50172*fONE;
				pos3D.y = 0;
				pos3D.z = 13193*fONE;
			}
			else {
				//아이언2
				pos3D.x = 37086*fONE;
				pos3D.y = 0;
				pos3D.z = 26425*fONE;
			}

			lprsFixedPoint = &pos3D;
			BabelPlayField = lpStgArea->lpField->FieldCode;


			//스턴 카운트 ( 아이언 지형 몹들 8초간 스턴 )
			for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
				if ( lpStgArea->lpCharMonster[cnt] ) {
					if ( lpStgArea->lpCharMonster[cnt]->Flag && lpStgArea->lpCharMonster[cnt]->MotionInfo->State!=CHRMOTION_STATE_DEAD ) {
						lpStgArea->lpCharMonster[cnt]->SetMotionFromCode(CHRMOTION_STATE_DAMAGE);
						lpStgArea->lpCharMonster[cnt]->PlayStunCount = 16*8;		//8초간 멈춘다
					}
				}
			}
		}

	//발렌토 출현
	if ( lpBossMonster->MasterMonster->dwCharSoundCode==snCHAR_SOUND_DEATHKNIGHT && 
		lpStgArea->lpField && lpStgArea->lpField->FieldCode==31 ) 
	{

		pos3D.x = 34042*fONE;
		pos3D.y = 0;
		pos3D.z = 36709*fONE;
		lprsFixedPoint = &pos3D;

	}

	//켈베쥬 출현
	if ( lpBossMonster->MasterMonster->dwCharSoundCode==snCHAR_SOUND_KELVEZU && 
		lpStgArea->lpField && lpStgArea->lpField->FieldCode==rsKELVEZU_FIELD ) 
	{

		pos3D.x = 33023*fONE;
		pos3D.y = 0;
		pos3D.z = 52608*fONE;
		lprsFixedPoint = &pos3D;
/*
		if ( lpStgArea->lpField->FieldCode==rsKELVEZU_FIELD )
			KelvezuPlayField = lpStgArea->lpField->FieldCode-1;
*/
	}

	if ( lpBossMonster->MasterMonster->dwCharSoundCode==snCHAR_SOUND_MOKOVA && 
		lpStgArea->lpField && lpStgArea->lpField->FieldCode==rsMOKOVA_FIELD ) 
	{

		pos3D.x = -12057*fONE;
		pos3D.y = 0;
		pos3D.z = 13225*fONE;
		lprsFixedPoint = &pos3D;
	}




	//보스급 몬스터 셋팅
	if ( lpBossMonster->MasterMonster ) {
		memcpy(	&StgCharInfo.smCharInfo , lpBossMonster->MasterMonster , sizeof( smCHAR_INFO ) ); 
		lpStgArea->EvnMonster = TRUE;
		lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
		lpStgArea->StartPointCnt = lpStgArea->StartPointLastOpenCount;
	}

	//수행 몬스터
	if ( lpBossMonster->SlaveMonster ) {
		memcpy(	&StgCharInfo.smCharInfo , lpBossMonster->SlaveMonster , sizeof( smCHAR_INFO ) ); 
		lpStgArea->EvnMonster = TRUE;
		lpStgArea->OpenMonster( &StgCharInfo , lpBossMonster->SlaveCount );
	}

	if ( lprsFixedPoint ) {
		lprsFixedPoint = 0;
		if ( lpChar ) {
			lpChar->lpAttackDamageList = new ATTACK_DAMAGE_LIST[ ATTACK_DAMAGE_LIST_MAX ];
			if ( lpChar->lpAttackDamageList )
				ZeroMemory( lpChar->lpAttackDamageList , sizeof(ATTACK_DAMAGE_LIST)*ATTACK_DAMAGE_LIST_MAX );
		}
	}

	return FALSE;
}

//주변 유저에게 명령 보냄
int	rsSendCommandUser( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX	*lpTransCommandEx )
{
	int cnt;
	int rx,rz,dist;
	int x,z;

	lpTransCommandEx->code = smTRANSCODE_COMMAND_USER;
	lpTransCommandEx->size = sizeof(smTRANS_COMMAND_EX);

	x = lpPlayInfo->Position.x;
	z = lpPlayInfo->Position.z;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial) {
			rx = (x-rsPlayInfo[cnt].Position.x)>>FLOATNS;
			rz = (z-rsPlayInfo[cnt].Position.z)>>FLOATNS;
			dist = rx*rx+rz*rz;

			if ( dist<DIST_TRANSLEVEL_HIGH && abs(rx)<TRANS_VIEW_LIMIT && abs(rz)<TRANS_VIEW_LIMIT ) {
				rsPlayInfo[cnt].lpsmSock->Send( (char *)lpTransCommandEx , lpTransCommandEx->size , TRUE );
			}
		}
	}

	return TRUE;
}

//주변 유저에게 명령 보냄
int	rsSendCommandUser2( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	int cnt;
	int rx,rz,dist;
	int x,z;

	x = lpPlayInfo->Position.x;
	z = lpPlayInfo->Position.z;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial) {
			rx = (x-rsPlayInfo[cnt].Position.x)>>FLOATNS;
			rz = (z-rsPlayInfo[cnt].Position.z)>>FLOATNS;
			dist = rx*rx+rz*rz;

			if ( dist<DIST_TRANSLEVEL_HIGH && abs(rx)<TRANS_VIEW_LIMIT && abs(rz)<TRANS_VIEW_LIMIT ) {
				rsPlayInfo[cnt].lpsmSock->Send( (char *)lpTransCommand , lpTransCommand->size , TRUE );
			}
		}
	}

	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////

/*
smTRANSCODE_SHOP_ITEMLIST
//상점 아이템 정보
struct smTRANS_SELL_ITEM {
	int size,code;
	int	ItemKind;					//공격 / 방어 /기타 등등의 구분
	int	ItemCounter;				//판매 아이템의 수
	int	Ext[4];						//예비
};
	//NPC 상점 판매 정보
	int		SellAttackItemCount;
	void	*SellAttackItem[32];	//공격 아이템
	int		SellDefenceItemCount;
	void	*SellDefenceItem[32];	//방어 아이템
	int		SellEtcItemCount;
	void	*SellEtcItem[32];		//기타 아이템

*/

//기본 아이템 설정
//int srSetItemFromCode( psITEM *lpsItem , char *szCoed )


// 문자열 비교 짧은 문장의 길이만큼 비교하여 비교 종료 포인터 반환
static int rsCompString( char *src1 , char *src2 )
{
	int cnt;
	int len1,len2;
	int len;

	len1 = lstrlen( src1 );
	len2 = lstrlen( src2 );

	if ( len1<len2 ) len = len1;
	else len = len2;

	if ( !len ) return NULL;

	for( cnt=0; cnt<len1; cnt++ ) {
		if ( src1[cnt]==0 ) break;
		if ( src1[cnt]!=src2[cnt] ) return NULL;
	}

	return cnt;
}

char *rsGetWord(char *q , char *p)
{

//	while ( *p != '\n' ) {
	if ( *p==0 ) { *q=0; return p; }

		while ( (*p == 32) || (*p == 9) || (*p == 58) ) // SPACE or TAB or ':'는 제외 시킴
		{
			p++;
		}

		while ( (*p != 32) && (*p != 9) && (*p != 58) && (*p != 0 ) ) // SPACE or TAB
		{
			if ( *p == '\n' || *p=='\r' ) break;
			*q++ = *p++;
		}
		*q++ = 0;	// end of one string, put Null character
//	}
//	*q = '\n';

	return p;
}


rsPLAYINFO *FindUserFromName( char *szName )
{
	int cnt;

	for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].TransInfoFlag ) {
			if ( lstrcmpi(rsPlayInfo[cnt].smCharInfo.szName , szName )==0 ) {
				return &rsPlayInfo[cnt];
			}
		}
	}

	return NULL;
}

rsPLAYINFO *FindUserFromName2( char *szName )
{
	int cnt;

	for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
		if ( rsPlayInfo[cnt].lpsmSock ) {
			if ( lstrcmpi(rsPlayInfo[cnt].szName , szName )==0 ) {
				return &rsPlayInfo[cnt];
			}
		}
	}

	return NULL;
}

//스킨핵 방지
rsPLAYINFO *FindUserFromCode( DWORD dwUserCode )
{
	int cnt;

	if ( dwUserCode ) {
		for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial==dwUserCode ) {
				return &rsPlayInfo[cnt];
			}
		}
	}

	return NULL;
}


rsPLAYINFO *FindUserFromName3( char *szName )
{
	int cnt;

	for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
		if ( rsPlayInfo[cnt].lpsmSock ) {
			if ( rsPlayInfo[cnt].szName[0] ) {
				if ( lstrcmpi(rsPlayInfo[cnt].szName , szName )==0 ) {
					return &rsPlayInfo[cnt];
				}
			}
			else {
				if ( lstrcmpi(rsPlayInfo[cnt].smCharInfo.szName , szName )==0 ) {
					return &rsPlayInfo[cnt];
				}
			}
		}
	}

	return NULL;
}

rsPLAYINFO *FindUserFromCodeName( char *szName , DWORD dwSpeedSum )
{
	int cnt;

	for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
		if ( rsPlayInfo[cnt].lpsmSock ) {
			if ( rsPlayInfo[cnt].dwCode_Name==dwSpeedSum && lstrcmpi(rsPlayInfo[cnt].szName , szName )==0 ) {
				return &rsPlayInfo[cnt];
			}
		}
	}

	return NULL;
}


rsPLAYINFO *FindUserFromID( char *szID )
{
	int cnt;

	for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] ) {
			if ( lstrcmpi(rsPlayInfo[cnt].szID , szID )==0 ) {
				return &rsPlayInfo[cnt];
			}
		}
	}

	return NULL;
}


/*
		lpStgItem = lpStgArea->FindItem( lpTransActionItem->x>>FLOATNS , lpTransActionItem->y>>FLOATNS , lpTransActionItem->z>>FLOATNS );
		if ( lpStgItem ) {
			//아이템 집음
			//아이템 보내기
			//lpStgItem->
			TRANS_ITEMINFO	TransItemInfo;

			TransItemInfo.code = smTRANSCODE_PUTITEM;
			TransItemInfo.size = sizeof(TRANS_ITEMINFO);
			memcpy( &TransItemInfo.Item , &lpStgItem->Item.ItemInfo , sizeof( sITEMINFO ) );
			lpsmSock->Send( (char *)&TransItemInfo , TransItemInfo.size , TRUE );

			//lpStgItem->state = 0;
			lpStgArea->DeleteItem( lpStgItem );

		}
*/

//선물형 아이템 생성
int CreatePresentItem( DWORD dwItemCode , STG_AREA *lpStgArea , int x, int y, int z , int count )
{
	psITEM			psItem;
	int				cnt;
	STG_ITEMS		*lpStgItem;

	ZeroMemory( &psItem , sizeof(psITEM) );

	for(cnt=0;cnt<DefaultItemCount;cnt++) {
		if ( DefaultItems[cnt].Item.CODE==dwItemCode && !DefaultItems[cnt].Item.UniqueItem ) {
			CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt] );

			psItem.state = TRUE;
			if ( (psItem.ItemInfo.CODE&sinITEM_MASK2)==(sinPM1&sinITEM_MASK2) ) {
				psItem.ItemInfo.PotionCount = (rand()%count)+1;						//물약 갯수 
			}

			lpStgItem = lpStgArea->AddItem( &psItem , x>>FLOATNS, y>>FLOATNS, z>>FLOATNS , TRUE );
			lpStgItem->dwCreateTime += 5000;		


			return TRUE;
		}
	}
	return FALSE;	
}


//아이템 생성 명령
int CreateCommandItem( rsPLAYINFO *lpPlayInfo , rsPLAYINFO *lpPlayInfo2, char *szItem )
{
	psITEM			*lpsItem;
	STG_AREA		*lpStgArea;
	TRANS_ITEMINFO	TransItemInfo;
	char		szItemName[32];
	int cnt,cnt2,len;
	int val;

	val = FALSE;

	if ( spJobCodeTime<dwPlayServTime ) {
		spJobCode = 0;
		spItemNormal = 0;
		spJobCodeTime = 0;
	}

	if ( spTimeAdjustTime<dwPlayServTime ) {
		spTimeAdjustTime = 0;
		spTimeAdjust = 0;
	}

	//저레벨 권한 없음
	if ( lpPlayInfo->AdminMode<4 && szItem[0]!='@' ) return FALSE;

	lpsItem = new psITEM;

	if ( szItem[0]!='\"' ) {
		if ( szItem[0]!='@' ) {
			if ( srSetItemFromCode( lpsItem , szItem )==TRUE ) {
				if ( lpPlayInfo2 ) {
					//상대방한테 전달
					if ( lpPlayInfo2->lpsmSock ) {
						TransItemInfo.code = smTRANSCODE_PUTITEM;
						TransItemInfo.size = sizeof(TRANS_ITEMINFO);
						memcpy( &TransItemInfo.Item , &lpsItem->ItemInfo , sizeof( sITEMINFO ) );

						//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
						rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );

						lpPlayInfo2->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
						val = TRUE;
					}
				}
				else {
					//(땅에 떨어뜨림)
					lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );
					if ( lpStgArea ) {
						lpsItem->state = TRUE;
						lpStgArea->AddItem( lpsItem , lpPlayInfo->Position.x>>FLOATNS, lpPlayInfo->Position.y>>FLOATNS, lpPlayInfo->Position.z>>FLOATNS , TRUE );
						val = TRUE;
					}
				}
			}
		}
		else {
			//이전에 생성된 아이템 코드를 찾아 설정
			if ( srSetItemFromLogData( lpsItem , szItem+1 )==TRUE ) {
				if ( lpPlayInfo2 ) {				
					//상대방한테 전달
					if ( lpPlayInfo2->lpsmSock ) {
						TransItemInfo.code = smTRANSCODE_PUTITEM;
						TransItemInfo.size = sizeof(TRANS_ITEMINFO);
						memcpy( &TransItemInfo.Item , &lpsItem->ItemInfo , sizeof( sITEMINFO ) );
						rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
						lpPlayInfo2->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
						val = TRUE;
					}
				}
				else {
					//바닥에 떨굼
					lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );
					if ( lpStgArea ) {
						lpsItem->state = TRUE;
						lpStgArea->AddItem( lpsItem , lpPlayInfo->Position.x>>FLOATNS, lpPlayInfo->Position.y>>FLOATNS, lpPlayInfo->Position.z>>FLOATNS , TRUE );
						val = TRUE;
					}
				}
			}
		}
	}
	else {
		cnt2=0;
		len=lstrlen(szItem);
		for(cnt=1;cnt<len;cnt++) {
			if ( szItem[cnt]=='\"' ) {szItemName[cnt2]=0;break;}
			szItemName[cnt2++] = szItem[cnt];
		}

		//이름으로 검색 ( 유니크 아이템등 )
		if ( srSetItemFromName( lpsItem , szItemName )==TRUE ) {
			if ( lpPlayInfo2 ) {				
				//상대방한테 전달
				if ( lpPlayInfo2->lpsmSock ) {
					TransItemInfo.code = smTRANSCODE_PUTITEM;
					TransItemInfo.size = sizeof(TRANS_ITEMINFO);
					memcpy( &TransItemInfo.Item , &lpsItem->ItemInfo , sizeof( sITEMINFO ) );
					rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
					lpPlayInfo2->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
					val = TRUE;
				}
			}
			else {
				//바닥에 떨굼
				lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );
				if ( lpStgArea ) {
					lpsItem->state = TRUE;
					lpStgArea->AddItem( lpsItem , lpPlayInfo->Position.x>>FLOATNS, lpPlayInfo->Position.y>>FLOATNS, lpPlayInfo->Position.z>>FLOATNS , TRUE );
					val = TRUE;
				}
			}
		}
	}
	delete lpsItem;

	return val;
}

//포인트 티켓 아이템 특정 유저의 인벤토리보냄
int rsPutItem_PointTicket( rsPLAYINFO *lpPlayInfo , int Price )
{
	TRANS_ITEMINFO	TransItemInfo;
	psITEM	psItem;
	int cnt;

	for(cnt=0;cnt<DefaultItemCount;cnt++) {
		if ( DefaultItems[cnt].Item.CODE==(sinGF1|sin01) && !DefaultItems[cnt].Item.UniqueItem ) {
			CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt] );

			if ( lpPlayInfo->lpsmSock ) {
				TransItemInfo.code = smTRANSCODE_PUTITEM;
				TransItemInfo.size = sizeof(TRANS_ITEMINFO);
				memcpy( &TransItemInfo.Item , &psItem.ItemInfo , sizeof( sITEMINFO ) );
				TransItemInfo.Item.Price = Price;
				ReformItem( &TransItemInfo.Item );
				rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
				lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
			}
			return TRUE;
		}
	}

	return TRUE;
}

//전업 확인 처리
int rsCheck_ChageJob( rsPLAYINFO *lpPlayInfo , int NewCnageJob )
{
	DWORD	dwItemCode;
	psITEM	psItem;
	int cnt;

	if ( lpPlayInfo->smCharInfo.ChangeJob==1 && NewCnageJob==2 ) {
		//전업 1->2 ; 반지아이템 보내준다
		dwItemCode = sinOR2|sin03;

		if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MAGICIAN || lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PRIESTESS ) 
			dwItemCode = sinOR2|sin02;

		if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ATALANTA || lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ARCHER ) 
			dwItemCode = sinOR2|sin04;

		for( cnt=0;cnt<INVEN_ITEM_INFO_MAX;cnt++ ) {
			if ( lpPlayInfo->InvenItemInfo[cnt].dwCode==dwItemCode ) return FALSE;
		}

		for(cnt=0;cnt<DefaultItemCount;cnt++) {
			if ( DefaultItems[cnt].Item.CODE==dwItemCode ) {
				CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt] );
				psItem.ItemInfo.ItemKindCode = ITEM_KIND_QUEST_WEAPON;
				ReformItem( &psItem.ItemInfo );
				//아이템 특정 유저의 인벤토리보냄
				return rsPutItem2( lpPlayInfo , &psItem.ItemInfo );
			}
		}

	}

	return FALSE;
}


//아이템 특정 유저의 인벤토리보냄
int rsPutItem( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode )
{
	TRANS_ITEMINFO	TransItemInfo;
	psITEM	psItem;
	int cnt;

	for(cnt=0;cnt<DefaultItemCount;cnt++) {
		if ( DefaultItems[cnt].Item.CODE==dwItemCode && !DefaultItems[cnt].Item.UniqueItem ) {
			CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt] );

			if ( lpPlayInfo->lpsmSock ) {
				TransItemInfo.code = smTRANSCODE_PUTITEM;
				TransItemInfo.size = sizeof(TRANS_ITEMINFO);
				memcpy( &TransItemInfo.Item , &psItem.ItemInfo , sizeof( sITEMINFO ) );
				rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
				lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
			}
			return TRUE;
		}
	}

	return TRUE;
}

//아이템 특정 유저의 인벤토리보냄
int rsPutItem( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , int spJobCode )
{
	TRANS_ITEMINFO	TransItemInfo;
	psITEM	psItem;
	int cnt;
	int JobCodeItem = 0;
	int PotionCount = 0;

	if ( (dwItemCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
		//물약인 경우 ( 물약 갯수 )
		PotionCount = spJobCode;
	}
	else {
		//일반 아이템 (특화 코드)
		JobCodeItem = spJobCode;
	}


	for(cnt=0;cnt<DefaultItemCount;cnt++) {
		if ( DefaultItems[cnt].Item.CODE==dwItemCode && !DefaultItems[cnt].Item.UniqueItem ) {
			CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt] , JobCodeItem );

			psItem.ItemInfo.PotionCount = PotionCount;		//물약 카운터 설정 (물약인 경우만 해당)

			if ( lpPlayInfo->lpsmSock ) {
				TransItemInfo.code = smTRANSCODE_PUTITEM;
				TransItemInfo.size = sizeof(TRANS_ITEMINFO);
				memcpy( &TransItemInfo.Item , &psItem.ItemInfo , sizeof( sITEMINFO ) );
				rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
				lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
			}
			return TRUE;
		}
	}

	return TRUE;
}

//아이템 특정 유저의 인벤토리보냄
int rsPutItemUnique( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , int spJobCode , DWORD dwUniqueCode )
{
	TRANS_ITEMINFO	TransItemInfo;
	psITEM	psItem;
	int cnt;
	int JobCodeItem = 0;
	int PotionCount = 0;

	if ( (dwItemCode&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
		//물약인 경우 ( 물약 갯수 )
		PotionCount = spJobCode;
	}
	else {
		//일반 아이템 (특화 코드)
		JobCodeItem = spJobCode;
	}


	for(cnt=0;cnt<DefaultItemCount;cnt++) {
		if ( DefaultItems[cnt].Item.CODE==dwItemCode && DefaultItems[cnt].Item.UniqueItem==dwUniqueCode ) {
			CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt] , JobCodeItem );

			psItem.ItemInfo.PotionCount = PotionCount;		//물약 카운터 설정 (물약인 경우만 해당)

			if ( lpPlayInfo->lpsmSock ) {
				TransItemInfo.code = smTRANSCODE_PUTITEM;
				TransItemInfo.size = sizeof(TRANS_ITEMINFO);
				memcpy( &TransItemInfo.Item , &psItem.ItemInfo , sizeof( sITEMINFO ) );
				rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
				lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
			}
			return TRUE;
		}
	}

	return TRUE;
}


//아이템 특정 유저의 인벤토리보냄
sDEF_ITEMINFO *rsPutItem3( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode )
{
	TRANS_ITEMINFO	TransItemInfo;
	psITEM	psItem;
	int cnt;

	for(cnt=0;cnt<DefaultItemCount;cnt++) {
		if ( DefaultItems[cnt].Item.CODE==dwItemCode && !DefaultItems[cnt].Item.UniqueItem ) {
			CreateDefItem( &psItem.ItemInfo , &DefaultItems[cnt] );

			if ( lpPlayInfo->lpsmSock ) {
				TransItemInfo.code = smTRANSCODE_PUTITEM;
				TransItemInfo.size = sizeof(TRANS_ITEMINFO);
				memcpy( &TransItemInfo.Item , &psItem.ItemInfo , sizeof( sITEMINFO ) );
				rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
				lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
			}
			return &DefaultItems[cnt];
		}
	}

	return NULL;
}


//아이템 특정 유저의 인벤토리보냄
int rsPutItem2( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpItem )
{
	TRANS_ITEMINFO	TransItemInfo;

	if ( lpPlayInfo->lpsmSock ) {
		TransItemInfo.code = smTRANSCODE_PUTITEM;
		TransItemInfo.size = sizeof(TRANS_ITEMINFO);
		memcpy( &TransItemInfo.Item ,lpItem , sizeof( sITEMINFO ) );
		rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );	//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
		return lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
	}
	return FALSE;
}

//네트웤 상태 로그 전송
int rsSendNetLog( rsPLAYINFO *lpPlayInfo )
{
	TRANS_CHATMESSAGE	TransChatMessage;

		wsprintf( TransChatMessage.szMessage , 
			"> Rcv(%d) Snd(%d) ScoopRcv(%d) ScoopFail(%d) SndFail(%d) RcvFail(%d)" ,
			lpPlayInfo->lpsmSock->RecvPacketCount,
			lpPlayInfo->lpsmSock->SendPacketCount,
			lpPlayInfo->lpsmSock->RecvPopCount,
			lpPlayInfo->lpsmSock->RecvPopErrorCount,
			lpPlayInfo->lpsmSock->SendPacketErrorCount,
			lpPlayInfo->lpsmSock->RecvPacketErrorCount );


		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;

	return lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
}


#ifdef _W_SERVER

char szAdminChar[32];
char szAdminMessage[4][32];

char *szAdminLogin = "ralley-x";
char *szAdminMaster = "동대장님";
char *szAdminMsg[4] = {
	"*공익근무대기중!!",
	"^^발렌타인21년산^^",
	"(한겨레소씨름민족대축전)~음매",
	0
};

#ifdef _TEST_SERVER
char *szAdminSpecial = "선릉역10번출구";
char *szAdminSpecialSucess = "벙개~강남초원의집~~~8시";
#else
char *szAdminSpecial = "<!일대삼서비스!>";
char *szAdminSpecialSucess = "헛~~ 진짜야 ?";
#endif

#ifdef _LANGUAGE_KOREAN

char *szAdminSucess[4] = {
	"오늘의미션 >> 훈련소집통지서 전부돌리기....",
	"오늘부터 민방위면제~",
	"행사장 입구에서 본권을 제시하면 입장할수 있습니다",
	0
};

#else

char *szAdminSucess[4] = {
	"Command Level (1)  d(+ _ +)b",
	"Command Level (2)  d(^ _ ^)b",
	"Command Level (3)  d(* . *)b",
	0
};

#endif

//TRANS_FIND_CRACKER	TransCrackFinder
/*
	char *temp_Windowname[7] = { "GameWiz3", "Game Mas" , "GameHack" ,
							"        " , "天空之城" , "스피드핵" };
	char *temp_Classname[4] = { "#3277" , "TWME1" , "#2770" };
*/

char *szFindCrackNames[][3] = {
	{	"GameWiz" , "" , "#3277" },			//게임 위자드
	{	"Game" , "Master" , "TWME1" },		//게임 마스터
	{	"Game" , "Hack" , "#3277" },		//게임 핵

	{	"        " , "" , "#2770" },		//스피드 핵 1
	{	"天空之城" , "" , "#2770" },		//스피드 핵 2
	{	"스피드" , "핵" , "#2770" },		//스피드 핵 3

	{	"Speeder" , "" , "#3277" },			//스피드핵2
	{	"Speeder" , "" , "#3227" },			//스피드핵2
	{	"스피드해킹" , "" , "#3277" },		//스피드핵2
	{	"Game Trainer" , "" , "#3277" },	//게임트레이너

	{	"FPE", "" , "TForm" },	//FPE

	{	"NEVERDIE", "ver" , "#32770" },	//피 채워주는 핵

	//{	"호떡" , "메신저" , "" },			//호떡메신저 테스트

	{	"","","" }							//끝
};

TRANS_FIND_CRACKER	rsTransFindCracker;


//크랙 찾기 초기화
int	InitCrackFinding()
{
	int cnt;
	char *lpBuff;

	cnt = 0;

	//크랙정보파일을 읽어 온다
	cnt = ReadCustomCracker( "FindGoodSoft.ini" , &rsTransFindCracker  );

	if ( cnt==0 ) {
		while(1) {
			if ( szFindCrackNames[cnt][0][0]==0 ) break;
			lstrcpy( rsTransFindCracker.CrackName[cnt].szName1 , szFindCrackNames[cnt][0] );
			lstrcpy( rsTransFindCracker.CrackName[cnt].szName2 , szFindCrackNames[cnt][1] );
			lstrcpy( rsTransFindCracker.CrackName[cnt].szClass , szFindCrackNames[cnt][2] );
			cnt++;
		}

		rsTransFindCracker.code = smTRANSCODE_FINDCRACK;
		rsTransFindCracker.size = sizeof(_CRACK_NAME)*cnt+16;
		rsTransFindCracker.FindCounter = cnt;
	}

	lpBuff = (char *)&rsTransFindCracker.CrackName[cnt];

	if ( rsServerConfig.szNoticeURL[0] ) {
		//공지 주소 클라이언트에 통보 
		lstrcpy( lpBuff , rsServerConfig.szNoticeURL );
		rsTransFindCracker.size+= lstrlen(lpBuff);
	}
	else 
		lpBuff[0] = 0;

	return TRUE;
}

//크랙 검색 요구
int	SendFindCrack( smWINSOCK *lpsmSock )
{
	if ( lpsmSock ) {
		return lpsmSock->Send2( (char *)&rsTransFindCracker , rsTransFindCracker.size , TRUE );
	}
	return FALSE;
}


//관리자 및 권한설정
int InitAdminCommand()
{
	int cnt;

	//기본 설정
	lstrcpy( szAdminChar , szAdminMaster );
	for(cnt=0;cnt<3;cnt++) {
		lstrcpy( szAdminMessage[cnt] , szAdminMsg[cnt] );
	}

	for(cnt=0;cnt<3;cnt++) {
		if ( rsServerConfig.szAdminPassword[cnt][0] )
			lstrcpy( szAdminMessage[cnt] , rsServerConfig.szAdminPassword[cnt] );
	}

	if ( rsServerConfig.szAdminName[0] )
		lstrcpy( szAdminChar , rsServerConfig.szAdminName );

	return TRUE;
}


int RecvCommand( rsPLAYINFO *lpPlayInfo , char *szChatCommand )
{
	int len,cnt;
	char *lpBuff,*lpBuff2;
	//DWORD dwTimer;
	char szCmdBuff[256];
	char szTempBuff[256];
	psITEM			*lpsItem;
	STG_AREA		*lpStgArea;
	TRANS_CHATMESSAGE	TransChatMessage;
	rsPLAYINFO		*lpPlayInfo2;
	smTRANS_COMMAND		smTransCommand;
	smTRANS_CHAR_COMMAND	smTransCharCommand;
	int		Level1, Level2;
	int		x,z;
	smCHAR	*lpChar;

	rsRECORD_DBASE *lpRecordBase;

	//파티 신청
	len = rsCompString( "/TRADE>" , szChatCommand );
	if ( len ) {

		for(cnt=len;cnt<100;cnt++) {
			if ( szChatCommand[cnt]==0 ) return TRUE;
			if ( szChatCommand[cnt]!=' ' ) {
				len = cnt;
				break;
			}
		}
		//lstrcpy( lpPlayInfo->szChatMessage , szChatCommand+len );
		wsprintf( lpPlayInfo->szChatMessage , "%s : %s" , lpPlayInfo->smCharInfo.szName , szChatCommand+len );
		lpPlayInfo->ChatMsgMode = 6;			//거래메세지
		return -1;
	}

	//파티 신청
	len = rsCompString( "//동료" , szChatCommand );
	if ( !len )
		len = rsCompString( "//party" , szChatCommand );
	if ( !len )
		len = rsCompString( "//PARTY" , szChatCommand );
	if ( len ) {

		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;
		if ( rsServerConfig.DisableParty ) return FALSE;		//동료금지 서버

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( lpPlayInfo2 && lpPlayInfo!=lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
			smTransCharCommand.code = smTRANSCODE_PARTY_REQUEST;
			smTransCharCommand.size = sizeof( smTRANS_CHAR_COMMAND );
			smTransCharCommand.WParam  = lpPlayInfo->dwObjectSerial;
			smTransCharCommand.LParam  = 0;
			smTransCharCommand.SParam  = 0;
			lstrcpy( smTransCharCommand.szName , lpPlayInfo->smCharInfo.szName );

			if ( lpPlayInfo->lpPartyMaster ) 
				Level1 = lpPlayInfo->lpPartyMaster->PartyLevelAverage;
			else
				Level1 = lpPlayInfo->smCharInfo.Level;

			if ( lpPlayInfo2->lpPartyMaster ) 
				Level2 = lpPlayInfo2->lpPartyMaster->PartyLevelAverage;
			else
				Level2 = lpPlayInfo2->smCharInfo.Level;

			if ( abs(Level1-Level2)<10 ) {

				if ( !lpPlayInfo2->dwPartyInfo || (!lpPlayInfo->dwPartyInfo && lpPlayInfo2->dwPartyInfo==PARTY_STATE_MASTER) ) {
	
					if ( lpPlayInfo->dwPartyInfo==PARTY_STATE_MEMBER ) {
						//wsprintf( TransChatMessage.szMessage , "동료장인 %s님께 %s님의 가입을 추천했습니다" , 
						if ( lpPlayInfo->lpPartyMaster ) {
							wsprintf( TransChatMessage.szMessage , srMsg_001 , 
								lpPlayInfo->lpPartyMaster->smCharInfo.szName , lpPlayInfo2->smCharInfo.szName);
							smTransCharCommand.WParam  = lpPlayInfo2->dwObjectSerial;
							if ( lpPlayInfo->lpPartyMaster->lpsmSock )
								lpPlayInfo->lpPartyMaster->lpsmSock->Send( (char *)&smTransCharCommand , smTransCharCommand.size , TRUE );
						}
					}
					else {
						//wsprintf( TransChatMessage.szMessage , "%s님께 동료 신청을 했습니다" , lpPlayInfo2->smCharInfo.szName );
						wsprintf( TransChatMessage.szMessage , srMsg_002 , lpPlayInfo2->smCharInfo.szName );
						lpPlayInfo2->lpsmSock->Send( (char *)&smTransCharCommand , smTransCharCommand.size , TRUE );
					}
				}
				else {
					if ( lpPlayInfo->dwPartyInfo && lpPlayInfo2->dwPartyInfo ) {
						if ( lpPlayInfo->lpPartyMaster==lpPlayInfo2->lpPartyMaster ) {
							//wsprintf( TransChatMessage.szMessage , "%s님은 동료입니다" , lpPlayInfo2->smCharInfo.szName );
							wsprintf( TransChatMessage.szMessage ,srMsg_003 , lpPlayInfo2->smCharInfo.szName );
						}
						else {
							//wsprintf( TransChatMessage.szMessage , "%s님은 현재 다른 동료에 가입되어 있습니다" , lpPlayInfo2->smCharInfo.szName );
							wsprintf( TransChatMessage.szMessage , srMsg_004 , lpPlayInfo2->smCharInfo.szName );
						}
					}
					else {
						//wsprintf( TransChatMessage.szMessage , "%s님은 현재 다른 동료에 가입되어 있습니다" , lpPlayInfo2->smCharInfo.szName );
						wsprintf( TransChatMessage.szMessage , srMsg_005 , lpPlayInfo2->smCharInfo.szName );
/*
					//파티장에게 보냄 ( 신청받은 사람이 파티원일 경우 )
					wsprintf( TransChatMessage.szMessage , "%s님의 동료대장인 %s 님께 동료 가입신청을 했습니다" , 
						lpPlayInfo2->smCharInfo.szName , lpPlayInfo2->lpPartyMaster->smCharInfo.szName);
					lpPlayInfo2->lpPartyMaster->lpsmSock->Send( (char *)&smTransCharCommand , smTransCharCommand.size , TRUE );
*/
					}
				}
			}
			else {
				//wsprintf( TransChatMessage.szMessage , "레벨차이가 많아서 동료신청을 할수 없습니다" , lpPlayInfo2->smCharInfo.szName );
				wsprintf( TransChatMessage.szMessage , srMsg_006 , lpPlayInfo2->smCharInfo.szName );
			}

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
	}


	//귓속말 ( /:아이디 대화문장 )
	if ( szChatCommand[1]==':' || szChatCommand[1]==';' ) {
		lpBuff = szChatCommand + 2;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴

		if ( lpPlayInfo->AdminMode && lstrcmpi( szCmdBuff , szAdminChar )==0 ) {
			cnt = 0;
			rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
			while(1) {
				if ( !szAdminMessage[cnt] || !szAdminMessage[cnt][0] ) break;
				if ( lstrcmp(szAdminMessage[cnt],szCmdBuff)==0 ) {
					lpPlayInfo->AdminMode = cnt+2;

					wsprintf( TransChatMessage.szMessage , "From> %s: %s" , szAdminChar , szAdminSucess[cnt] ); 
					TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
					TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
					TransChatMessage.dwIP = 1;
					TransChatMessage.dwObjectSerial = 0;
					lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

					return TRUE;
				}
				cnt++;
			}

			//특별 명령 ( 에이징 관리자 )
			if ( lpPlayInfo->AdminMode>=4 && lstrcmp(szAdminSpecial,szCmdBuff)==0 ) {
				lpPlayInfo->AdminMode = 10;

				wsprintf( TransChatMessage.szMessage , "From> %s: %s" , szAdminChar , szAdminSpecialSucess ); 
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 1;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				return TRUE;
			}
		}


		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( lpPlayInfo2 ) {

			if ( lpPlayInfo2->WhisperMode ) {
				//귓말 거부 상태
				lstrcpy( TransChatMessage.szMessage , srMsg_034 );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

				return TRUE;
			}

			rsGetWord( szTempBuff , lpBuff );	//ID 읽어옴
			if ( szTempBuff[0] ) {
				wsprintf( TransChatMessage.szMessage , "To> %s: %s" , szCmdBuff , lpBuff ); 
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 1;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

				if ( lpPlayInfo2->lpsmSock ) {
					wsprintf( TransChatMessage.szMessage , "From> %s: %s" , lpPlayInfo->smCharInfo.szName , lpBuff ); 
					TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
					TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
					TransChatMessage.dwIP = 1;
					TransChatMessage.dwObjectSerial = 0;
					lpPlayInfo2->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				}
			}
			else {
				//wsprintf( TransChatMessage.szMessage , "%s 님은 현재 접속중입니다" , szCmdBuff );
				wsprintf( TransChatMessage.szMessage , srMsg_007 , szCmdBuff );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			}
		}
		else {
			if ( szCmdBuff[0] ) {
				//wsprintf( TransChatMessage.szMessage , "%s 님은 현재 접속중이 아니거나 찾을수 없습니다" , szCmdBuff );
				wsprintf( TransChatMessage.szMessage , srMsg_008 , szCmdBuff );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			}
		}

		return TRUE;
	}

//해외
	//귓속말거부 ( /**아이디 대화문장 )
	//브라질에서 이걸 쓰면 Red Whisper가 발생되어서 막음.
//#ifdef _LANGUAGE_BRAZIL
/*
	if(	( szChatCommand[1]=='*' && szChatCommand[2]=='*') ||
		( szChatCommand[1]=='/' && szChatCommand[2]=='*') ||
		( szChatCommand[1]=='*' && szChatCommand[2]==';') ||
		( szChatCommand[1]=='*' && szChatCommand[2]==';' && szChatCommand[3]=='+')
	  )
	{
	}
	else
	{
		//귓속말거부 ( /**아이디 대화문장 )
		if ( szChatCommand[1]=='*' || szChatCommand[2]=='*' )
		{
			lpBuff = szChatCommand + 3;
			lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴

			lpPlayInfo2=FindUserFromName( szCmdBuff );
			if ( lpPlayInfo2 )
			{
				if ( lpPlayInfo2->lpsmSock )
				{
					wsprintf( TransChatMessage.szMessage , "%s> %s" , lpPlayInfo->smCharInfo.szName , lpBuff ); 
					TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
					TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
					TransChatMessage.dwIP = 0;
					TransChatMessage.dwObjectSerial = 0;
					lpPlayInfo2->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				}
			}
		}
	}
*/
//#endif
	//귓말거부
	len = rsCompString( "/귓말거부" , szChatCommand );
	if ( !len ) 
		len= rsCompString( "/disable_whisper" , szChatCommand );

	if ( len ) {

		lpPlayInfo->WhisperMode = TRUE;

		//귓말 거부 상태
		lstrcpy( TransChatMessage.szMessage , srMsg_035 );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;

	}

	//귓말거부
	len = rsCompString( "/귓말허용" , szChatCommand );
	if ( !len ) 
		len= rsCompString( "/enable_whisper" , szChatCommand );

	if ( len ) {

		lpPlayInfo->WhisperMode = FALSE;

		//귓말 허용 상태
		lstrcpy( TransChatMessage.szMessage , srMsg_036 );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;

	}


	//클랜 채팅
	if ( lpPlayInfo->dwClanCode ) {
		len = rsCompString( "/CLAN>" , szChatCommand );
		if ( len ) {
			for(cnt=len;cnt<100;cnt++) {
				if ( szChatCommand[cnt]==0 ) return TRUE;
				if ( szChatCommand[cnt]!=' ' ) {
					len = cnt;
					break;
				}
			}
			wsprintf( TransChatMessage.szMessage , "%s> %s" , lpPlayInfo->smCharInfo.szName , szChatCommand+len ); 
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 5;
			TransChatMessage.dwObjectSerial = 0;

			for(cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwClanCode==lpPlayInfo->dwClanCode ) {
					rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				}
			}
			return TRUE;
		}
	}

#ifdef _LANGUAGE_VEITNAM
	//시간분배경험치 정보 표시 (베트남)
	len = rsCompString( "/get_expgametime" , szChatCommand );
	if ( len  ) {

		cnt = lpPlayInfo->dwExpGameTime/1000;
		len = cnt%(60*60);
		wsprintf( TransChatMessage.szMessage , "> ExpGameTime Exp( %d ) ExpTime( %d:%d:%d )" , 
			rsGetExp_GameTime(lpPlayInfo) , cnt/(60*60) , len/60 , cnt%60 );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;
	}
#else

#ifdef	_LANGUAGE_CHINESE
	//시간분배경험치 정보 표시 (중국)
	len = rsCompString( "/get_expgametime" , szChatCommand );
	if ( len  ) {

		cnt = lpPlayInfo->dwExpGameTime/1000;
		len = cnt%(60*60);
		wsprintf( TransChatMessage.szMessage , "> ExpGameTime Exp( %d ) ExpTime( %d:%d:%d )" , 
			rsGetExp_GameTime(lpPlayInfo) , cnt/(60*60) , len/60 , cnt%60 );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;
	}
#endif

#endif

	//남은 시간 표시
	len = rsCompString( "/time" , szChatCommand );
	if ( len ) {
		//빌링 남은 시간 표시

		if ( lpPlayInfo->Bl_RNo>0 )
			bSql_PCRNoReservProduct( lpPlayInfo );
		else
			srDisplayBillingTime( lpPlayInfo , 0 );

		return TRUE;
	}

	if ( !lpPlayInfo->AdminMode ) return FALSE;

	//Sod 상황 표시
	len = rsCompString( "/sod_view" , szChatCommand );
	if ( len ) {
		rsSod_GetRealTimeScore( lpPlayInfo , 0 );	
		return TRUE;
	}

	//Sod 강제 입장
	len = rsCompString( "/sod_enter" , szChatCommand );
	if ( len ) {
		lpBuff = szChatCommand + len;

		lpPlayInfo->sEventParam[0] = atoi(lpBuff);
		rsEnterHardCoreEvent( lpPlayInfo , -1 );
		return TRUE;
	}



	//현재 시간 표시
	len = rsCompString( "/localtime" , szChatCommand );
	if ( len ) {
		SYSTEMTIME	st;
		GetLocalTime( &st );

		wsprintf( TransChatMessage.szMessage , "TIME [%d]> %d/%d/%d ( %d:%d:%d )", 
			rsServerConfig.ServerCode ,
			st.wYear , st.wMonth , st.wDay ,
			st.wHour , st.wMinute , st.wSecond );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		return TRUE;
	}

	//보스출현 분 표시
	len = rsCompString( "/get_bosstime" , szChatCommand );
	if ( len ) {
		wsprintf( TransChatMessage.szMessage , "%d> Boss Time ( %d min.)", rsServerConfig.ServerCode , OpenBossTimeMin );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		return TRUE;
	}

	//포스오브 유지상태
	len = rsCompString( "/get_forceorb" , szChatCommand );
	if ( len && lpPlayInfo->dwForceOrb_Time && lpPlayInfo->dwForceOrb_Time>dwPlayServTime ) {

		wsprintf( TransChatMessage.szMessage , "%d> Force Orb - [%d] ( %d sec )( %d dmg )", rsServerConfig.ServerCode , 
			lpPlayInfo->dwForceOrb_Code , (lpPlayInfo->dwForceOrb_Time-dwPlayServTime)/1000 , lpPlayInfo->dwForceOrb_Damage  );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		return TRUE;
	}

	//프리미엄아이템 유지상태
	len = rsCompString( "/get_primitem" , szChatCommand );
	if ( len && ( lpPlayInfo->dwTime_PrimeItem_ExpUp || lpPlayInfo->dwTime_PrimeItem_X2 ) ) {

		wsprintf( TransChatMessage.szMessage , "%d> Prime Item - Package[%d] DropItem( %d min ) ExpUp( %d min )", rsServerConfig.ServerCode , 
			lpPlayInfo->dwPrimeItem_PackageCode , (lpPlayInfo->dwTime_PrimeItem_X2-(DWORD)tServerTime)/60 , (lpPlayInfo->dwTime_PrimeItem_ExpUp-(DWORD)tServerTime)/60  );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		return TRUE;
	}


	//통화량 표시
	len = rsCompString( "/get_currency" , szChatCommand );
	if ( len ) {
		INT64	currencyTotal;

		currencyTotal = CurrencyLog.int64_CraftMoney+CurrencyLog.int64_AgingMoney+CurrencyLog.int64_ShopMoney;
		currencyTotal+= CurrencyLog.int64_ShopPotionMoney[0]+CurrencyLog.int64_ShopPotionMoney[1]+CurrencyLog.int64_ShopPotionMoney[2];
		currencyTotal+= CurrencyLog.int64_ForceOrbMoney+CurrencyLog.int64_WarpgateMoney+CurrencyLog.int64_LearnSkillMoney;

		wsprintf( TransChatMessage.szMessage , ">currency: Mx(%d) Ag(%d) Sh(%d) Po(%d %d %d) Fo(%d) Wp(%d) Sk(%d ) Tt(%d)" ,
			(int)CurrencyLog.int64_CraftMoney , 
			(int)CurrencyLog.int64_AgingMoney , 
			(int)CurrencyLog.int64_ShopMoney , 
			(int)CurrencyLog.int64_ShopPotionMoney[0] , 
			(int)CurrencyLog.int64_ShopPotionMoney[1] , 
			(int)CurrencyLog.int64_ShopPotionMoney[2] , 
			(int)CurrencyLog.int64_ForceOrbMoney,
			(int)CurrencyLog.int64_WarpgateMoney,
			(int)CurrencyLog.int64_LearnSkillMoney,
			(int)currencyTotal );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		wsprintf( TransChatMessage.szMessage , ">currency[M]: Mx(%d) Ag(%d) Sh(%d) Po(%d %d %d) Fo(%d) Wp(%d) Sk(%d ) Tt(%d)" ,
			(int)(CurrencyLog.int64_CraftMoney/1000000) , 
			(int)(CurrencyLog.int64_AgingMoney/1000000) , 
			(int)(CurrencyLog.int64_ShopMoney/1000000) , 
			(int)(CurrencyLog.int64_ShopPotionMoney[0]/1000000) , 
			(int)(CurrencyLog.int64_ShopPotionMoney[1]/1000000) , 
			(int)(CurrencyLog.int64_ShopPotionMoney[2]/1000000) , 
			(int)(CurrencyLog.int64_ForceOrbMoney/1000000) ,
			(int)(CurrencyLog.int64_WarpgateMoney/1000000) ,
			(int)(CurrencyLog.int64_LearnSkillMoney/1000000) ,
			(int)(currencyTotal/1000000) );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;
	}
/*
	//통화량 표시
	len = rsCompString( "/reset_currency" , szChatCommand );
	if ( len ) {
		int64_CraftMoney=0; 
		int64_AgingMoney=0;
		int64_ShopMoney=0;
		int64_ShopPotionMoney[0]=0;
		int64_ShopPotionMoney[1]=0;
		int64_ShopPotionMoney[2]=0;

		wsprintf( TransChatMessage.szMessage , "> Reset Currency" );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		return TRUE;
	}
*/
	//아이템 생기는 치트//해외
	len = rsCompString( "/specific" , szChatCommand ); //( /특화설정 )
	if ( len && lpPlayInfo->AdminMode>=1 ) {
		lpBuff = szChatCommand + len;

		spJobCode = atoi(lpBuff);
		spJobCodeTime = dwPlayServTime+60*1000;

		wsprintf( TransChatMessage.szMessage , ">Specific (%d) 1 minute operation", spJobCode );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 1 );		//운영자 명령 사용기록
		return TRUE;
	}

	//아이템 생기는 치트 날짜설정
	len = rsCompString( "/아이템날짜보정" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=1 ) {
		lpBuff = szChatCommand + len;

		cnt = atoi(lpBuff);
		if ( cnt<-30 || cnt>30 ) return TRUE;

		spTimeAdjust = cnt*60*60*24;
		spTimeAdjustTime = dwPlayServTime+60*1000;

		wsprintf( TransChatMessage.szMessage , ">날짜보정 (%d) 1분동안 유효", spTimeAdjust );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 1 );		//운영자 명령 사용기록
		return TRUE;
	}



	//아이템 생기는 치트
	len = rsCompString( "/성능설정" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=1 ) {
		lpBuff = szChatCommand + len;

		spItemNormal = atoi(lpBuff);
		spJobCodeTime = dwPlayServTime+60*1000;

		wsprintf( TransChatMessage.szMessage , ">아이템 성능설정 (%d) 1분동안 유효", spItemNormal );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 1 );		//운영자 명령 사용기록
		return TRUE;
	}

	//아이템 생기는 치트
	len = rsCompString( "/@get" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=3 ) {
		lpBuff = szChatCommand + len;

		//p = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		//pb=p;p=GetWord(strBuff,p);if(strBuff[0]==34)p=GetString(strBuff,pb);	//단어 찾기

		len = lstrlen(lpBuff);
		for(cnt=0;cnt<len;cnt++) {
			if ( lpBuff[0]==' ' ) lpBuff++;
			else break;
		}

		//아이템 생성 명령
		if ( CreateCommandItem( lpPlayInfo , 0 , lpBuff )==TRUE ) {
			//wsprintf( TransChatMessage.szMessage , "아이템 %s를 생성했습니다" , lpBuff );
			wsprintf( TransChatMessage.szMessage , srMsg_009 , lpBuff );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 1 );		//운영자 명령 사용기록
		return TRUE;
	}

	//아이템 생기는 치트
	len = rsCompString( "/@put" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=3 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName3( szCmdBuff );
		if ( lpPlayInfo2 ) {

			len = lstrlen(lpBuff);
			for(cnt=0;cnt<len;cnt++) {
				if ( lpBuff[0]==' ' ) lpBuff++;
				else break;
			}
			//아이템 생성 명령
			if ( CreateCommandItem( lpPlayInfo , lpPlayInfo2 , lpBuff )==TRUE ) {
				//wsprintf( TransChatMessage.szMessage , "아이템 %s를 %s님께 보냈습니다" , lpBuff , lpPlayInfo2->smCharInfo.szName );
				wsprintf( TransChatMessage.szMessage , srMsg_010 , lpBuff , lpPlayInfo2->smCharInfo.szName );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			}
		}

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 1 );		//운영자 명령 사용기록
		return TRUE;
	}
/* //해외
	//모양을 코믹캐릭으로 변경
	len = rsCompString( "/comic_player" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//캐릭이름 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName3( szCmdBuff );
		if ( lpPlayInfo2 ) {


			rsGetWord( szCmdBuff , lpBuff );		//숫자 읽어옴
			if ( szCmdBuff[0] )
				smTransCommand.LParam = 60*atoi( szCmdBuff );
			else
				smTransCommand.LParam = 60*5;

			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.code = smTRANSCODE_COMIC_SKIN;
			smTransCommand.WParam = (rand()%2)+1;
			smTransCommand.SParam = 0;
			smTransCommand.EParam = 0;
			lpPlayInfo2->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
		}

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}
*/
	//물약 모니터
	len = rsCompString( "/get_potion" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && rsServerConfig.PotionMonitor ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//캐릭이름 읽어옴

		if ( !szCmdBuff[0] ) 
			lpPlayInfo2 = lpPlayInfo;
		else
			lpPlayInfo2=FindUserFromName3( szCmdBuff );

		if ( lpPlayInfo2 ) {
			wsprintf( TransChatMessage.szMessage , ">PL(%d %d %d %d) PM(%d %d %d %d) PS(%d %d %d %d)" , 
				lpPlayInfo2->ServerPotion[0][0],lpPlayInfo2->ServerPotion[0][1],lpPlayInfo2->ServerPotion[0][2],lpPlayInfo2->ServerPotion[0][3],
				lpPlayInfo2->ServerPotion[1][0],lpPlayInfo2->ServerPotion[1][1],lpPlayInfo2->ServerPotion[1][2],lpPlayInfo2->ServerPotion[1][3],
				lpPlayInfo2->ServerPotion[2][0],lpPlayInfo2->ServerPotion[2][1],lpPlayInfo2->ServerPotion[2][2],lpPlayInfo2->ServerPotion[2][3] );

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		}
		return TRUE;
	}



	//전체 귓말
	if ( szChatCommand[1]=='>' && lpPlayInfo->AdminMode>=2 ) {
		if ( szChatCommand[2]!='>' ) {
			wsprintf( TransChatMessage.szMessage , srMsg_011 , szChatCommand+2 ); 
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 3;
			TransChatMessage.dwObjectSerial = 0;

			for(cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock ) {
					rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				}
			}
		}
		else {
			//공지사항을 설정한다
			rsSetNoticeMessage( szChatCommand+3 );
		}

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}


	//네트웍 상태 전송
	len = rsCompString( "/netlog" , szChatCommand );
	if ( !len )
		len = rsCompString( "//netlog" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		//네트웤 상태 로그 전송
		rsSendNetLog( lpPlayInfo );
	}

	//접속제한인원 설정
	len = rsCompString( "/접속제한인원" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=2 ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( szCmdBuff[0] ) {
			rsConnectUserLimit = atoi( szCmdBuff );
			//wsprintf( TransChatMessage.szMessage , "접속제한 인원을 %d명으로 설정 했습니다" , rsConnectUserLimit );
			wsprintf( TransChatMessage.szMessage , srMsg_012 , rsConnectUserLimit );
		}
		else {
			//wsprintf( TransChatMessage.szMessage , "현재 접속제한 인원은 %d명 입니다" , rsConnectUserLimit );
			wsprintf( TransChatMessage.szMessage , srMsg_013 , rsConnectUserLimit );
		}
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}

	//접속제한인원 설정
	len = rsCompString( "/접속가능코드" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=2 ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//코드 읽어옴
		if ( szCmdBuff[0] ) {
			if ( rsServerConfig.ClientCheckSumCount<32 ) {
				cnt = atoi(szCmdBuff);
				rsServerConfig.dwClientCheckSum[rsServerConfig.ClientCheckSumCount++] = cnt;
				//wsprintf( TransChatMessage.szMessage , "%d번째 클라이언트 확인코드를 추가했습니다( %d )"
				wsprintf( TransChatMessage.szMessage , srMsg_014 ,rsServerConfig.ClientCheckSumCount , cnt );
			}
			else {
				//wsprintf( TransChatMessage.szMessage , "코드를 추가할수 없습니다-FULL" );
				wsprintf( TransChatMessage.szMessage , srMsg_015 );
			}
		}
		else {
			rsServerConfig.ClientCheckSumCount = 0;
			//wsprintf( TransChatMessage.szMessage , "클라이언트 확인을 해제했습니다" );
			wsprintf( TransChatMessage.szMessage , srMsg_016 );
		}

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}


/*
			for( cnt=0;cnt<rsServerConfig.ClientCheckSumCount;cnt++ ) {
				if ( lpTransCharCommand->WParam==(int)rsServerConfig.dwClientCheckSum[cnt] ) {
*/

	//유저 연결 강제 끈기
	len = rsCompString( "/kick" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=2 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( !lpPlayInfo2 ) 
			lpPlayInfo2 = FindUserFromName2( szCmdBuff );

		if ( lpPlayInfo2 ) {
			//wsprintf( TransChatMessage.szMessage , "축하합니다. %s님을 짤랐습니다" , lpBuff , lpPlayInfo2->smCharInfo.szName );
			wsprintf( TransChatMessage.szMessage , srMsg_017 , lpBuff , lpPlayInfo2->smCharInfo.szName );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

			DisconnectUser( lpPlayInfo2->lpsmSock );
		}
		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}

	//유저 강제로 죽이기
	len = rsCompString( "/kill" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=2 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( !lpPlayInfo2 ) 
			lpPlayInfo2 = FindUserFromName2( szCmdBuff );

		if ( lpPlayInfo2 ) {
			//wsprintf( TransChatMessage.szMessage , "축하합니다. %s님을 짤랐습니다" , lpBuff , lpPlayInfo2->smCharInfo.szName );
			wsprintf( TransChatMessage.szMessage , "> Killed ( %s )" , lpPlayInfo2->smCharInfo.szName );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.code = smTRANSCODE_DEAD_PLAYER;
			smTransCommand.WParam = 0;
			smTransCommand.SParam = 0;
			smTransCommand.LParam = 0;
			smTransCommand.EParam = 0;
			lpPlayInfo2->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

		}
		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}

	//창고 열기
	len = rsCompString( "/open_warehouse" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=2 ) {
		lpBuff = szChatCommand + len;

		lpBuff2 = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( szCmdBuff[0]==34 ) lpBuff2 = GetString( szCmdBuff , lpBuff );
		if ( szCmdBuff[0] ) {
			rsGetWord( szTempBuff , lpBuff2 );	//숫자 읽어옴
			if  ( szTempBuff[0]>='0' && szTempBuff[0]<='9' ) {
				 rsLoadWareHouseData_Admin( lpPlayInfo , szCmdBuff , atoi(szTempBuff) );
			}
			else {
				 rsLoadWareHouseData_Admin( lpPlayInfo , szCmdBuff , 0 );
			}
		}
		else {
			SendWareHouseToClient( lpPlayInfo );		//자신의 창고 열기
		}
		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}

	//유저들 모두 연결 종료 요구 메세지 보냄
	len = rsCompString( "/shutdown" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>=2 ) {

		smTransCommand.WParam = 11000;
		smTransCommand.SParam = 0;
		smTransCommand.LParam = 0;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		rsShutDown();	//서버 종료

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}

/*
		//ID에 새로운 캐릭터 삽입
		lpRecordBase = new rsRECORD_DBASE;

		lpTransCharCommand2 = ( smTRANS_CHAR_COMMAND2 * )SockInfo->Buff;

		lpPlayInfo2 = FindUserFromName2( lpTransCharCommand2->szName );		//접속자 같은 이름 있는지 확인
		if ( !lpPlayInfo2 )
			lpTransCharCommand2->WParam = lpRecordBase->InsertCharData( lpPlayInfo->szID , lpTransCharCommand2->szName );
			//lpTransCharCommand2->WParam = lpRecordBase->InsertCharData( lpTransCharCommand2->szId , lpTransCharCommand2->szName );
		else
			lpTransCharCommand2->WParam = FALSE;

		lpsmSock->Send( (char *)lpTransCharCommand2 , lpTransCharCommand2->size , TRUE );

		if ( lpTransCharCommand2->WParam==TRUE )							//접속자이름에 등록
			lstrcpy( lpPlayInfo->szName , lpTransCharCommand2->szName );

		delete lpRecordBase;
*/

	if ( lpPlayInfo->AdminMode>=2 ) {
		//다른 ID에 캐릭터 삽입 연결
		len = rsCompString( "/insert" , szChatCommand );
		if ( len ) {

			lpBuff = szChatCommand + len;
			lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
			lpBuff = rsGetWord( szTempBuff , lpBuff );	//Name 읽어옴

			if ( szCmdBuff[0] && szTempBuff[0] ) {
				lpRecordBase = new rsRECORD_DBASE;

				if ( lpRecordBase->InsertCharData( szCmdBuff , szTempBuff , TRUE ) ) {
					//wsprintf( TransChatMessage.szMessage , "%s 계정에 %s 캐릭을 연결했습니다" , szCmdBuff , szTempBuff );
					wsprintf( TransChatMessage.szMessage , srMsg_018 , szCmdBuff , szTempBuff );
				}
				else {
					//wsprintf( TransChatMessage.szMessage , "계정 연결에 실패했습니다" );
					wsprintf( TransChatMessage.szMessage , srMsg_019 );
				}
				delete lpRecordBase;
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

				rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
				return TRUE;
			}
		}
	}



	//동료정보 출력
	len = rsCompString( "//동료정보" , szChatCommand );
	if ( len ) {
		//wsprintf( TransChatMessage.szMessage , "내상태(%d) ", lpPlayInfo->dwPartyInfo );
		wsprintf( TransChatMessage.szMessage , srMsg_020 , lpPlayInfo->dwPartyInfo );
		if ( lpPlayInfo->lpPartyMaster ) {
			//wsprintf( szTempBuff , "동료장(%s) ", lpPlayInfo->lpPartyMaster->smCharInfo.szName );
			wsprintf( szTempBuff , srMsg_021 , lpPlayInfo->lpPartyMaster->smCharInfo.szName );
			lstrcat( TransChatMessage.szMessage , szTempBuff );

			for(cnt=0;cnt<PARTY_PLAYER_MAX;cnt++) {
				if ( lpPlayInfo->lpPartyMaster->lpPartyPlayers[cnt] ) {
					wsprintf( szTempBuff, "%s/", lpPlayInfo->lpPartyMaster->lpPartyPlayers[cnt]->smCharInfo.szName );
					lstrcat( TransChatMessage.szMessage , szTempBuff );
				}
			}
		}
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}

	//동료탈퇴
	len = rsCompString( "//동료탈퇴" , szChatCommand );
	if ( len ) {
		if ( lpPlayInfo->SecedeParty() ) {
			//wsprintf( TransChatMessage.szMessage , "동료에서 탈퇴했습니다" );
			wsprintf( TransChatMessage.szMessage , srMsg_022 );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
	}

	//동료추방
	len = rsCompString( "//동료추방" , szChatCommand );
	if ( len ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( lpPlayInfo2 && lpPlayInfo2->SecedeParty() ) {
			//wsprintf( TransChatMessage.szMessage , "%s님을 동료에서 추방했습니다" , lpPlayInfo2->smCharInfo.szName );
			wsprintf( TransChatMessage.szMessage , srMsg_023 , lpPlayInfo2->smCharInfo.szName );
		}
		else {
			//wsprintf( TransChatMessage.szMessage , "%s님은 동료가 아니거나 추방할수 없습니다" , szCmdBuff );
			wsprintf( TransChatMessage.szMessage , srMsg_024 , szCmdBuff );
		}

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}

	//동료해산
	len = rsCompString( "//동료해산" , szChatCommand );
	if ( len ) {
		if ( lpPlayInfo->ReleaseParty() ) {
			//wsprintf( TransChatMessage.szMessage , "동료를 해산 시켰습니다" );
			wsprintf( TransChatMessage.szMessage , srMsg_025 );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
	}

	//동료이임
	len = rsCompString( "//동료이임" , szChatCommand );
	if ( len ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( lpPlayInfo2 && lpPlayInfo->LeavePartyMaster(lpPlayInfo2) ) {
			//wsprintf( TransChatMessage.szMessage , "파티장을 %s님께 이임 했습니다",lpPlayInfo2->smCharInfo.szName  );
			wsprintf( TransChatMessage.szMessage , srMsg_026 ,lpPlayInfo2->smCharInfo.szName  );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
	}

#ifdef	_WINMODE_DEBUG

	//스킨핵(캐릭 네임 안보일때)

	//특정 유저의 정보표시 ( 계정 )
	len = rsCompString( "/코드정보" , szChatCommand );
	if ( !len ) 
		len= rsCompString( "/usercode" , szChatCommand );

	if ( len && lpPlayInfo->AdminMode>=1 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromCode( atoi(szCmdBuff) );
		if ( lpPlayInfo2 ) {
			//wsprintf( TransChatMessage.szMessage , "계정( %s ) 이름( %s ) IP( %s ) 접속시간( %d분 )", 
			wsprintf( TransChatMessage.szMessage , srMsg_027, 
				lpPlayInfo2->szID, lpPlayInfo2->szName, lpPlayInfo2->lpsmSock->szIPAddr , 
				(dwPlayServTime-lpPlayInfo2->dwConnectTime)/(60*1000) );

			rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		}
		else {
			//wsprintf( TransChatMessage.szMessage , "현재 접속중이 아니거나 찾을수 없습니다" );
			wsprintf( TransChatMessage.szMessage , srMsg_028 );
		}

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;
	}



	//특정 유저의 정보표시 ( 계정 )
	len = rsCompString( "/계정정보" , szChatCommand );
	if ( !len ) 
		len= rsCompString( "/userid" , szChatCommand );

	if ( len && lpPlayInfo->AdminMode>=1 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromID( szCmdBuff );
		if ( lpPlayInfo2 ) {
			//wsprintf( TransChatMessage.szMessage , "계정( %s ) 이름( %s ) IP( %s ) 접속시간( %d분 )", 
			wsprintf( TransChatMessage.szMessage , srMsg_027, 
				lpPlayInfo2->szID, lpPlayInfo2->szName, lpPlayInfo2->lpsmSock->szIPAddr , 
				(dwPlayServTime-lpPlayInfo2->dwConnectTime)/(60*1000) );

			rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		}
		else {
			//wsprintf( TransChatMessage.szMessage , "현재 접속중이 아니거나 찾을수 없습니다" );
			wsprintf( TransChatMessage.szMessage , srMsg_028 );
		}

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;
	}

	//특정 유저의 정보표시 ( 이름 )
	len = rsCompString( "/이름정보" , szChatCommand );
	if ( !len ) 
		len= rsCompString( "/username" , szChatCommand );

	if ( len && lpPlayInfo->AdminMode>=1 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName2( szCmdBuff );
		if ( lpPlayInfo2 ) {
			//wsprintf( TransChatMessage.szMessage , "계정( %s ) 이름( %s ) IP( %s ) 접속시간( %d분 )", 
			wsprintf( TransChatMessage.szMessage , srMsg_029, 
				lpPlayInfo2->szID, lpPlayInfo2->szName, lpPlayInfo2->lpsmSock->szIPAddr , 
				(dwPlayServTime-lpPlayInfo2->dwConnectTime)/(60*1000) );

			rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록

		}
		else {
			//wsprintf( TransChatMessage.szMessage , "현재 접속중이 아니거나 찾을수 없습니다" );
			wsprintf( TransChatMessage.szMessage , srMsg_030 );
		}

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;
	}


	//특정 유저에게 접근
	len = rsCompString( "/접근" , szChatCommand );
	if ( !len ) 
		len = rsCompString( "/near" , szChatCommand );

	if ( len && lpPlayInfo->AdminMode>=2 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( lpPlayInfo2 ) {
			lpStgArea = FindStageField( lpPlayInfo2->Position.x, lpPlayInfo2->Position.z );
			if ( lpStgArea ) {
				smTransCommand.code = smTRANSCODE_WARPFIELD;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = lpStgArea->lpField->FieldCode;
				smTransCommand.SParam = lpPlayInfo2->Position.x;
				smTransCommand.LParam = lpPlayInfo2->Position.z;
				lpPlayInfo->lpsmSock->Send( (char *)&smTransCommand , smTransCommand.size , TRUE );

				rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
				return TRUE;
			}
		}
	}

	//특정 유저 호출
	len = rsCompString( "/호출" , szChatCommand );
	if ( !len ) 
		len = rsCompString( "/call" , szChatCommand );

	if ( len && lpPlayInfo->AdminMode>=2 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( lpPlayInfo2 ) {
			lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );
			if ( lpStgArea ) {
				smTransCommand.code = smTRANSCODE_WARPFIELD;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = lpStgArea->lpField->FieldCode;
				smTransCommand.SParam = lpPlayInfo->Position.x;
				smTransCommand.LParam = lpPlayInfo->Position.z;
				lpPlayInfo2->lpsmSock->Send( (char *)&smTransCommand , smTransCommand.size , TRUE );

				rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
				return TRUE;
			}
		}
	}


	//특정 유저 위치 찾기
	len = rsCompString( "/위치" , szChatCommand );
	if ( !len ) 
		len = rsCompString( "/where" , szChatCommand );

	if ( len && lpPlayInfo->AdminMode>=2 ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( lpPlayInfo2 ) {
			lpStgArea = FindStageField( lpPlayInfo2->Position.x, lpPlayInfo2->Position.z );
			if ( lpStgArea ) {
				//wsprintf( TransChatMessage.szMessage , "%s님의 위치 ( %s ) x=%d / z=%d ", lpPlayInfo2->smCharInfo.szName , lpStgArea->lpField->szName , lpPlayInfo2->Position.x>>FLOATNS , lpPlayInfo2->Position.z>>FLOATNS );
				wsprintf( TransChatMessage.szMessage , srMsg_031, lpPlayInfo2->smCharInfo.szName , lpStgArea->lpField->szName , lpPlayInfo2->Position.x>>FLOATNS , lpPlayInfo2->Position.z>>FLOATNS );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

				rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
				return TRUE;
			}
		}
	}


	//경험치 치트
	//len = rsCompString( "/내경험치내놔!" , szChatCommand );
//해외
	len = rsCompString( "/GiveMeExp!" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && ( DebugServerMode || rsServerConfig.TestSeverMode || lpPlayInfo->AdminMode>=4 ) )
	{
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//레벨
		if ( !szCmdBuff[0] ) return FALSE;

		cnt = atoi(szCmdBuff)-1;
		if ( cnt>0 && cnt<CHAR_LEVEL_MAX ) {
			lpPlayInfo->spExp_Start = GetNextExp( cnt );
			cnt = (int)lpPlayInfo->spExp_Start;

			wsprintf( TransChatMessage.szMessage , ">Here you go~( %d )" , cnt );

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 1 );		//운영자 명령 사용기록
		return TRUE;
	}

	//돈 치트
//	len = rsCompString( "/내돈다내놔!" , szChatCommand );
//해외
	len = rsCompString( "/GiveMeMoney!" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && ( DebugServerMode || rsServerConfig.TestSeverMode || lpPlayInfo->AdminMode>=4 ) ) {
		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//레벨
		if ( !szCmdBuff[0] ) return FALSE;

		cnt = atoi(szCmdBuff);
		if ( cnt>0 && cnt<=1000000 ) {
			lpsItem = new psITEM;

			ZeroMemory( lpsItem , sizeof(psITEM) );
			wsprintf( lpsItem->ItemInfo.ItemName , sinGold , cnt );
			lpsItem->ItemInfo.Money = cnt;
			lpsItem->ItemInfo.CODE = sinGG1|sin01;			//돈이다
			ReformItem( &lpsItem->ItemInfo );						//아이템 인증

			lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );
			if ( lpStgArea ) {
				lpsItem->state = TRUE;
				lpStgArea->AddItem( lpsItem , lpPlayInfo->Position.x>>FLOATNS, lpPlayInfo->Position.y>>FLOATNS, lpPlayInfo->Position.z>>FLOATNS );
			}
			delete lpsItem;


			wsprintf( TransChatMessage.szMessage , ">What the hell~!!( %d )" , cnt );

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 1 );		//운영자 명령 사용기록
		return TRUE;

	}


	//유저 정보 보기
#ifndef _LANGUAGE_CHINESE
	len = rsCompString( "/user" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		//wsprintf( TransChatMessage.szMessage , "접속인원 %d명 / 활동몬스터 %d개", rsGetUserCounter(PlayerCount) ,ActivePlayCounter  );
		wsprintf( TransChatMessage.szMessage , srMsg_032, rsGetUserCounter(PlayerCount) ,ActivePlayCounter  );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}
#endif

	//유저 정보 보기
	len = rsCompString( "/소켓" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		//wsprintf( TransChatMessage.szMessage , "열린소켓 (%d) / 활성캐릭터 (%d)", PlayerCount ,ActivePlayCounter  );
		wsprintf( TransChatMessage.szMessage , srMsg_033, PlayerCount ,ActivePlayCounter  );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}

	//몬스터 대사 입력
	len = rsCompString( "/talk" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		lpBuff = szChatCommand + len;
		lpBuff2 = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( szCmdBuff[0] ) {
			lpChar = srFindCharFromSerial( atoi(szCmdBuff) );
			if ( lpChar ) {
				wsprintf( TransChatMessage.szMessage , "%s: %s " , lpChar->smCharInfo.szName , lpBuff2 );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = lpChar->dwObjectSerial;

				rsSendCommandUser2( lpPlayInfo , (smTRANS_COMMAND *)&TransChatMessage );
			}
		}

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}

	//몬스터 흡수 조작
	len = rsCompString( "/set_absorb" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>3 ) {
		lpBuff = szChatCommand + len;
		lpBuff2 = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( szCmdBuff[0] ) {
			lpChar = srFindCharFromSerial( atoi(szCmdBuff) );
			cnt = atoi(lpBuff2);
			if ( lpChar && cnt>0 && cnt<100 ) {
				wsprintf( TransChatMessage.szMessage , "> set_absorb (%s) %d->%d " , lpChar->smCharInfo.szName ,lpChar->smCharInfo.Absorption , cnt );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

				lpChar->smCharInfo.Absorption = cnt;
			}
		}

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}

	//가상 피시방 설정
	len = rsCompString( "/set_pcbang" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>3 ) {

		lpBuff = szChatCommand + len;

		lpBuff = rsGetWord( szCmdBuff , lpBuff );		//PC방 코드
		if ( !szCmdBuff[0] ) return FALSE;

		cnt = atoi(szCmdBuff);

		wsprintf( TransChatMessage.szMessage , "> set_pcbang (%d) " ,  cnt );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		lpPlayInfo->Bl_RNo = cnt;

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}



	//전송거리 변경
	len = rsCompString( "/player_sight" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && StageArea[rsCASTLE_FIELD].dwActiveMode ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );
		if ( !szCmdBuff[0] ) {
			rsConnectViewDist = DIST_TRANSLEVEL_HIGH;
			lstrcpy( TransChatMessage.szMessage , "> Player Sight = [NEAR]" );
		}
		else {
			rsConnectViewDist = DIST_TRANSLEVEL_CONNECT;
			lstrcpy( TransChatMessage.szMessage , "> Player Sight = [FAR]" );
		}

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;

	}

	//지역 유저 정보 보기
	len = rsCompString( "/area_users" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		len = 0;
		for(cnt=0;cnt<CONNECTMAX;cnt++) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial ) {
				if ( rsPlayInfo[cnt].Position.Area==lpPlayInfo->Position.Area )
					len ++;
			}
		}
		wsprintf( TransChatMessage.szMessage , "> Area(%d) Users(%d)" , lpPlayInfo->Position.Area , len  );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}

	//몬스터 생성
	len = rsCompString( "/arena_monster" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {

		OpenMonster_QuestArena( lpPlayInfo , HAQUEST_CODE_FURYOFPHANTOM , 1 );

		return TRUE;
	}

	//몬스터 생성
	len = rsCompString( "/monster" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {
		//pb=p;p=GetWord(strBuff,p);if(strBuff[0]==34)p=GetString(strBuff,pb);	//단어 찾기
		lpBuff = szChatCommand + len;
		lpBuff2 = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( szCmdBuff[0]==34 ) lpBuff2 = GetString( szCmdBuff , lpBuff );
		if ( szCmdBuff[0] ) {
			lpChar = OpenMonsterFromName( szCmdBuff , lpPlayInfo->Position.x , lpPlayInfo->Position.y , lpPlayInfo->Position.z );
			if ( lpChar && lpPlayInfo->AdminMode<4 ) {
				lpChar->smMonsterInfo.FallItemCount = 0;			//소환 몬스터 아이템 드롭 금지
			}
		}

		rsGetWord( szTempBuff , lpBuff2 );	//숫자 읽어옴
		if  ( szTempBuff[0]>='0' && szTempBuff[0]<='9' ) {
			len = atoi( szTempBuff );
			if ( len<=20 ) {
				for( cnt=0;cnt<len;cnt++ ) {
					x = rand()%(128*fONE);
					z = rand()%(128*fONE);
					x -= 64*fONE;
					z -= 64*fONE;
					lpChar = OpenMonsterFromName( szCmdBuff , lpPlayInfo->Position.x+x , lpPlayInfo->Position.y , lpPlayInfo->Position.z+z );
					if ( lpChar && lpPlayInfo->AdminMode<4 ) {
						lpChar->smMonsterInfo.FallItemCount = 0;			//소환 몬스터 아이템 드롭 금지
					}
				}
			}
		}
		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}

	//몬스터 생성
	len = rsCompString( "/mymonster" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {
		//pb=p;p=GetWord(strBuff,p);if(strBuff[0]==34)p=GetString(strBuff,pb);	//단어 찾기
		lpBuff = szChatCommand + len;
		lpBuff2 = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( szCmdBuff[0]==34 ) lpBuff2 = GetString( szCmdBuff , lpBuff );
		if ( szCmdBuff[0] ) {
			lpChar = OpenMonsterFromName( szCmdBuff , lpPlayInfo->Position.x , lpPlayInfo->Position.y , lpPlayInfo->Position.z , lpPlayInfo );
			if ( lpChar && lpPlayInfo->AdminMode<4 ) {
				lpChar->smMonsterInfo.FallItemCount = 0;			//소환 몬스터 아이템 드롭 금지
			}
		}

		rsGetWord( szTempBuff , lpBuff2 );	//숫자 읽어옴
		if  ( szTempBuff[0]>='0' && szTempBuff[0]<='9' ) {
			len = atoi( szTempBuff );
			if ( len<=20 ) {
				for( cnt=0;cnt<len;cnt++ ) {
					x = rand()%(128*fONE);
					z = rand()%(128*fONE);
					x -= 64*fONE;
					z -= 64*fONE;
					lpChar = OpenMonsterFromName( szCmdBuff , lpPlayInfo->Position.x+x , lpPlayInfo->Position.y , lpPlayInfo->Position.z+z , lpPlayInfo );
					if ( lpChar && lpPlayInfo->AdminMode<4 ) {
						lpChar->smMonsterInfo.FallItemCount = 0;			//소환 몬스터 아이템 드롭 금지
					}
				}
			}
		}
		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}

	//이벤트 몬스터 설정
	len = rsCompString( "/event_monster" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {
		lpBuff = szChatCommand + len;
		lpBuff2 = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );

		if ( lpStgArea ) {
			if ( szCmdBuff[0]==34 ) lpBuff2 = GetString( szCmdBuff , lpBuff );
			if ( szCmdBuff[0] ) {

				lpStgArea->Event_lpChrMonster = 0;
				lpStgArea->Event_dwMonsterTime = 0;
				lpStgArea->Event_MonsterPercentage = 0;

				for( cnt=0;cnt<chrMonsterCnt;cnt++ ) {
					if ( lstrcmp( chrMonsterList[cnt].szName , szCmdBuff )==0 ) {
						lpStgArea->Event_lpChrMonster = &chrMonsterList[cnt];
						break;
					}
				}

				if ( !lpStgArea->Event_lpChrMonster ) 
					return FALSE;

				lpBuff2 = rsGetWord( szTempBuff , lpBuff2 );	//숫자 읽어옴 ( 시간 / 분 )
				if  ( szTempBuff[0]>='0' && szTempBuff[0]<='9' ) {
					len = atoi( szTempBuff );
					lpStgArea->Event_dwMonsterTime = dwPlayServTime+len*1000*60;
				}
				else {
					lpStgArea->Event_dwMonsterTime = 0;
					return FALSE;
				}


				lpBuff2 = rsGetWord( szTempBuff , lpBuff2 );	//숫자 읽어옴 ( 발생확률 x/1000 )
				if  ( szTempBuff[0]>='0' && szTempBuff[0]<='9' ) {
					lpStgArea->Event_MonsterPercentage = atoi( szTempBuff );		//확률
				}
				else {
					lpStgArea->Event_dwMonsterTime = 0;
					return FALSE;
				}

				wsprintf( TransChatMessage.szMessage , "> Set Event Monster ( %s ) (%d)Min. (%d/1000)" , 
					lpStgArea->Event_lpChrMonster->szName , len , lpStgArea->Event_MonsterPercentage );

				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			}
			else {
				if ( lpStgArea->Event_dwMonsterTime && lpStgArea->Event_lpChrMonster ) {
					len = (lpStgArea->Event_dwMonsterTime-dwPlayServTime)/1000;
					wsprintf( TransChatMessage.szMessage , "> Event Monster ( %s ) Left %d Sec. (%d/1000)" , 
						lpStgArea->Event_lpChrMonster->szName , len , lpStgArea->Event_MonsterPercentage );

					TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
					TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
					TransChatMessage.dwIP = 0;
					TransChatMessage.dwObjectSerial = 0;
					lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				}
			}
		}
		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 2 );		//운영자 명령 사용기록
		return TRUE;
	}


	//몬스터 지역 정보
	len = rsCompString( "/area_monster" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {
		lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );
		if ( lpStgArea ) {
			x=0; z=0; len=0;
			for( cnt=0;cnt<STG_START_POINT_MAX;cnt++)
				if ( lpStgArea->StartPoint[cnt].state ) len++;

			for( cnt=0;cnt<STG_START_POINT_MAX;cnt++ )
				x += lpStgArea->StartPointMonCount[cnt];

			for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
				if (  lpStgArea->lpCharMonster[cnt] ) {
					z ++;
				}
			}

			if ( x || z || len || lpStgArea->MonsterCount ) {
				wsprintf( TransChatMessage.szMessage , "> ResponePoint( %d ) ResponeMonster( %d ) Monster( %d ) MonsterCount( %d ) LimitTime( %d )"
					, len , x , z , lpStgArea->MonsterCount , lpStgArea->rsMonsterList.dwIntervalTime/1000 );

				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			}
		}
	}

	if ( StageArea[rsCASTLE_FIELD].dwActiveMode ) {
		//공성시작
		len = rsCompString( "/start_castle" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {
			rsStart_CombatCastle();

			lpBuff = szChatCommand + len;
			lpBuff = rsGetWord( szCmdBuff , lpBuff );
			if ( szCmdBuff[0] ) {
				rsBlessCastle.dwBattleOverTime = dwPlayTime+atoi(szCmdBuff)*60*1000;
			}
			return TRUE;
		}

		//공성종료
		len = rsCompString( "/end_castle" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {
			rsEnd_CombatCastle( 0 );
			//rsBlessCastle.dwMasterClan = 0;
			return TRUE;
		}

		//공성쉽게
		len = rsCompString( "/easy_castle" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode>3 && AutoPlayServer ) {
			rsEasy_CastleMode();
			return TRUE;
		}

		//공성 남은 시간 변경
		len = rsCompString( "/set_castle_time" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {
			lpBuff = szChatCommand + len;
			lpBuff = rsGetWord( szCmdBuff , lpBuff );	//시간
			if ( szCmdBuff[0] ) {
				rsBlessCastle.dwBattleOverTime = dwPlayTime+atoi(szCmdBuff)*60*1000;
			}
			return TRUE;
		}

		//성주 클랜 설정
		len = rsCompString( "/set_castle_master" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode && AutoPlayServer ) {
			if ( !rsBlessCastle.CastleMode && lpPlayInfo->dwClanCode ) {
				lpBuff = szChatCommand + len;
				lpBuff = rsGetWord( szCmdBuff , lpBuff );	//레벨
				if ( !szCmdBuff[0] )
					rsBlessCastle.dwMasterClan = lpPlayInfo->dwClanCode;
				else
					rsBlessCastle.dwMasterClan = atoi(szCmdBuff);

				wsprintf( TransChatMessage.szMessage , "> Castle Master Clan [ %d ]" , rsBlessCastle.dwMasterClan );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

			}
			return TRUE;
		}
	}

	if ( StageArea[rsCASTLE_FIELD].dwActiveMode || LoginServer ) {
		//블레스 캐슬 설정정보 확인
		len = rsCompString( "/get_castle_info" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode ) {

			wsprintf( TransChatMessage.szMessage , "> BlessCastle ( MasterClan[%d] Tax[%d] NextTax[%d] ) MyClan(%d/%d) Mode(%d)" , 
				rsBlessCastle.dwMasterClan ,
				rsBlessCastle.Tax ,
				rsBlessCastle.NextTax,
				lpPlayInfo->dwClanCode , lpPlayInfo->smCharInfo.ClassClan , 
				rsBlessCastle.CastleMode );

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

			return TRUE;
		}

		//블레스 캐슬 영혼의샘 정보 확인
		len = rsCompString( "/get_fountain_info" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode ) {

			wsprintf( TransChatMessage.szMessage , "> SoulFountain ( Potion[%d] LastUser[%d] Time[%d] Time2[%d] ) Count[%d]" , 
				rsBlessCastle.SoulFountain_PotionCount,
				rsBlessCastle.SoulFountain_LastUserCount,
				rsBlessCastle.dwSoulFountainTime-dwPlayServTime,
				rsBlessCastle.dwSoulFountainTime2-dwPlayServTime,
				rsBlessCastle.Counter );

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

			return TRUE;
		}

		//블레스 캐슬 영혼의샘 생성시간정보 초기화
		len = rsCompString( "/reset_fountain_time" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode ) {

			rsBlessCastle.dwSoulFountainTime = 0;
			rsBlessCastle.dwSoulFountainTime2 = 0;

			wsprintf( TransChatMessage.szMessage , "> Reset SoulFountain (PlayServTime %d)" , dwPlayServTime );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

			return TRUE;
		}

		//rsBlessCastle.Counter
		//rsBlessCastle.dwSoulFountainTime


		//블레스 캐슬 설정정보 확인 (세율 미리적용)
		len = rsCompString( "/set_castle_tax" , szChatCommand );
		if ( len && lpPlayInfo->AdminMode ) {

			rsBlessCastle.Tax = rsBlessCastle.NextTax;		//세율 미리 적용 (디버깅용)
			rsBlessCastle.SelectedSkill = rsBlessCastle.BlessCastleSetup.ClanSkill;	//선택된 스킬 적용

			wsprintf( TransChatMessage.szMessage , "> BlessCastle ( MasterClan[%d] Tax[%d] NextTax[%d]" , 
				rsBlessCastle.dwMasterClan ,
				rsBlessCastle.Tax ,
				rsBlessCastle.NextTax );

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

			return TRUE;
		}
	}

	//나쁜이 정보 보기
	len = rsCompString( "/show_blackuser" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {

		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴

		rsShowBlackList( lpPlayInfo->lpsmSock , szCmdBuff );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}

	//나쁜이 정보 보기
	len = rsCompString( "/reset_blackuser" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		//나쁜자들 명단 모두 초기화
		rsResetBackList();

		lstrcpy( TransChatMessage.szMessage , "> Reset BlackUser OK!" );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}

	//나쁜이 해제
	len = rsCompString( "/free_blackuser" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( rsFreekBackListID( szCmdBuff )==TRUE ) {
			lstrcpy( TransChatMessage.szMessage , "> Free BlackUser OK!" );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}

// 해외 블랙유저 아닐경우의 메세지 출력 테스트
		else
		{
			lstrcpy( TransChatMessage.szMessage , "> Non-Blackuser, Check again." );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
//////////////////////////////////////////////////////////////////////////////////////////////////////

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}

	//유저 를 투명하게
	len = rsCompString( "/hide" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		lpPlayInfo->HideMode = TRUE;

		lstrcpy( TransChatMessage.szMessage , "Hide OK!" );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}
	//유저 를 정상으로
	len = rsCompString( "/show" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		lpPlayInfo->HideMode = FALSE;

		lstrcpy( TransChatMessage.szMessage , "Show OK!" );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}

	//서버에서 파악한 돈 정보 표시
	len = rsCompString( "/get_money" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode>2 && lpPlayInfo->ServerMoney ) {

		wsprintf( TransChatMessage.szMessage , "> Server Money ( %d )( %d )" , 
			lpPlayInfo->spMoney_Start , lpPlayInfo->ServerMoney );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}
/*
	//시간분배경험치 정보 표시 (베트남)
	len = rsCompString( "/get_expgametime" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {

		cnt = lpPlayInfo->dwExpGameTime/1000;
		len = cnt%(60*60);
		wsprintf( TransChatMessage.szMessage , "> ExpGameTime Exp( %d ) ExpTime( %d:%d:%d )" , 
			rsGetExp_GameTime(lpPlayInfo) , cnt/(60*60) , len/60 , cnt%60 );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		return TRUE;
	}
*/

	//데미지 정보 표시
	len = rsCompString( "/dm_info" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {

		wsprintf( TransChatMessage.szMessage , "Limit Damage ( %d %d %d )" , 
			lpPlayInfo->sLimitDamage[0], lpPlayInfo->sLimitDamage[1] , lpPlayInfo->sLimitCritical[0] );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
		return TRUE;
	}

	//GUID 정보 표시
	len = rsCompString( "/get_guid" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {

		wsprintf( TransChatMessage.szMessage , "> Guid( %s ) GpCode( %s ) PCRno( %d ) GpType( %d )" , 
			lpPlayInfo->szGuid , lpPlayInfo->szGPCode , lpPlayInfo->Bl_RNo , lpPlayInfo->GpType );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}

	//Event LEvel 정보 표시
	len = rsCompString( "/get_event_level" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {

		wsprintf( TransChatMessage.szMessage , "> Event Level ( %d ) " , lpPlayInfo->Event_StarTicketLevel );

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}


	len = rsCompString( "/권한부여" , szChatCommand );
	if ( len && lpPlayInfo->AdminMode ) {
		lpBuff = szChatCommand + len;
		lpBuff = rsGetWord( szCmdBuff , lpBuff );	//ID 읽어옴
		if ( !szCmdBuff[0] ) return FALSE;

		lpPlayInfo2=FindUserFromName( szCmdBuff );
		if ( lpPlayInfo2 ) {

			lpPlayInfo2->AdminMode = lpPlayInfo->AdminMode;

			wsprintf( TransChatMessage.szMessage , "> %d 에게 권한(%d)이 부여되었습니다" , 
				lpPlayInfo2->smCharInfo.szName , lpPlayInfo2->AdminMode );

			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			lpPlayInfo2->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
	}

	if ( DebugServerMode ) {

		if ( spJobCodeTime<dwPlayServTime ) {
			spJobCode = 0;
			spItemNormal = 0;
			spJobCodeTime = 0;
		}

		if ( spTimeAdjustTime<dwPlayServTime ) {
			spTimeAdjustTime = 0;
			spTimeAdjust = 0;
		}


		lpsItem = new psITEM;

		if ( srSetItemFromCode( lpsItem , &szChatCommand[1] )==TRUE ) {
			lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );
			if ( lpStgArea ) {
				lpsItem->state = TRUE;
				lpStgArea->AddItem( lpsItem , lpPlayInfo->Position.x>>FLOATNS, lpPlayInfo->Position.y>>FLOATNS, lpPlayInfo->Position.z>>FLOATNS );

				rsRecordAdminCommand( lpPlayInfo , szChatCommand , 3 );		//운영자 명령 사용기록
			}
		}
		delete lpsItem;
	}
#endif

	return TRUE;
}

#else

char *szAdminLogin = "빨간마후라";
char *szAdminChar = "김대호만세";
char *szAdminMessage[4] = { 0,0,0,0 };
char *szAdminSucess[4] = {0,0,0,0};

//크랙 찾기 초기화
int	InitCrackFinding()
{
	return TRUE;
}
//크랙 검색 요구
int	SendFindCrack( smWINSOCK *lpsmSock )
{
	return TRUE;
}

int RecvCommand( rsPLAYINFO *lpPlayInfo , char *szChatCommand )
{
	return TRUE;
}



#endif


int SendQuickMessage( rsPLAYINFO *lpPlayInfo , char *szMessage ) 
{

	TRANS_CHATMESSAGE	TransChatMessage;

	wsprintf( TransChatMessage.szMessage , "From> %s: %s" , szAdminChar , szMessage ); 
	TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
	TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
	TransChatMessage.dwIP = 0;
	TransChatMessage.dwObjectSerial = 0;

	lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

	return TRUE;

}

int SendQuickMessage2( rsPLAYINFO *lpPlayInfo , char *szMessage ) 
{

	TRANS_CHATMESSAGE	TransChatMessage;

	wsprintf( TransChatMessage.szMessage , "%s" , szMessage ); 
	TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
	TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
	TransChatMessage.dwIP = 0;
	TransChatMessage.dwObjectSerial = 0;

	lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

	return TRUE;

}





/*
#ifdef _LANGUAGE_KOREAN
//내국어
#define CHAT_ANGERMONSTER_MAX		5
char *szAngerMonster[CHAT_ANGERMONSTER_MAX] = {
	"더 이상은 참을수 없다!",
	"종족의 복수다.",
	"우리를 괴롭히지 마라.",
	"참을수 없다",
	"우리를 괴롭히지 마라."
};

#else
//외국어 바꿔야됨
#define CHAT_ANGERMONSTER_MAX		5
char *szAngerMonster[CHAT_ANGERMONSTER_MAX] = {
	"더 이상은 참을수 없다!",
	"종족의 복수다.",
	"우리를 괴롭히지 마라.",
	"참을수 없다",
	"우리를 괴롭히지 마라."
};

#endif
*/

#ifdef _xTrap_GUARD
#ifdef _W_SERVER
// [XTrapCC #1] XTrapCC.h 파일 인클루드
#pragma comment(lib,"XTrapSvrSrc/XTrapCC_mt.lib")
//#include "XTrapSvrSrc/XTrapCC.h"

XC_CMF				rsXTrap_Cmf[2];
//int					rsXTrap_InitFlag = 0;

int rsXTrap_Init()
{
	FILE *fp;
	fp=fopen(".\\CMF1.dat","rb");
	if ( fp ) { fread( rsXTrap_Cmf[0] , sizeof(unsigned char), XC_CMF_SIZE , fp ); fclose(fp); }
	fp=fopen(".\\CMF2.dat","rb");
	if ( fp ) { fread( rsXTrap_Cmf[1] , sizeof(unsigned char), XC_CMF_SIZE , fp ); fclose(fp); }
	//rsXTrap_InitFlag = TRUE;

	return TRUE;
}

//로그인 성공 (엑스트랩 키생성)
int rsXTrap_Login( rsPLAYINFO *lpPlayInfo )
{

	smTRANS_XTRAP_ADDR	smTransXTrapAddr;
	smTRANS_COMMAND		smTransCommand;

	XC_ADDR		Addr[2]	= {0,};
	SeedKeyGenEx(rsXTrap_Cmf,2, lpPlayInfo->smXTrapInfo.KeyValue, Addr);

	smTransXTrapAddr.smTransCommand.size = sizeof(smTRANS_XTRAP_ADDR);
	smTransXTrapAddr.smTransCommand.code = smTRANSCODE_XTRAP_PACKET;
	smTransXTrapAddr.smTransCommand.WParam = smXTRAP_COMMAND_LOGIN;
	smTransXTrapAddr.smTransCommand.LParam = 0;
	smTransXTrapAddr.smTransCommand.SParam = 0;
	smTransXTrapAddr.smTransCommand.EParam = 0;

	memcpy(&smTransXTrapAddr.Addr, Addr, XC_ADDR_SIZE*2);

	lpPlayInfo->lpsmSock->Send2( (char *)&smTransXTrapAddr , smTransXTrapAddr.smTransCommand.size , TRUE );
#ifdef _LANGUAGE_BRAZIL
	lpPlayInfo->smXTrapInfo.dwKeyGenTime = dwPlayServTime+60*1000*10;			//제한시간 브라질 10분설정 ( 10분마다 확인 )
#else
	lpPlayInfo->smXTrapInfo.dwKeyGenTime = dwPlayServTime+60*1000*5;			//제한시간 5분설정 ( 5분마다 확인 )
#endif
	lpPlayInfo->smXTrapInfo.KeyGenWaitCount++;

	if ( lpPlayInfo->smXTrapInfo.KeyGenWaitCount>2 )
	{
		//2회 이상 클라이언트에서 XTRAP 응답이 없는경우
		smTransCommand.WParam = 8710;
		smTransCommand.LParam = 100;
		smTransCommand.SParam = lpPlayInfo->smXTrapInfo.KeyGenWaitCount;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+10000;		//10초후 종료
	}

	return TRUE;
}

int rsXTrap_RecvSecurity( rsPLAYINFO *lpPlayInfo , smTRANS_XTRAP_SECURITY *lpTransXTrapSecurity )
{
	smTRANS_COMMAND	smTransCommand;

	XC_CLIENTBUF	ClientBuf[2]	= {0,};

	memcpy(ClientBuf, lpTransXTrapSecurity->serialkey, XC_CLIENTBUF_SIZE * 2);
	int rest = XCrackCheckEx(rsXTrap_Cmf, 2, lpPlayInfo->smXTrapInfo.KeyValue, ClientBuf);


/*
	FILE *fp;
	char szBuff[256];
	fp=fopen("XCrackCheckEx.txt" , "wb" );
	if ( fp )
	{
		wsprintf( szBuff , "%d\r\n" , rest );
		fwrite( szBuff , lstrlen(szBuff),1,fp );
		fclose(fp);
	}
*/
	lpPlayInfo->smXTrapInfo.KeyGenWaitCount = 0;

	if(rest == 0)
	{
		//클라이언트 종료
		//클라이언트로 로그 메세지 전송후 종료


		smTransCommand.code = smTRANSCODE_XTRAP_PACKET;
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.WParam = smXTRAP_COMMAND_SECURITY;
		smTransCommand.LParam = rest;
		smTransCommand.SParam = 0;
		smTransCommand.EParam = 0;
		lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

		lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+10000;		//10초후 종료

		smTransCommand.WParam = 8700;
		smTransCommand.LParam = rest;
		smTransCommand.SParam = 0;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		return FALSE;
	}

	return TRUE;
}
#endif


#endif

//클라이언트로 부터 메세지 받음
int RecvMessage( smTHREADSOCK *SockInfo )
{

#ifdef _W_SERVER

	DWORD *IPData;
	smWINSOCK *lpsmSock;
	rsPLAYINFO *lpPlayInfo;
	rsPLAYINFO *lpPlayInfo2;
	TRANS_PLAYPOS *lpTransPlayPos;
	smTRANS_COMMAND	*lpTransCommand;
	smTRANS_COMMAND_EX	*lpTransCommandEx;
	smTRANS_COMMAND		smTransCommand;
	smTRANS_COMMAND_EX	smTransCommandEx;
	smTRNAS_PLAYERINFO	*lpTransPlayerInfo;
	STG_AREA		*lpStgArea;
	smTRANS_ACITON_ITEM		*lpTransActionItem;
	rsRECORD_DBASE *lpRecordBase;
	smTRANS_CHAR_COMMAND	*lpTransCharCommand;
	smTRANS_CHAR_COMMAND2	*lpTransCharCommand2;
	TRANS_CHATMESSAGE	TransChatMessage;
	TRANS_CHATMESSAGE	*lpTransChatMessage;
	TRANS_TRADEITEMS	*lpTransTradeItems;
	TRANS_CLIENT_FUNPOS	*lpTransClientFunPos;

	TRANS_ITEMINFO		*lpTransItemInfo;
	psITEM		*lpsItem;

	STG_ITEMS		*lpStgItem;
	DWORD	dwTime;
	DWORD	dwPacketCode;

	//int cbCnt;
	DWORD Area;
	int cnt,len,rnd;
	smCHAR	*lpChar;
	int ang,x,z;
	//int ang,ang2,x,y,z;
	DWORD	dwTransCode , dwTransSize;
	char	*lpBuff;
	DWORD	dwDataKey;

	//크리티칼 섹션 선언
	EnterCriticalSection( &cSerSection );

	lpsmSock = SockInfo->smMySock;
	lpPlayInfo = (rsPLAYINFO *)lpsmSock->ExtData1;
	IPData = (DWORD *)( SockInfo->Buff );
	dwTime = GetCurrentTime();

	if ( !lpPlayInfo || !lpPlayInfo->lpsmSock ) goto quit;

	if ( lpPlayInfo && !lpPlayInfo->SystemLine && (dwTime-lpPlayInfo->dwPacketAttackTime)>5000 ) {
		if ( lpPlayInfo->dwPacketAttackCount>120 ) {
			//5초 동안 60개 이상의 과도한 패킷 들어옴 ( 패킷을 이용한 서버 공격 )
			//로그에 기록
			smTransCommand.WParam = 5100;
			smTransCommand.SParam = lpPlayInfo->dwPacketAttackCount;
			smTransCommand.LParam = lpPlayInfo->dwPacketAttackCount;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );

			DisconnectUser( lpPlayInfo->lpsmSock );		//연결 종료

			goto quit;
		}
		lpPlayInfo->dwPacketAttackCount = 0;
		lpPlayInfo->dwPacketAttackTime = dwTime;
	}
	else {
		lpPlayInfo->dwPacketAttackCount++;
	}

	dwPacketCode = (IPData[1]&0xFFFF0000);

pRetry:

	if ( dwPacketCode==smTRANSCODE_ENCODE_PACKET || ( lpPlayInfo && dwPacketCode==lpPlayInfo->dwDecPacketCode ) ) {
		//암호화 패킷
		smTHREADSOCK smEncData;

		memcpy( &smEncData , SockInfo , sizeof(smTHREADSOCK)-smSOCKBUFF_SIZE );


		if ( dwPacketCode==smTRANSCODE_ENCODE_PACKET ) {
			dwDataKey = DecodePacket( (BYTE *)SockInfo->Buff , (BYTE *)smEncData.Buff );
		}
		else
			dwDataKey = DecodePacket2( (BYTE *)SockInfo->Buff , (BYTE *)smEncData.Buff , lpsmSock->bDecXor );

		if ( !dwDataKey )
			goto quit;


		cnt = dwDataKey&0xFFFF;

		if ( lpsmSock->CheckEncRecvPacket( cnt )==TRUE ) {
			//들어온 데이타 또 들어온 경우 ( 문제 있음 )
			goto quit;
		}

		if ( cnt<(lpsmSock->EncPacketRecvCount-ENC_PACKET_REC_MAX) ) {
			//아주 오래된 데이타거나 문제있는 경우
			goto quit;
		}
		lpsmSock->PushEncRecvPacket( cnt );			//패킷 번호 기록

		SockInfo = &smEncData;
		IPData = (DWORD *)( SockInfo->Buff );
	}
	else {
		if ( dwPacketCode>=smTRANSCODE_ENCODE_PACKET2 && !lpPlayInfo->dwDecPacketCode ) {
			//암호 모듈인지 확인하여 적용
			if ( rsCompareSafePacket( lpPlayInfo , dwPacketCode )==TRUE ) goto pRetry;
		}
		if ( IPData[1]==smTRANSCODE_ATTACKDATA ||
			IPData[1]==smTRANSCODE_THROWITEM ||
			IPData[1]==smTRANSCODE_TRADE_ITEMKEY ||
			IPData[1]==smTRANSCODE_TRADE_READYITEM )
			goto quit;

	}

	dwTransCode = IPData[1];
	dwTransSize = IPData[0];

	//디버그용 ( 임시 )
	if ( LoginServer ) {
		dwServer_DebugMessage = dwTransCode;
		lstrcpy( szServer_DebugLastUserID , lpPlayInfo->szID );
		lstrcpy( szServer_DebugLastUserName , lpPlayInfo->szName );
		Server_DebugCount = 0;
	}

	switch( dwTransCode ) {

	case smTRANSCODE_SYSTEM:
		//시스템 패킷 ( 다른 서버에서 들어옴 )
		rsRecvSystemInfo( lpPlayInfo , SockInfo->Buff );
		break;

	case smTRANSCODE_PROCESSINFO:
		//프로세스 정보 수신
		lpTransChatMessage = (TRANS_CHATMESSAGE *)SockInfo->Buff;
		
		if ( rsServerConfig.ClientCheckSumCount>0 && !lpPlayInfo->AdminMode) {
			for( cnt=0;cnt<rsServerConfig.ClientCheckSumCount;cnt++ ) {
				if ( lpTransChatMessage->dwObjectSerial==rsServerConfig.dwClientCheckSum[cnt] ) {
					break;
				}
			}
			if ( cnt>=rsServerConfig.ClientCheckSumCount ) {
				//일치하는 체크섬 없음

				//클라이언트 첵크섬 오류
				smTransCommand.WParam = 1103;
				smTransCommand.SParam = lpTransChatMessage->dwObjectSerial;
				smTransCommand.LParam = (int)lpTransChatMessage->szMessage;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				if ( rsServerConfig.ClientCheckOut ) {
					DisconnectUser( lpsmSock );				//접속 종료
				}
			}
		}
		break;

	case smTRANSCODE_CHATMESSAGE:

		if ( !lpPlayInfo->dwObjectSerial ) break;			//신원 불명의 채팅 막기

		lpBuff = &SockInfo->Buff[8];

		lpPlayInfo->ChatMsgMode = 0;

		if ( lpBuff[0]=='/' || lpBuff[0]=='`' ) {
			if ( RecvCommand( lpPlayInfo , lpBuff )>=0 ) break;
		}
		else {
			lstrcpy( lpPlayInfo->szChatMessage , lpBuff );
		}

		len = lstrlen( lpPlayInfo->szChatMessage );

		//긴말 ... 으로 끈음
		if ( len>70 ) {
			for( cnt=0;cnt<68;cnt++) {
				if ( lpPlayInfo->szChatMessage[cnt]>=0x80 )
					cnt++;
			}
			lpPlayInfo->szChatMessage[cnt++] = '.';
			lpPlayInfo->szChatMessage[cnt++] = '.';
			lpPlayInfo->szChatMessage[cnt++] = '.';
			lpPlayInfo->szChatMessage[cnt++] = 0;
		}

		//파티원에게 내용 전송
		//if ( lpPlayInfo->dwPartyInfo && lpPlayInfo->lpPartyMaster )
		//	lpPlayInfo->lpPartyMaster->PartyChatting( lpPlayInfo );

		lpPlayInfo->dwMacroTime = dwPlayServTime;			//채팅 하면 매크로 감시 시간 초기화

		break;

	case smTRANSCODE_PARTY_CHATMSG:
		//파티 전용 채팅

		if ( !lpPlayInfo->dwObjectSerial ) break;			//신원 불명의 채팅 막기

		lpBuff = &SockInfo->Buff[8];

		len = lstrlen( lpBuff );
		lstrcpy( lpPlayInfo->szChatMessage , lpBuff );

		//긴말 ... 으로 끈음
		if ( len>70 ) {
			for( cnt=0;cnt<68;cnt++) {
				if ( lpPlayInfo->szChatMessage[cnt]>=0x80 )
					cnt++;
			}
			lpPlayInfo->szChatMessage[cnt++] = '.';
			lpPlayInfo->szChatMessage[cnt++] = '.';
			lpPlayInfo->szChatMessage[cnt++] = '.';
			lpPlayInfo->szChatMessage[cnt++] = 0;
		}

		//파티원에게 내용 전송
		if ( lpPlayInfo->dwPartyInfo && lpPlayInfo->lpPartyMaster )
			lpPlayInfo->lpPartyMaster->PartyChatting( lpPlayInfo );

		lpPlayInfo->szChatMessage[0] = 0;
		lpPlayInfo->dwMacroTime = dwPlayServTime;			//채팅 하면 매크로 감시 시간 초기화
		break;

	case smTRANSCODE_POSITION:
		//현재 캐릭터의 위치 받음
		lpTransPlayPos = (TRANS_PLAYPOS *)SockInfo->Buff;
		Area = lpPlayInfo->Position.Area;
		memcpy( &lpPlayInfo->Position , &lpTransPlayPos->rsPlayPos , sizeof(rsPLAYPOS) );
		lpPlayInfo->SendListCnt = 0;
/*
		//유저가 있는 지역이 변경 되었으면 구역 링크를 변경한다
		if ( Area!=lpPlayInfo->Position.Area ) {
			if ( lpPlayInfo->lpAreaPlayInfo ) {
				//헌구역 지움
				*lpPlayInfo->lpAreaPlayInfo = 0;
			}

			Area = lpPlayInfo->Position.Area;
			for(cnt=0;cnt<AREA_USERMAX;cnt++) {
				//새 구역을 찾아 설정
				if( AreaPlayUserInfo[Area][cnt]==0 ) {
					AreaPlayUserInfo[Area][cnt] = lpPlayInfo;
					lpPlayInfo->lpAreaPlayInfo = &AreaPlayUserInfo[Area][cnt];
					break;
				}
			}
		}
*/
		lpPlayInfo->smCharInfo.Life[0] = lpTransPlayPos->Hp[0];
		lpPlayInfo->smCharInfo.Life[1] = lpTransPlayPos->Hp[1];

		if ( lpPlayInfo->dwRecvTimePlayBuff ) {
			if ( (dwTime-lpPlayInfo->dwRecvTimePlayBuff)>4*60*1000 ) {
				//60초동안 데이타 수신 없었음
				DisconnectUser( lpsmSock );
			}
		}

		lpPlayInfo->dwRecvTimePlayBuff = dwTime;

		//생명력 오류
		if ( lpTransPlayPos->Hp[0]<0 || lpTransPlayPos->Hp[0]>(lpTransPlayPos->Hp[1]<<1) ) {
			DisconnectUser( lpsmSock );
		}


		if ( lpPlayInfo->lpPartyMaster && rsServerConfig.AreaServer.IP_Count>0 ) {
			//파티가입자 변경된 정보 업데이트
			if ( lpPlayInfo->dwPartyInfo==PARTY_STATE_MASTER ) {
				lpPlayInfo->lpPartyMaster->PartyUpdateFlag++;
				lpPlayInfo->UpdatePartyPlayInfo();
			}
		}
		break;

	case smTRANSCODE_CONTINUEDATA:
		//지역 정보를 계속 보내달라는 요구
		break;

	case smTRANSCODE_GETPLAYERINFO:
		//캐릭터의 정보를 보내 달라는 요구
		//캐릭터 정보적어서 되돌려서 보냄

		//rsSendPlayerInfoQuick( lpsmSock , (smTRANS_COMMAND *)IPData );
		//break;
		if ( lpPlayInfo->AdminMode ) {
			rsSendPlayerInfo( lpPlayInfo , (smTRANS_COMMAND *)IPData );
		}
		else {
			rsSendPlayerInfoQuick( lpPlayInfo , (smTRANS_COMMAND *)IPData );
		}
		break;

#ifndef _LANGUAGE_CHINA
	case smTRANSCODE_ATTACKDATA:
		//공격 수신 받음
		rsRecvAttackData_Old( lpPlayInfo , (TRANS_ATTACKDATA *)SockInfo->Buff , 0 , 0 );
		break;

	case smTRANSCODE_SKIL_ATTACKDATA:
		//공격 범위형 수신
		rsRecvRangeAttackData_Old( lpPlayInfo , (TRANS_SKIL_ATTACKDATA *)SockInfo->Buff , 0 );
		break;
#endif

	case smTRANSCODE_ATTACK_DAMAGE:
		//공격 수신 받음
		rsRecvAttackData( lpPlayInfo , (TRANS_ATTACKDATA2 *)SockInfo->Buff );
		break;

	case smTRANSCODE_RANGE_DAMAGE:
		//범위공격 수신 받음
		rsRecvRangeAttackData( lpPlayInfo , (TRANS_SKIL_ATTACKDATA2 *)SockInfo->Buff );
		break;


	case smTRANSCODE_SKIL_ATTACKUSER:
		//범위형 스킬 공격 ( 유저 공격 )
		//공격 범위형 유저 수신
		rsRecvRangeAttackUserData_Old( lpPlayInfo , (TRANS_SKIL_ATTACKDATA *)SockInfo->Buff );
		break;

	case smTRANSCODE_ADD_STARTPOSI:
		//몬스터 시작 지점 추가	
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

		x = lpTransCommand->LParam;
		z = lpTransCommand->WParam;

		if ( lpPlayInfo->AdminMode>=3 ) {
			lpStgArea = FindStageField( x, z );
			if ( lpStgArea ) {
				lpStgArea->AddStartPoint( x>>FLOATNS, z>>FLOATNS, TRUE );
				lpStgArea->SendStartPointFlag();
			}
		}
		break;

	case smTRANSCODE_DEL_STARTPOSI:
		//몬스터 시작 지점 제거	
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

		x = lpTransCommand->LParam;
		z = lpTransCommand->WParam;

		if ( lpPlayInfo->AdminMode>=3 ) {
			lpStgArea = FindStageField( x, z );
			if ( lpStgArea ) {
				lpStgArea->DeleteStartPoint( x>>FLOATNS, z>>FLOATNS );
				lpStgArea->SendStartPointFlag();
			}
		}
		break;

	case smTRANSCODE_ADD_NPC:
		//NPC 추가
		lpTransPlayerInfo = ( smTRNAS_PLAYERINFO * )SockInfo->Buff;

		if ( lpPlayInfo->AdminMode>=3 ) {
			lpStgArea = FindStageField( lpTransPlayerInfo->x, lpTransPlayerInfo->z );
			if ( lpStgArea ) {
				lpStgArea->AddCharInfoFixed( lpTransPlayerInfo );
			}
		}
		break;

	case smTRANSCODE_DEL_NPC:
		//NPC 제거
		lpTransPlayerInfo = ( smTRNAS_PLAYERINFO * )SockInfo->Buff;

		if ( lpPlayInfo->AdminMode>=3 ) {
			lpStgArea = FindStageField( lpTransPlayerInfo->x, lpTransPlayerInfo->z );
			if ( lpStgArea ) {
				lpStgArea->DeleteCharInfoFixed( lpTransPlayerInfo );
			}
		}
		break;

	case smTRANSCODE_PUTITEM:
		//아이템을 집으려고 시도
		lpTransActionItem = ( smTRANS_ACITON_ITEM *)SockInfo->Buff;
		lpStgArea = (STG_AREA *)lpTransActionItem->lpStgArea;

		//지역 배경 포인터가 올바른지 확인 ( 잘못된 데이타가 수신되는거 방지 )
		if ( IsStgArea(lpStgArea)==FALSE ) break;

		if ( rsServerConfig.Event_HardCore ) {
			//이벤트 지역인지 첵크 - 이벤트가 아닌곳에서 아이템을 취할수 없도록 설정
 			if ( rsCheckHardCoreEventArea( lpTransActionItem->x , lpTransActionItem->y, lpTransActionItem->z )==TRUE ) {
				if ( !lpPlayInfo->EventMode  ) break;
			}
		}


		lpStgItem = lpStgArea->FindItem( lpTransActionItem->x>>FLOATNS , lpTransActionItem->y>>FLOATNS , lpTransActionItem->z>>FLOATNS );
		if ( lpStgItem ) {
			//아이템 집음
			//아이템 보내기

			if ( (lpStgItem->Item.ItemInfo.CODE&sinITEM_MASK2)==sinSD2 ) {
				//SOD 깜짝 아이템 ( 집으면 바로 적용 )
	
				//SOD 아이템 잡다 / 적용시키기
				rsSoD_CatchItem( lpStgItem->Item.ItemInfo.CODE , lpPlayInfo );
				lpStgArea->DeleteItem( lpStgItem );
				break;
			}

			if ( lpPlayInfo->dwPartyInfo && lpStgItem->Item.ItemInfo.CODE==(sinGG1|sin01) && lpStgItem->Item.ItemInfo.Money<10000) {
				//파티원 돈 획득 ( 10000 원 보다 작은 금액일때 )
				if ( lpPlayInfo->lpPartyMaster->GetPartyMoney( &lpStgItem->Item.ItemInfo , lpPlayInfo )==FALSE ) {
					//파티정보 오류
					lpPlayInfo->dwPartyInfo = PARTY_STATE_NONE;
					lpPlayInfo->lpPartyMaster = NULL;
				}
			}
			else {
				TRANS_ITEMINFO	TransItemInfo;

				TransItemInfo.code = smTRANSCODE_PUTITEM;
				TransItemInfo.size = sizeof(TRANS_ITEMINFO);
				memcpy( &TransItemInfo.Item , &lpStgItem->Item.ItemInfo , sizeof( sITEMINFO ) );

				if ( lpStgItem->Item.ItemInfo.CODE==(sinGG1|sin01) ) {
					lpPlayInfo->spMoney_Out += lpStgItem->Item.ItemInfo.Money;				//출금 기록
					TransItemInfo.x = dwPlayServTime;											//해독 키
					TransItemInfo.y = TransItemInfo.Item.ItemHeader.dwChkSum;					//해독 키2
					TransItemInfo.z = lpPlayInfo->spMoney_Out^(TransItemInfo.x+TransItemInfo.y);	//토탈 기록 전송
				}

				rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , lpStgItem->BeginMode );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
				lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );

				//고가의 아이템 입수 기록 파일로 남김 ( 코드 9번 이상 )
				if ( (lpStgItem->Item.ItemInfo.CODE&sinITEM_MASK3)>=sin09 || 
					((lpStgItem->Item.ItemInfo.CODE&sinITEM_MASK2)==sinOS1 && (lpStgItem->Item.ItemInfo.CODE&sinITEM_MASK3)>=sin05)  ) {
					RecordGetHighItem( lpPlayInfo , lpStgItem );
				}

				//파티원에게 아이템 집은 메세지 출력
				if ( lpPlayInfo->dwPartyInfo && lpStgItem->BeginMode && rsServerConfig.Enable_PartyItem ) {

					if( (lpStgItem->Item.ItemInfo.CODE&sinITEM_MASK2)==sinPZ1 || (lpStgItem->Item.ItemInfo.CODE&sinITEM_MASK2)==sinPZ2 ) {
						//퍼즐 ( 내용 숨김 )
						wsprintf( TransChatMessage.szMessage , srMsg_037 , lpPlayInfo->smCharInfo.szName , srItem_PZ );
					}
					else {
						//일반 아이템
						wsprintf( TransChatMessage.szMessage , srMsg_037 , lpPlayInfo->smCharInfo.szName , lpStgItem->Item.ItemInfo.ItemName );
					}

					if ( lpPlayInfo->lpPartyMaster )
						lpPlayInfo->lpPartyMaster->SendPartyMessage( TransChatMessage.szMessage , 9 );
				}

			}

			//lpStgItem->state = 0;
			lpStgArea->DeleteItem( lpStgItem );
		}
		break;

	case smTRANSCODE_PLAYERINFO:
		//상대 플레이어의 데이타 수신 받음
		lpTransPlayerInfo = ( smTRNAS_PLAYERINFO * )SockInfo->Buff;

		memcpy( &lpPlayInfo->smCharInfo , &lpTransPlayerInfo->smCharInfo , sizeof( smCHAR_INFO ) );
		lpPlayInfo->dwCode_Name = GetSpeedSum( lpPlayInfo->smCharInfo.szName );		//고속 체크섬


#ifdef	_SECURITY_UPDATE
		//로그인서버 보안키 확인
		if ( rsCheck_LoginServerSafeKey( &lpPlayInfo->smCharInfo , lpPlayInfo->dwCode_Name )==FALSE ) {
			DisconnectUser( lpPlayInfo->lpsmSock );
			break;
		}
#endif

		lpPlayInfo->Position.x = lpTransPlayerInfo->x;
		lpPlayInfo->Position.y = lpTransPlayerInfo->y;
		lpPlayInfo->Position.z = lpTransPlayerInfo->z;

		if ( !lpPlayInfo->dwObjectSerial ) {
			//lpPlayInfo->dwObjectSerial = GetNewObjectSerial();			//고유 번호 받음
			lpPlayInfo->dwObjectSerial = lpPlayInfo->smCharInfo.dwObjectSerial;	//고유번호 받음 ( 군서버에서 정의됨 )
		}

		if ( !lpPlayInfo->dwObjectSerial ) {
			DisconnectUser( lpPlayInfo->lpsmSock );
			break;
		}


		rsSetDamagePacketKey( lpPlayInfo );						//데미지 암호화 키설정
		rsSendDamageFuncToClient2( lpPlayInfo );				//데미지 암호화 펑션을 통채로 클라이언트에 보낸다

		if ( !lpPlayInfo->sLimitDamage[1] ) {		//기본 제한 데미지 설정
			lpPlayInfo->sLimitDamage[0] = (lpPlayInfo->smCharInfo.Attack_Damage[0]*120)/100;
			lpPlayInfo->sLimitDamage[1] = (lpPlayInfo->smCharInfo.Attack_Damage[1]*120)/100;
			lpPlayInfo->sLimitCritical[0] = (lpPlayInfo->smCharInfo.Critical_Hit*120)/100;

			if ( lpPlayInfo->sLimitDamage[0]<5 ) lpPlayInfo->sLimitDamage[0]=5;
			if ( lpPlayInfo->sLimitDamage[1]<10 ) lpPlayInfo->sLimitDamage[1]=10;
			if ( lpPlayInfo->sLimitCritical[0]<3 ) lpPlayInfo->sLimitCritical[0]=3;
		}

		//lpPlayInfo->dwClanCode = lpPlayInfo->smCharInfo.ClassClan/100;		//클랜코드 등록
		lpPlayInfo->dwClanCode = GetClanCode(lpPlayInfo->smCharInfo.ClassClan);		//클랜코드 등록


		//자신의 등록 고유 번호 알려줌 
		smTransCommand.code = smTRANSCODE_CONNECTED;
		smTransCommand.size = sizeof( smTRANS_COMMAND );
		smTransCommand.WParam = lpPlayInfo->dwObjectSerial;			//고유번호
		smTransCommand.LParam = dwTime;								//서버의 고유시간
		lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

		lpPlayInfo2=FindUserFromName( lpPlayInfo->smCharInfo.szName );
		if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock && lpPlayInfo2->TransInfoFlag && !lpPlayInfo2->AdminMode ) {
			//같은 이름이 들어와 있음 ( 먼저 접속자 연결 끊음)
			DisconnectUser( lpPlayInfo2->lpsmSock );
			break;
		}


		//스킨핵 방지
		if ( rsServerConfig.CheckModelFile && !lpPlayInfo->AdminIP ) {
			if ( !lpPlayInfo->smCharInfo.szModelName[0] || rsCheckActiveFile( lpPlayInfo->smCharInfo.szModelName )==FALSE ) {
				//잘못된 모델 캐릭터
				//DisconnectUser( lpPlayInfo->lpsmSock );
				smTransCommand.WParam = 8880;
				smTransCommand.LParam = (DWORD)lpPlayInfo->smCharInfo.szModelName;
				smTransCommand.SParam = (DWORD)lpPlayInfo->smCharInfo.szModelName2;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
				break;
			}
			if ( lpPlayInfo->smCharInfo.szModelName2[0] && rsCheckActiveFile( lpPlayInfo->smCharInfo.szModelName2 )==FALSE ) {
				//잘못된 모델 캐릭터
				//DisconnectUser( lpPlayInfo->lpsmSock );
				smTransCommand.WParam = 8880;
				smTransCommand.LParam = (DWORD)lpPlayInfo->smCharInfo.szModelName;
				smTransCommand.SParam = (DWORD)lpPlayInfo->smCharInfo.szModelName2;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
				break;
			}
		}

		if ( rsServerConfig.AreaServer.IP_Count>0 ) {
			//지역별 분할 서버 매핑정보
			lpsmSock->Send2( (char *)&rsServerConfig.AreaServer , rsServerConfig.AreaServer.size , TRUE );
		}
	
		lpPlayInfo->TransInfoFlag = TRUE;
		lpPlayInfo->dwLastExpMoneyCheckTime = dwPlayServTime;	//경험치 돈 클라이언트라 비교시간
		lpPlayInfo->UpdateInfo_WarnigCounter++;

		rsSendCharInfoToLoginServer( lpPlayInfo );				//군서버에 확인정보 보냄
		break;

	case smTRANSCODE_PLAYERINFO2:
		//상대 플레이어의 데이타 수신 받음 ( 보조 서버 수신 ->고유번호 함께 수신 )
		lpTransPlayerInfo = ( smTRNAS_PLAYERINFO * )SockInfo->Buff;

		memcpy( &lpPlayInfo->smCharInfo , &lpTransPlayerInfo->smCharInfo , sizeof( smCHAR_INFO ) );

		//스킨핵 방지
		if ( rsServerConfig.CheckModelFile && !lpPlayInfo->AdminIP ) {
			if ( !lpPlayInfo->smCharInfo.szModelName[0] || rsCheckActiveFile( lpPlayInfo->smCharInfo.szModelName )==FALSE ) {
				//잘못된 모델 캐릭터
				//DisconnectUser( lpPlayInfo->lpsmSock );
				smTransCommand.WParam = 8880;
				smTransCommand.LParam = (DWORD)lpPlayInfo->smCharInfo.szModelName;
				smTransCommand.SParam = (DWORD)lpPlayInfo->smCharInfo.szModelName2;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				break;
			}
			if ( lpPlayInfo->smCharInfo.szModelName2[0] && rsCheckActiveFile( lpPlayInfo->smCharInfo.szModelName2 )==FALSE ) {
				//잘못된 모델 캐릭터
				//DisconnectUser( lpPlayInfo->lpsmSock );
				smTransCommand.WParam = 8880;
				smTransCommand.LParam = (DWORD)lpPlayInfo->smCharInfo.szModelName;
				smTransCommand.SParam = (DWORD)lpPlayInfo->smCharInfo.szModelName2;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				break;
			}
		}

		lpPlayInfo->dwCode_Name = GetSpeedSum( lpPlayInfo->smCharInfo.szName );		//고속 체크섬

#ifdef	_SECURITY_UPDATE
		//로그인서버 보안키 확인
		if ( rsCheck_LoginServerSafeKey( &lpPlayInfo->smCharInfo , lpPlayInfo->dwCode_Name )==FALSE ) {
			DisconnectUser( lpPlayInfo->lpsmSock );
			break;
		}
#endif

		if ( !lpPlayInfo->dwObjectSerial ) lpPlayInfo->dwObjectSerial = lpTransPlayerInfo->dwObjectSerial;
		lpPlayInfo->TransInfoFlag = TRUE;
		lpPlayInfo->dwLastExpMoneyCheckTime = dwPlayServTime;	//경험치 돈 클라이언트라 비교시간

		rsSetDamagePacketKey( lpPlayInfo );							//데미지 암호화 키설정
		rsSendDamageFuncToClient2( lpPlayInfo );					//데미지 암호화 펑션을 통채로 클라이언트에 보낸다

		if ( !lpPlayInfo->sLimitDamage[1] ) {		//기본 제한 데미지 설정
			lpPlayInfo->sLimitDamage[0] = (lpPlayInfo->smCharInfo.Attack_Damage[0]*120)/100;
			lpPlayInfo->sLimitDamage[1] = (lpPlayInfo->smCharInfo.Attack_Damage[1]*120)/100;
			lpPlayInfo->sLimitCritical[0] = (lpPlayInfo->smCharInfo.Critical_Hit*120)/100;

			if ( lpPlayInfo->sLimitDamage[0]<5 ) lpPlayInfo->sLimitDamage[0]=5;
			if ( lpPlayInfo->sLimitDamage[1]<10 ) lpPlayInfo->sLimitDamage[1]=10;
			if ( lpPlayInfo->sLimitCritical[0]<3 ) lpPlayInfo->sLimitCritical[0]=3;
		}

		//lpPlayInfo->dwClanCode = lpPlayInfo->smCharInfo.ClassClan/100;		//클랜코드 등록
		lpPlayInfo->dwClanCode = GetClanCode(lpPlayInfo->smCharInfo.ClassClan);		//클랜코드 등록
		lpPlayInfo->UpdateInfo_WarnigCounter++;

		break;

	case smTRANSCODE_TRANSPLAYDATA:
		//게임 진행 수신
		smTRANS_PLAYDATA	*lpTransPlayData;
		smTRANS_PLAYBUFF	*lpTransPlayBuff;

		lpTransPlayData = (smTRANS_PLAYDATA *)SockInfo->Buff;

		//잘못된 데이타일 가능성이 커서 무시
		if ( lpTransPlayData->PlayBuffCnt>=32 ) break;

		if ( lpTransPlayData->PlayBuffCnt<=1 ) {
			//네트웤 슬립 모드 돌입 
			if (lpPlayInfo->PlayBuffSleep==0)
				lpPlayInfo->PlayBuffSleep = 1;

			cnt = srPLAYBUFF_MAX;
		}
		else {
			cnt = lpPlayInfo->srRecvPlayBuffCnt & srPLAYBUFF_MASK;
			lpPlayInfo->PlayBuffSleep = 0;
			lpPlayInfo->srRecvPlayBuffCnt++;
		}
/*
#ifdef	_LANGUAGE_CHINESE
		//중국판 해킹이 많기 때문에 이펙트 기능 제한함
		lpTransPlayData->bEventInfo[TRANS_PLAYDATA_EVENT_EXT] = 0;
#endif
*/

		memcpy( &lpPlayInfo->srPlayBuff[cnt] , lpTransPlayData , dwTransSize );
		lpPlayInfo->srPlayBuffSize[cnt] = dwTransSize;

		if ( lpPlayInfo->lpPartyMaster ) {
			//파티가입자 변경된 정보 업데이트
			//if ( lpPlayInfo->smCharInfo.Life[0]!=lpTransPlayData->Hp[0] || lpPlayInfo->smCharInfo.Level!=lpTransPlayData->bEventInfo[TRANS_PLAYDATA_EVENT_LEVEL] ) {
				lpPlayInfo->lpPartyMaster->PartyUpdateFlag++;
			//}
		}

		lpPlayInfo->smCharInfo.Life[0] = lpTransPlayData->Hp[0];
		lpPlayInfo->smCharInfo.Life[1] = lpTransPlayData->Hp[1];
		lpPlayInfo->smCharInfo.Level = lpTransPlayData->bEventInfo[TRANS_PLAYDATA_EVENT_LEVEL];
/*
		if ( lpPlayInfo->srRecvPlayBuffCnt&0x1F && !lpPlayInfo->BadPlayer ) {
			//레벨 제한구역 침범 유저 확인
			if ( (lpTransPlayData->wArea[0]<16 && lpTransPlayData->wArea[0]>12) || 
				( lpTransPlayData->wArea[1]<16 && lpTransPlayData->wArea[1]>12 ) ) {

				if ( lpPlayInfo->smCharInfo.Level<40 && !lpPlayInfo->AdminMode ) {
					lpPlayInfo->BadPlayer = TRUE;

					smTransCommand.WParam = 1840;
					smTransCommand.SParam = lpPlayInfo->smCharInfo.Level;
					smTransCommand.LParam = (lpTransPlayData->wArea[0])|(lpTransPlayData->wArea[0]<<16);
					RecordHackLogFile( lpPlayInfo , &smTransCommand );
				}
			}
		}
*/
		//캐릭터 모션 프레임 정보에서 위치를 얻는다
		if ( lpTransPlayData->PlayBuffCnt>0 ) {
			lpTransPlayBuff = (smTRANS_PLAYBUFF *) ( ((char *)lpTransPlayData)+sizeof(smTRANS_PLAYDATA) );
			lpTransPlayBuff += lpTransPlayData->PlayBuffCnt-1;
			lpPlayInfo->Position.x = lpTransPlayBuff->PlayBuff.x;
			lpPlayInfo->Position.y = lpTransPlayBuff->PlayBuff.y;
			lpPlayInfo->Position.z = lpTransPlayBuff->PlayBuff.z;
			lpPlayInfo->Position.Area = lpTransPlayData->wArea[0];

			//현재 플레이어의 필드 바닥위치 확인
			rsCheckPlayField( lpPlayInfo );

			//매크로 감시
			x = (lpPlayInfo->Position.x-lpPlayInfo->Macro_PosX)>>FLOATNS;
			z = (lpPlayInfo->Position.z-lpPlayInfo->Macro_PosZ)>>FLOATNS;

			if ( abs(x)>80 || abs(z)>80 ) {
				lpPlayInfo->Macro_PosX = lpPlayInfo->Position.x;
				lpPlayInfo->Macro_PosZ = lpPlayInfo->Position.z;
				lpPlayInfo->dwMacroTime = dwPlayServTime;
			}

			if ( lpPlayInfo->Macro_AngY!=lpTransPlayBuff->PlayBuff.angle[1] ) {
				lpPlayInfo->dwMacroAngTime = dwPlayServTime;
				lpPlayInfo->Macro_AngY = lpTransPlayBuff->PlayBuff.angle[1];
			}

			lpPlayInfo->dwMacroChkTime = dwPlayServTime;
		}

		//몬스터/NPC 데이타 보내주기
		//srTransAutoPlayData( lpPlayInfo );
		//캐릭터 데이타 보내주기
		//srTransCharPlayData( lpPlayInfo );

		if ( lpPlayInfo->dwRecvTimePlayBuff ) {
			if ( (dwTime-lpPlayInfo->dwRecvTimePlayBuff)>4*60*1000 ) {
				//60초동안 데이타 수신 없었음
				DisconnectUser( lpsmSock );
			}
		}

		lpPlayInfo->dwRecvTimePlayBuff = dwTime;

		if ( lpTransPlayData->bUpdateInfo[0]!=lpPlayInfo->smCharInfo.bUpdateInfo[0] ) {
			if ( lpPlayInfo->UpdateInfo_WaitCounter>6 && (lpPlayInfo->UpdateInfo_WaitCounter&0x7)==0 ) {
				//업데이트 정보가 틀림 ( 갱신요구 )
				smTransCommand.code = smTRANSCODE_GETPLAYERINFO;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = lpPlayInfo->dwObjectSerial;
				smTransCommand.LParam = lpPlayInfo->smCharInfo.bUpdateInfo[0];
				smTransCommand.SParam = lpTransPlayData->bUpdateInfo[0];
				lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
				lpPlayInfo->UpdateInfo_WarnigCounter++;
			}
			lpPlayInfo->UpdateInfo_WaitCounter++;
		}
		else
			lpPlayInfo->UpdateInfo_WaitCounter = 0;

		//생명력 오류
		if ( lpTransPlayData->Hp[0]<0 || lpTransPlayData->Hp[0]>(lpTransPlayData->Hp[1]<<1) ) {
			DisconnectUser( lpsmSock );
		}
		if ( lpPlayInfo->UpdateInfo_WarnigCounter>50 ) {
			//업데이트 경고 초과 50회 이상 업데이트 요구 및 업데이트 했음
			smTransCommand.WParam = 8570;
			smTransCommand.LParam = lpPlayInfo->smCharInfo.bUpdateInfo[0];
			smTransCommand.SParam = lpTransPlayData->bUpdateInfo[0];
			smTransCommand.EParam = lpPlayInfo->UpdateInfo_WarnigCounter;
			rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
		}

		lpPlayInfo->dwLastMotionRecvTime = dwPlayServTime;			//마지막 받은 시간 기록

		UserPlayServer = TRUE;			//사용자 데이타 전송 서버
		break;

	case smTRANSCODE_RECORDDATA:
		if ( lpPlayInfo->dwFuncChkErrorFlag ) {
			//펑션첵크 에러
			smTransCommand.WParam = 1130;
			smTransCommand.SParam = lpPlayInfo->Client_Version;
			smTransCommand.LParam = lpPlayInfo->dwFuncChkErrorFlag;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );

			if ( lpPlayInfo->lpRecordDataBuff ) 
				((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size = 0;

			DisconnectUser(lpsmSock);
			break;
		}

		if ( lpPlayInfo->dwHopeDisconnectTime ) break;			//종료 시간 예약되 있음 ( 저장 하지 않기 )
		if ( !lpPlayInfo->szID[0] ) break;						//로그인이 제대로 되지 않음 ( 아이디가 없다 )

		if ( !lpPlayInfo->lpRecordBase ) {
			//처음 저장할 데이타일 경우 클래스 생성
			lpPlayInfo->lpRecordBase = new rsRECORD_DBASE;
			if ( lpPlayInfo->lpRecordBase ) {
				lpPlayInfo->lpRecordBase->TransLastPartCount = 0;
			}
		}

		int val;

		//val = lpPlayInfo->lpRecordBase->RecvRecordDataFromClient( (TRANS_RECORD_DATAS *)SockInfo->Buff , lpPlayInfo->smCharInfo.Level , lpPlayInfo->CrackWarning , lpPlayInfo->lpRecordDataBuff );
		val = lpPlayInfo->lpRecordBase->RecvRecordDataFromClient( (TRANS_RECORD_DATAS *)SockInfo->Buff , lpPlayInfo ); //->smCharInfo.Level , lpPlayInfo->CrackWarning , lpPlayInfo->lpRecordDataBuff );
		if ( val==-1 ) {
			//저장 첵크섬 오류
			smTransCommand.WParam = 1600;
			smTransCommand.SParam = 0;
			smTransCommand.LParam = 0;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );	
		}

		if ( val==-2 ) {
			//저장 레벨 오류
			smTransCommand.WParam = 2300;
			smTransCommand.SParam = lpPlayInfo->smCharInfo.Level;
			smTransCommand.LParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
		}

		if ( val==-5 ) {
			//아이템 데이타 수신 오류
			smTransCommand.WParam = 2400;
			smTransCommand.SParam = lpPlayInfo->lpRecordBase->TransRecordData.ItemCount;
			smTransCommand.LParam = lpPlayInfo->lpRecordBase->TransRecordData.DataSize;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
		}

		if ( val==-6 ) {

			//경험치가 오차가 큼
			smTransCommand.WParam = 6600;
			smTransCommand.SParam = (int)((lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp-lpPlayInfo->spExp_Start)/1000);
			smTransCommand.LParam = (lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.TotalExp^lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.PosX)/1000;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;


			//저장된 데이타의 경험치와 돈을 초기 상태로 변경
			//rsRecordMemoryBuffToFile( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->lpRecordDataBuff );
			//FixRecordData( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->spExp_Start , lpPlayInfo->spMoney_Start );

			//if ( lpPlayInfo->lpRecordDataBuff ) 
			//	((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size = 0;
		}

		if ( val==-7 ) {
			//돈의 오차가 큼
			smTransCommand.WParam = 6610;
			smTransCommand.SParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Money-lpPlayInfo->spMoney_Start;
			smTransCommand.LParam = lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.TotalMoney^lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.PosZ;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;

			//저장된 데이타의 경험치와 돈을 초기 상태로 변경
			//rsRecordMemoryBuffToFile( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->lpRecordDataBuff );
			//FixRecordData( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->spExp_Start , lpPlayInfo->spMoney_Start );

			//if ( lpPlayInfo->lpRecordDataBuff ) 
			//	((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size = 0;
		}

		if ( val==-8 ) {
			//캐릭터 정보 스텟에 문제 발생
			smTransCommand.WParam = 6900;
			smTransCommand.SParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level;
			smTransCommand.LParam = 
				lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Strength+
				lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Spirit+
				lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Dexterity+
				lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Health+
				lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Talent+
				lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.StatePoint;

			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;

			//저장된 데이타의 경험치와 돈을 초기 상태로 변경
			//rsRecordMemoryBuffToFile( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->lpRecordDataBuff );
			//FixRecordData( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->spExp_Start , lpPlayInfo->spMoney_Start );

			//if ( lpPlayInfo->lpRecordDataBuff ) 
			//	((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size = 0;

		}

		if ( val==-9 ) {
			//경험치 배분율 오류 ( 서버에서 받은 경험치에 비해 클라이언트에서 올라간 경험치가 33% 초과 )
			smTransCommand.WParam = 6620;
			smTransCommand.SParam = lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.TotalSubExp;
			smTransCommand.LParam = lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.TotalExp^lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.PosX;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;

			//저장된 데이타의 경험치와 돈을 초기 상태로 변경
			//rsRecordMemoryBuffToFile( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->lpRecordDataBuff );
			//FixRecordData( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->spExp_Start , lpPlayInfo->spMoney_Start );

			//if ( lpPlayInfo->lpRecordDataBuff ) 
			//	((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size = 0;

		}

		if ( val==-10 ) {
			//스킬포인트 조작 오류
			CheckSkillPoint( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level , &lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.SkillInfo , &cnt , lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.dwLevelQuestLog );
			smTransCommand.WParam = 6910;
			smTransCommand.LParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level;
			smTransCommand.SParam = cnt;
			smTransCommand.EParam = lpPlayInfo->lpRecordBase->TransRecordData.GameSaveInfo.dwLevelQuestLog;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;

			//저장된 데이타의 경험치와 돈을 초기 상태로 변경
			//rsRecordMemoryBuffToFile( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->lpRecordDataBuff );
			//FixRecordData( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->spExp_Start , lpPlayInfo->spMoney_Start );

			//if ( lpPlayInfo->lpRecordDataBuff ) 
			//	((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size = 0;
		}

		if ( val==-11 ) {
			//아이템 무게 오류
			smTransCommand.WParam = 6920;
			smTransCommand.SParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Weight[1];
			smTransCommand.LParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Weight[0];
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;
		}

		if ( val==-12 ) {
			//레벨 2단계 이상 상승
			smTransCommand.WParam = 2100;
			smTransCommand.LParam = lpPlayInfo->smCharInfo.Level;
			smTransCommand.SParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;
		}

		if ( val==-14 ) {
			//직업 코드 오류
			smTransCommand.WParam = 7030;
			smTransCommand.LParam = lpPlayInfo->smCharInfo.Level;
			smTransCommand.SParam = lpPlayInfo->smCharInfo.JOB_CODE;
			smTransCommand.EParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.JOB_CODE;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;
		}

		if ( val==-15 ) {
			//저장될 데이타 이름과 서버의 이름이 맞지않음
			smTransCommand.WParam = 8030;
			smTransCommand.LParam = (int)lpPlayInfo->szName; 
			smTransCommand.SParam = (int)lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName;
			smTransCommand.EParam = (int)lpPlayInfo->smCharInfo.szName;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->dwTime_Disconnect = 1;
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3000;
		}

		if ( val<0 ) {
			//저장에 문제 생김

			//저장 실패 알려줌
			smTransCommand.code = smTRANSCODE_RECORDRESULT;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = FALSE;
			smTransCommand.LParam = 0;
			smTransCommand.SParam = rsBlessCastle.Tax;
			smTransCommand.EParam = (int)rsBlessCastle.dwMasterClan;
			lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

			delete lpPlayInfo->lpRecordBase;
			lpPlayInfo->lpRecordBase = 0;
		}

		if ( val==TRUE ) {
/*
			///////////////////////////// 게임서버 경험치 확인 ////////////////////
			len = lpPlayInfo->dwGameServerExp[0] + lpPlayInfo->dwGameServerExp[1] + lpPlayInfo->dwGameServerExp[2] + lpPlayInfo->dwGameServerExp[3] +
				lpPlayInfo->dwGameServerExp[4] + lpPlayInfo->dwGameServerExp[5] + lpPlayInfo->dwGameServerExp[6] + lpPlayInfo->dwGameServerExp[7];
			//게임 서버로 부터 받은 경험치
			rnd = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp-lpPlayInfo->spExp_Start;

			if ( rnd>len ) {
				x = rnd-len;			//보조 획득 경험치

				cnt = 10000;
				if ( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level>=10 && lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level<20 ) cnt = 20000;
				else if ( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level>=20 && lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level<40 ) cnt = 50000;
				else if ( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level>=40 && lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level<60 ) cnt = 250000;
				else if ( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level>=60 && lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level<70 ) cnt = 500000;
				else if ( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level>=70 && lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level<100 ) cnt = 1500000;

				if ( x>cnt && (x*2)>len ) {
					//게임서버에서 들어간 경험치와 클라이언트 경험치의 오차 범위 큼
					smTransCommand.WParam = 6630;
					smTransCommand.LParam = lpPlayInfo->smCharInfo.Level;
					smTransCommand.SParam = rnd;
					smTransCommand.EParam = len;
					RecordHackLogFile( lpPlayInfo , &smTransCommand );
					//lpPlayInfo->dwTime_Disconnect = 1;
				}
			}
			///////////////////////////////////////////////////////////////////////////
*/

			lpPlayInfo->TradePotionInfoCount = 0;	//물약 거래 정보 초기화
		
			if ( rsServerConfig.ExpFixMode && lpPlayInfo->RecordWarningCount>8 ) {
				//경고 3회 누적
				lpPlayInfo->dwTime_Disconnect = 1;
			}
/*
			cnt = abs( lpPlayInfo->smCharInfo.Exp-lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp );
			if ( lpPlayInfo->smCharInfo.Level>1 ) {
				if ( (lpPlayInfo->smCharInfo.Level>30 && cnt>=2000000 ) || (lpPlayInfo->smCharInfo.Level<=30 && cnt>=400000) ) {
					if ( lpPlayInfo->smCharInfo.Level>60 && cnt>=8000000)  {
						//과도한 경험치 획득 ( 레벨 30 이상 2백만  레빌 30이하 4십만 레벨 60이상 800만 )
						smTransCommand.WParam = 2110;
						smTransCommand.LParam = lpPlayInfo->smCharInfo.Level;
						smTransCommand.SParam = cnt;
						RecordHackLogFile( lpPlayInfo , &smTransCommand );
					}
				}
			}
			if ( lpPlayInfo->smCharInfo.Level==0 && !lpPlayInfo->AdminMode ) {
				if( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level>2 || lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp>=10000 ) {
					//초반 캐릭 조작 캐릭터 삭제후 로그남김

					//캐릭 삭제 (열심히 렙업해봐야 나중에 들어오면 캐릭이 없다는것을 느낄수 있게된다 )
					lpPlayInfo->lpRecordBase->DeleteCharData( lpPlayInfo->szID , lpPlayInfo->szName );	

					//로그 기록
					smTransCommand.WParam = 6000;
					smTransCommand.SParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level;
					smTransCommand.LParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp;
					RecordHackLogFile( lpPlayInfo , &smTransCommand );

					lpPlayInfo->dwTime_Disconnect = 1;

				}
			}
*/


/*
			len = dwPlayServTime-lpPlayInfo->dwLastSaveTime;
			cnt = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp-lpPlayInfo->smCharInfo.Exp;

			if ( lpPlayInfo->smCharInfo.Level>24 && len>0 ) {
				//짧은 시간동안 레벨20 이상 캐릭이 자기 경험치의 1/10 획득한 사람 로그에 기록
				x = GetNextExp( lpPlayInfo->smCharInfo.Level )-GetNextExp( lpPlayInfo->smCharInfo.Level-1 );
				if (  lpPlayInfo->smCharInfo.Level<40 )	x /= 7;
				else x/=10;

				if ( cnt>x && len<12*60*1000 ) {
					//로그 기록
					smTransCommand.WParam = 2120;
					smTransCommand.LParam = lpPlayInfo->smCharInfo.Level;
					smTransCommand.SParam = cnt;
					smTransCommand.EParam = len/(60*1000);
					RecordHackLogFile( lpPlayInfo , &smTransCommand );
				}
			}
*/
			lpPlayInfo->smCharInfo.Level = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level;
			lpPlayInfo->smCharInfo.Exp = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp;
			lpPlayInfo->smCharInfo.Exp_High = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp_High;
			lpPlayInfo->smCharInfo.Money = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Money;

			//흡수율 해킹한 유저는 경험치 백만 깍아서 저장
			//방어력 해킹한 유저 연결 강제 종료 시킴 // 크랙사용 적발 유저 강제 종료
			if ( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Defence>=4000 ||
				lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Absorption>=150 ||
				lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Attack_Damage[1]>=800 ||
				lpPlayInfo->CrackWarning ) {

				if ( lpPlayInfo->CrackWarning ) {
					//크랙 종료 기록
					smTransCommand.WParam = 2000;
					smTransCommand.SParam = 0;
					smTransCommand.LParam = lpPlayInfo->CrackWarning;
				}
				else {
					//파라메터 해킹 종료 기록
					smTransCommand.WParam = 100;
					smTransCommand.SParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Absorption;
					smTransCommand.LParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Attack_Damage[1];
					smTransCommand.EParam = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Defence;
				}

				RecordHackLogFile( lpPlayInfo , &smTransCommand );

/*
				//저장이 완료되면 클래스 삭제
				delete lpPlayInfo->lpRecordBase;

				lpPlayInfo->lpRecordBase = 0;
				lpPlayInfo->ThrowItemCount = 0;			//버린 아이템 정보 초기화
				lpPlayInfo->UnsaveMoney = -1;				//버린 돈 초기화

				DisconnectUser( lpPlayInfo->lpsmSock );		//강제 종료
				break;
*/
			}

			lpPlayInfo->smCharInfo.Exp = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp;
			lpPlayInfo->smCharInfo.Exp_High = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Exp_High;
			lpPlayInfo->smCharInfo.Level = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.Level;

			if ( lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.ClassClan )		//클랜 코드
				lpPlayInfo->smCharInfo.ClassClan = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.ClassClan;


			if ( lpPlayInfo->smCharInfo.ChangeJob!=lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.ChangeJob ) {
				//전업카운터 변경
				rsCheck_ChageJob( lpPlayInfo , lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.ChangeJob );
				lpPlayInfo->smCharInfo.ChangeJob = lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.ChangeJob;
			}

			//접속한 캐릭과 저장되는 캐릭의 이름이 다른 경우 ( 운영자 모드 거나 치트한 경우 )
			//if ( lpPlayInfo->AdminMode>1 && lstrcmpi( lpPlayInfo->szName , lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName )!=0 ) {
			if ( lpPlayInfo->AdminMode>1 ) {
				Server_DebugCount = 500;
				rsRecordMemoryBuffToFile( lpPlayInfo , lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->lpRecordDataBuff );
				Server_DebugCount = 501;
			}

			if ( abs(dwTime-lpPlayInfo->dwRecordDataTime)>30*60*1000 ) {
				//30분 마다 진짜로 저장
				Server_DebugCount = 600;
				if ( lpPlayInfo->lpRecordDataBuff && ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size>0 ) {
					if ( rsRecordMemoryBuffToFile( lpPlayInfo , lpPlayInfo->lpRecordBase->TransRecordData.smCharInfo.szName , lpPlayInfo->lpRecordDataBuff )==TRUE ) {
						if ( lstrcmpi( lpPlayInfo->szName , ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->smCharInfo.szName )!=0 ) {
							smTransCommand.WParam = 10003;
							smTransCommand.LParam = (DWORD)lpPlayInfo->szName;
							smTransCommand.SParam = (DWORD)((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->smCharInfo.szName;
							RecordHackLogFile( lpPlayInfo , &smTransCommand );
						}
						lpPlayInfo->dwRecordDataTime = dwTime;
					}
					else {
						//저장 오류
						smTransCommand.WParam = 8080;
						smTransCommand.LParam = 3;
						smTransCommand.SParam = lpPlayInfo->dwRecordDataTime/1000;
						smTransCommand.EParam = dwTime/1000;
						RecordHackLogFile( lpPlayInfo , &smTransCommand );
					}

				}
				Server_DebugCount = 601;
			}

			if ( lpPlayInfo->lpRecordDataBuff && ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size>0 ) {
				if ( lstrcmpi( lpPlayInfo->szName , ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->smCharInfo.szName )!=0 ) {
					smTransCommand.WParam = 10005;
					smTransCommand.LParam = (DWORD)lpPlayInfo->szName;
					smTransCommand.SParam = (DWORD)((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->smCharInfo.szName;
					RecordHackLogFile( lpPlayInfo , &smTransCommand );
				}
			}

			//레벨과 경험치가 맞는지 확인
			if ( !lpPlayInfo->RecordWarningExp && CheckLevelExp( lpPlayInfo->smCharInfo.Level , GetExp64( &lpPlayInfo->smCharInfo ) )==FALSE ) {
				//경험치 대 레벨 오류 감지
				smTransCommand.WParam = 6200;
				smTransCommand.LParam = (DWORD)lpPlayInfo->smCharInfo.Level;
				smTransCommand.SParam = (DWORD)lpPlayInfo->smCharInfo.Exp;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				if ( lpPlayInfo->smCharInfo.Level>20 ) 
					lpPlayInfo->dwTime_Disconnect = 1;
			}

			//저장이 완료되면 클래스 삭제
			delete lpPlayInfo->lpRecordBase;

			lpPlayInfo->lpRecordBase = 0;
			lpPlayInfo->ThrowItemCount = 0;			//버린 아이템 정보 초기화
			lpPlayInfo->UnsaveMoney = -1;				//버린 돈 초기화

			//저장 성공 알려줌
			smTransCommand.code = smTRANSCODE_RECORDRESULT;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = TRUE;
			smTransCommand.LParam = 0;
			smTransCommand.SParam = rsBlessCastle.Tax;
			smTransCommand.EParam = (int)rsBlessCastle.dwMasterClan;
			lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );


			lpPlayInfo->dwLastSaveTime = dwPlayServTime;		//저장 시간 기록

			if ( lpPlayInfo->dwTime_Disconnect && lpPlayInfo->dwTime_Disconnect<dwTime && !lpPlayInfo->AdminMode ) {
				//rsServerConfig.ClientCodeCheckOut && !lpPlayInfo->AdminMode ) {
				//안전 코드 오류 / 연결 종료

				DisconnectUser( lpPlayInfo->lpsmSock );
			}

			if ( rsServerConfig.Event_StarPointTicket ) 
				OpenStarPointTicket( lpPlayInfo );		//별 포인트 이벤트 티켓 발생 레벨

			rsSendBlessCastleClanSkill( lpPlayInfo );	//블레스 캐슬 클랜스킬 확인 적용

			if ( lpPlayInfo->dwStartUser_PresentItem_Count )
				lpPlayInfo->dwStartUser_PresentItem_Time = dwPlayServTime+1000*10;		//10초후 아이템 기본 아이템 주기

		}
		break;



	case smTRANSCODE_GETRECORDDATA:
		//저장된 데이타를 불러옴
		//lpsmSock
		lpTransCharCommand = (smTRANS_CHAR_COMMAND *)SockInfo->Buff;

		if ( !lpPlayInfo->szID[0] ) break;
		if ( !lpPlayInfo->AdminMode && lpPlayInfo->dwTime_Disconnect ) break;
		if ( rsServerConfig.LimitVersionMax && lpTransCharCommand->SParam>rsServerConfig.LimitVersionMax ) break;//최상위 버전 검사

		if ( !lpPlayInfo->szName[0] )
			lpPlayInfo->dwClientFunChk_NextTime = dwPlayServTime+60*1000;			//1분후 부터 검사 설정

		lpRecordBase = new rsRECORD_DBASE;

		if ( lpPlayInfo->AdminMode<3 ) {
			lpTransCharCommand->LParam = FALSE;
		}
		ang = 0;

		lpPlayInfo->Client_Version = lpTransCharCommand->SParam;			//클라이언트 버전 기록

		if ( rsServerConfig.ClientCheckSumCount>0 && !lpPlayInfo->AdminMode ) {
			for( cnt=0;cnt<rsServerConfig.ClientCheckSumCount;cnt++ ) {
				if ( lpTransCharCommand->WParam==(int)rsServerConfig.dwClientCheckSum[cnt] ) {
					break;
				}
			}
			if ( cnt>=rsServerConfig.ClientCheckSumCount ) {
				//일치하는 체크섬 없음

				//클라이언트 첵크섬 오류
				smTransCommand.WParam = 1102;
				smTransCommand.SParam = lpTransCharCommand->WParam;
				smTransCommand.LParam = lpTransCharCommand->WParam;
				//RecordHackLogFile( lpPlayInfo , &smTransCommand );

				//DisconnectUser( lpsmSock );		//연결 종료
				//break;
			}
		}


		if ( lpPlayInfo->szName[0] && lpPlayInfo->AdminMode ) {
			//운영자 캐릭터 로딩 설정
			cnt=0;
			while(1) {
				if ( szAdminSucess[cnt]==0 ) break;
				if ( lstrcmp( szAdminMessage[cnt] , lpTransCharCommand->szName )==0 ) {
					lpPlayInfo->AdminMode = 2+cnt;
					SendQuickMessage( lpPlayInfo , szAdminSucess[cnt] ); 
					break;
				}
				cnt++;
			}

			wsprintf( TransChatMessage.szMessage , "LOAD [%d] ( %s )" , lpTransCharCommand->LParam , lpTransCharCommand->szName );
			rsRecordAdminCommand( lpPlayInfo , TransChatMessage.szMessage , 2 );		//관리자 명령 기록
		}

		//캐릭터를 여러번 로딩을 시도하는 경우 로그로 남긴다 ( 한게임 돈복사 조사중 )
		if ( lpPlayInfo->CharLoadingCount>0 && lpPlayInfo->AdminMode<3 ) {
			smTransCommand.WParam = 8890;
			smTransCommand.LParam = (DWORD)lpPlayInfo->szName;
			smTransCommand.SParam = (DWORD)lpTransCharCommand->szName;
			smTransCommand.EParam = lpPlayInfo->AdminMode;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );

			if ( lpRecordBase ) {
				delete lpRecordBase;
				lpRecordBase = 0;
			}
			break;
		}


		lpPlayInfo->CharLoadingCount++;

		if ( lpPlayInfo->AdminMode<3 ) {
			//아이디 이중 접속 재확인
			for( cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] && lpPlayInfo!=&rsPlayInfo[cnt] 
					&& rsPlayInfo[cnt].AdminMode<=1 ) {
					//동일 아이디가 확인됨
					if ( lpPlayInfo->dwCode_ID==rsPlayInfo[cnt].dwCode_ID &&
						lstrcmpi( lpPlayInfo->szID , rsPlayInfo[cnt].szID )==0 ) {
						DisconnectUser( lpsmSock );
						DisconnectUser( rsPlayInfo[cnt].lpsmSock );
						break;
					}
					//동일 캐릭터 접속 확인
					if ( lstrcmpi( lpTransCharCommand->szName , rsPlayInfo[cnt].szName )==0 ) {
						DisconnectUser( lpsmSock );
						DisconnectUser( rsPlayInfo[cnt].lpsmSock );
						break;
					}
				}
			}
		}
		else {
			//운영자 캐릭터 로딩
			cnt = CONNECTMAX;
			if ( lpPlayInfo->szName[0] ) {
				ang = TRUE;
				lpPlayInfo->AdminOperMode = TRUE;
			}
		}

		if ( !lpPlayInfo->lpsmSock ) {
			if ( lpRecordBase ) {
				delete lpRecordBase;
				lpRecordBase = 0;
			}			
			break;
		}


		lpPlayInfo->dwLastSaveTime = dwPlayServTime;			//저장된 시간으로 설정

		//해당 ID에 해당 캐릭터이 존재하는지 확인
		if ( lpPlayInfo->AdminMode<3 && rsCheckAccountChar( lpPlayInfo->szID , lpTransCharCommand->szName )==FALSE ) {
			//잘못된 캐릭임
			//DisconnectUser( lpsmSock );
			//delete lpRecordBase;

			//저장 첵크섬 오류
			smTransCommand.WParam = 2800;
			smTransCommand.LParam = (int)lpTransCharCommand->szName;
			smTransCommand.SParam = lpPlayInfo->CharLoadingCount;
			smTransCommand.EParam = lpPlayInfo->dwObjectSerial;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			lpPlayInfo->szName[0] = 0;
			cnt = 0;
			if ( lpRecordBase ) {
				delete lpRecordBase;
				lpRecordBase = 0;
			}
			DisconnectUser( lpsmSock );
			//lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+5000;
			break;
		}

		if ( rsNSpriteMode ) {
			if ( lpPlayInfo->dwNSpriteTime==0 )
				lpPlayInfo->dwNSpriteTime = dwTime+1*60000;		//검사 유효 시간 ( 2분간 유효 )
		}

		if ( cnt>=CONNECTMAX ) {//&& ( lpPlayInfo->AdminMode>=4 || !lpPlayInfo->szName[0] ) ) {
			if ( lpRecordBase->SendRecordDataToClient( lpPlayInfo , lpTransCharCommand->szName , lpsmSock , lpTransCharCommand->LParam )==FALSE ) {
				Server_DebugCount = 1001;
				//데이타 없음 실패
				lpTransCharCommand->code = smTRANSCODE_FAILRECORDDATA;
				if ( !lpPlayInfo->dwObjectSerial ) lpPlayInfo->dwObjectSerial = GetNewObjectSerial();
				lpTransCharCommand->WParam = lpPlayInfo->dwObjectSerial;

				lpPlayInfo->smCharInfo.dwObjectSerial = lpPlayInfo->dwObjectSerial;
				lpTransCharCommand->LParam = rsGetLoginSafeKey( &lpPlayInfo->smCharInfo , GetSpeedSum( lpPlayInfo->szName ) );	//로그인서버 보안키

				//서버 고유번호 설rfv4정 ( 군서버에서 하도록 변경 )
				lpsmSock->Send2( (char *)lpTransCharCommand , lpTransCharCommand->size , TRUE );

				((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size = 0;
				((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->code = 0;

				lpPlayInfo->spLevel_Start = 1;

				//암호 모듈 시행
				//rsProcessSafePacket( lpPlayInfo );
/*
				if ( !lpPlayInfo->AdminMode ) {
					lpPlayInfo->smCharInfo.Level = 1;				//레벨 저장
					lpPlayInfo->smCharInfo.Exp = 0;					//경험치 저장
					lpPlayInfo->smCharInfo.Money = 0;				//돈저장
					lpPlayInfo->spExp_Start = 0;					//시작시 경험치
					lpPlayInfo->spMoney_Start = 0;
				}

*/
				ZeroMemory( lpPlayInfo->bSkillPoint , SKILL_POINT_COLUM_MAX );	//스킬 포인트 버퍼 초기화

				if ( rsServerConfig.Event_StarPointTicket ) {
					//별 포인트 이벤트 티켓 발생 설정 ( 신규캐릭 )
					OpenStarPointEvent( lpPlayInfo , 0 );
				}

				lpPlayInfo->smCharInfo.ChangeJob = 0;		//전업카운터
				SendSaveClientData( lpPlayInfo );			//클라이언트에 데이타 저장 요구
			}
			else {
/*
				if ( !lpPlayInfo->szName[0] ) {
					//정량제 시간세팅
					if ( lpPlayInfo->GpCode==BILLING_GPTYPE_TIME ) {
						lpPlayInfo->dwPeriodTime = dwPlayServTime+lpPlayInfo->UsePeriod*1000;
						if ( lpPlayInfo->dwPeriodTime<dwPlayServTime ) {
							lpPlayInfo->dwPeriodTime = 0;
						}
					}
				}
*/

				//임시 첵크용 (나중에 다른 로그로 변경)
				if ( !rsServerConfig.Event_Child && lpPlayInfo->AdminMode==0 ) {
					if ( lpPlayInfo->szName[0] ) {
						smTransCommand.WParam = 10010;
						smTransCommand.LParam = (DWORD)lpPlayInfo->szName;
						smTransCommand.SParam = (DWORD)lpTransCharCommand->szName;
						RecordHackLogFile( lpPlayInfo , &smTransCommand );
					}
				}

				Server_DebugCount = 1000;

				lstrcpy( lpPlayInfo->szName , lpTransCharCommand->szName );
				lpPlayInfo->dwCode_Name = GetSpeedSum( lpPlayInfo->szName );		//고속 체크섬

				if ( lpRecordBase->TransRecordData.ThrowItemCount>0 ) {
					if ( lpRecordBase->TransRecordData.ThrowItemCount>THROW_ITEM_INFO_MAX ) 
						lpRecordBase->TransRecordData.ThrowItemCount = THROW_ITEM_INFO_MAX;

					lpPlayInfo->ThrowItemCount = lpRecordBase->TransRecordData.ThrowItemCount;
					memcpy( lpPlayInfo->ThrowItemInfo , lpRecordBase->TransRecordData.ThrowItemInfo , sizeof(sTHROW_ITEM_INFO)*lpPlayInfo->ThrowItemCount );
				}
				if ( lpRecordBase->TransRecordData.GameSaveInfo.LastMoeny>0 ) {
					lpPlayInfo->UnsaveMoney = lpRecordBase->TransRecordData.GameSaveInfo.LastMoeny-1;
				}

				Server_DebugCount = 1010;

				if ( lpPlayInfo->smCharInfo.szName[0] ) {
					//캐릭터 정보 게임 진행 서버에 복사
					memcpy( &lpPlayInfo->smCharInfo , &lpRecordBase->TransRecordData.smCharInfo , sizeof( smCHAR_INFO ) );
				}

				//스킬 포인트 버퍼에 저장
				memcpy( lpPlayInfo->bSkillPoint , lpRecordBase->TransRecordData.GameSaveInfo.SkillInfo.bSkillPoint , SKILL_POINT_COLUM_MAX );

//				ZeroMemory( lpPlayInfo->bSkillPoint , sizeof(BYTE)*SKILL_POINT_COLUM_MAX );	//스킬 포인트 버퍼 초기화


				//레벨 저장
				lpPlayInfo->smCharInfo.Level = lpRecordBase->TransRecordData.smCharInfo.Level;
				lpPlayInfo->spLevel_Start = lpPlayInfo->smCharInfo.Level;

				//경험치 저장
				lpPlayInfo->smCharInfo.Exp = lpRecordBase->TransRecordData.smCharInfo.Exp;
				lpPlayInfo->smCharInfo.Exp_High = lpRecordBase->TransRecordData.smCharInfo.Exp_High;
				//이름 저장
				lstrcpy( lpPlayInfo->smCharInfo.szName , lpRecordBase->TransRecordData.smCharInfo.szName );
				//직업코드 저장
				lpPlayInfo->smCharInfo.JOB_CODE = lpRecordBase->TransRecordData.smCharInfo.JOB_CODE;
				//돈저장
				lpPlayInfo->smCharInfo.Money = lpRecordBase->TransRecordData.smCharInfo.Money;

				//초기 설정 백업
				lpPlayInfo->spExp_Start = GetExp64( &lpRecordBase->TransRecordData.smCharInfo );			//시작시 경험치


				if ( lpRecordBase->TransRecordData.GameSaveInfo.LastMoeny>0 ) 
					lpPlayInfo->spMoney_Start = lpRecordBase->TransRecordData.GameSaveInfo.LastMoeny-1;
				else
					lpPlayInfo->spMoney_Start = lpRecordBase->TransRecordData.smCharInfo.Money;;			//시작시 돈

				lpPlayInfo->SetServerMoney ( lpPlayInfo->spMoney_Start , WHERE_LOAD_PLAYER );				//실제 돈
				lpPlayInfo->smCharInfo.ClassClan = lpRecordBase->TransRecordData.smCharInfo.ClassClan;	//클랜


				//DB LOG 기록
				RecordLogSql( LOG_SQL_LOGIN , lpPlayInfo->lpsmSock->szIPAddr , lpPlayInfo->szID , lpPlayInfo->szName , lpPlayInfo->szGPCode , 1,
					lpRecordBase->TransRecordData.smCharInfo.JOB_CODE,
					GetExp64( &lpRecordBase->TransRecordData.smCharInfo ),
					lpRecordBase->TransRecordData.smCharInfo.Level,
					lpRecordBase->TransRecordData.smCharInfo.Money );

				//::CoCreateGuid(&lpPlayInfo->Guid);			//식별자 선정

				//Game LOG 기록
				RecordGameLogSql( GAMELOG_SQL_LOGIN , lpPlayInfo->lpsmSock->szIPAddr , lpPlayInfo->szID , lpPlayInfo->szName, lpPlayInfo->szGPCode ,
						lpRecordBase->TransRecordData.smCharInfo.JOB_CODE,  lpPlayInfo->szGuid , 0 );



/*
					//DB LOG 기록
					RecordLogSql( LOG_SQL_LOGIN , LogAccount->lpPlayInfo->lpsmSock->szIPAddr , LogAccount->szID , 
						"" , 1 , 0, 0 , 0 , 0 );

					::CoCreateGuid(&LogAccount->lpPlayInfo->Guid);			//식별자 선정
					RecordGameLogSql( GAMELOG_SQL_LOGIN , LogAccount->lpPlayInfo->lpsmSock->szIPAddr , LogAccount->szID ,
						"", 0,  LogAccount->lpPlayInfo->Guid );
*/

				Server_DebugCount = 1020;

				if ( lpRecordBase->TransRecordData.GameSaveInfo.szMasterID[0] ) {
					if ( lstrcmpi(lpRecordBase->TransRecordData.GameSaveInfo.szMasterID , lpPlayInfo->szID )!=0 ) {
						//마지막 저장시의 아이디랑 현재 아이디가 틀린 경우
						smTransCommand.WParam = 10010;
						smTransCommand.LParam = (DWORD)lpRecordBase->TransRecordData.GameSaveInfo.szMasterID;
						smTransCommand.SParam = (DWORD)lpRecordBase->TransRecordData.GameSaveInfo.szMasterID;
						RecordHackLogFile( lpPlayInfo , &smTransCommand );
					}
				}

				Server_DebugCount = 1060;

				if ( lpPlayInfo->lpRecordDataBuff && !ang ) {
					//불러온 아이템 목록을 유저정보에 저장
					lpRecordBase->MakeRecordItemList( lpPlayInfo );
					if ( lpRecordBase->TransRecordData.size<=srRECORD_MEMORY_SIZE )
						memcpy( lpPlayInfo->lpRecordDataBuff , &lpRecordBase->TransRecordData , lpRecordBase->TransRecordData.size );

					//물약 보유량 비교
					rsCompareServerPotion( lpPlayInfo , &lpRecordBase->TransRecordData.GameSaveInfo );

					//포스오브 사용 설정
					rsLoadServerForce( lpPlayInfo , &lpRecordBase->TransRecordData.GameSaveInfo );
				}

				Server_DebugCount = 1030;

				if ( lpRecordBase->TransRecordData.smCharInfo.Level>CHAR_LEVEL_MAX ) {
					//레벨이 100보다 큰 경우
					smTransCommand.WParam = 6100;
					smTransCommand.LParam = lpRecordBase->TransRecordData.smCharInfo.Level;
					smTransCommand.SParam = lpRecordBase->TransRecordData.smCharInfo.Exp;
					RecordHackLogFile( lpPlayInfo , &smTransCommand );
					delete lpRecordBase;
					DisconnectUser( lpsmSock );
					break;
				}

				Server_DebugCount = 1040;

				//레벨과 경험치가 맞는지 확인
				if ( CheckLevelExp( lpRecordBase->TransRecordData.smCharInfo.Level , GetExp64( &lpRecordBase->TransRecordData.smCharInfo ) )==FALSE ) {
					//경험치 대 레벨 오류 감지
					smTransCommand.WParam = 6200;
					smTransCommand.LParam = (DWORD)lpRecordBase->TransRecordData.smCharInfo.Level;
					smTransCommand.SParam = (DWORD)lpRecordBase->TransRecordData.smCharInfo.Exp;
					RecordHackLogFile( lpPlayInfo , &smTransCommand );
					delete lpRecordBase;
					DisconnectUser( lpsmSock );
					break;
				}

				Server_DebugCount = 1050;

				//모델이 맞는지 확인
				if ( !lpPlayInfo->AdminMode && CheckUserModel( &lpRecordBase->TransRecordData.smCharInfo )==FALSE ) {
					//모델 오류
					smTransCommand.WParam = 7020;
					smTransCommand.LParam = lpRecordBase->TransRecordData.smCharInfo.JOB_CODE;
					smTransCommand.SParam = (DWORD)lpRecordBase->TransRecordData.smCharInfo.szModelName;
					smTransCommand.EParam = (DWORD)lpRecordBase->TransRecordData.smCharInfo.szModelName2;
					RecordHackLogFile( lpPlayInfo , &smTransCommand );
					delete lpRecordBase;
					DisconnectUser( lpsmSock );
					break;
				}

				lpPlayInfo->smCharInfo.ChangeJob = lpRecordBase->TransRecordData.smCharInfo.ChangeJob;

				if ( rsServerConfig.Record_JobChanger && lpRecordBase->TransRecordData.smCharInfo.ChangeJob>0 ) {
					//전업자 기록 파일로 남김
					RecordJobChanger( lpPlayInfo );
				}

				Server_DebugCount = 1070;

				//서버 고유번호 설정 ( 군서버에서 하도록 변경 )
				if ( !lpPlayInfo->dwObjectSerial ) 
					lpPlayInfo->dwObjectSerial = lpRecordBase->TransRecordData.smCharInfo.dwObjectSerial;

			}
		}
		delete lpRecordBase;

		if ( lpPlayInfo->lpRecordDataBuff && ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size>0 ) {
			if ( lstrcmpi( lpPlayInfo->szName , ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->smCharInfo.szName )!=0 ) {
				smTransCommand.WParam = 10006;
				smTransCommand.LParam = (DWORD)lpPlayInfo->szName;
				smTransCommand.SParam = (DWORD)((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->smCharInfo.szName;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
			}
		}

		bClan_UserTicket( lpPlayInfo , 0 );			//발급된 티켓으로 클랜 설정


		Server_DebugCount = 1080;

		//데미지 암호화 펑션을 통채로 클라이언트에 보낸다
		rsSendDamageFuncToClient( lpPlayInfo );
/*
		if ( rsServerConfig.FreeLevel && (lpPlayInfo->Bl_Meter&BIMASK_FREE_USER)!=0 ) {
			//무료 레벨 사용자
			if ( lpPlayInfo->smCharInfo.Level<rsServerConfig.FreeLevel ) {
				//무료 레벨
				//lpPlayInfo->Bl_Meter -= BIMASK_FREE_USER;
				//lpPlayInfo->Bl_Meter |= BIMASK_PRORATE_USER;
				lpPlayInfo->DisuseDay = tServerTime+(60*60*24*3);		//3일 추가
				lpPlayInfo->UsePeriod = 0;
				lpPlayInfo->dwPeriodTime = 0;
			}
			else {
				//무료 레벨 초과
				bSql_EventLogon( lpPlayInfo );			//과금 검사
			}
		}
		else {
			if ( rsServerConfig.DispBillingTime ) {
				//빌링 남은 시간 표시
				if ( lpPlayInfo->Bl_RNo>0 )
					bSql_PCRNoReservProduct( lpPlayInfo );
				else
					srDisplayBillingTime( lpPlayInfo , 0 );
			}
		}
*/
		if ( rsServerConfig.FreeLevel ) {
			if ( lpPlayInfo->smCharInfo.Level>=rsServerConfig.FreeLevel ) {
				if ( (lpPlayInfo->Bl_Meter&BIMASK_FREE_USER)!=0 ) {
					//비 결제자
					lpPlayInfo->Bl_Meter -= BIMASK_FREE_USER;
				}
				if ( lpPlayInfo->Bl_RNo>0 )
					bSql_PCRNoReservProduct( lpPlayInfo );
				else
					srDisplayBillingTime( lpPlayInfo , 0 );

				if ( (lpPlayInfo->Bl_Meter&BIMASK_TIMELEVEL_USER)!=0 ) {
					lpPlayInfo->dwPeriodTime2 = 0;
				}
			}
			else {
				//레벨 이하
				if ( (lpPlayInfo->Bl_Meter&BIMASK_TIMELEVEL_USER)!=0 ) {
					//시간제 무료
					lstrcpy( lpPlayInfo->szGPCode , rsServerConfig.szFreeGpCode );

					lpPlayInfo->dwPeriodTime = 0;//lpPlayInfo->dwPeriodTime2;
					lpPlayInfo->UsePeriod = 0;
					lpPlayInfo->DisuseDay = lpPlayInfo->dwPeriodTime2;
					lpPlayInfo->dwPeriodTime2 = 0;

					srDisplayBillingTime( lpPlayInfo , 0 );
				}
				else {
					if ( (lpPlayInfo->Bl_Meter&(BIMASK_TIMELEVEL_USER+BIMASK_FREE_USER))==0 && rsServerConfig.szFreeGpCode[0] ) {
						if ( lpPlayInfo->Bl_RNo>0 )
							bSql_PCRNoReservProduct( lpPlayInfo );
						else
							srDisplayBillingTime( lpPlayInfo , 0 );
					}
					else {

						if ( (lpPlayInfo->Bl_Meter&BIMASK_FREE_USER)!=0 ) {
							bSql_EventLogOut( lpPlayInfo );						//과금 중단 시키기

							lpPlayInfo->Bl_Meter |= BIMASK_FREE_USER;				//무료 이용자 설정
							lpPlayInfo->DisuseDay = tServerTime+(60*60*24*3);		//3일 추가
							lpPlayInfo->UsePeriod = 0;
							lpPlayInfo->dwPeriodTime = 0;
						}
						else
							srDisplayBillingTime( lpPlayInfo , 0 );

/*
						if ( (lpPlayInfo->Bl_Meter&BIMASK_FREE_USER)==0 ) {
							bSql_EventLogOut( lpPlayInfo );						//과금 중단 시키기
						}

						lpPlayInfo->Bl_Meter |= BIMASK_FREE_USER;				//무료 이용자 설정
						lpPlayInfo->DisuseDay = tServerTime+(60*60*24*3);		//3일 추가
						lpPlayInfo->UsePeriod = 0;
						lpPlayInfo->dwPeriodTime = 0;
						srDisplayBillingTime( lpPlayInfo , 0 );
*/
					}
				}
			}
		}
		else {
			if ( lpPlayInfo->Bl_RNo>0 )
				bSql_PCRNoReservProduct( lpPlayInfo );
			else
				srDisplayBillingTime( lpPlayInfo , 0 );
		}


		if ( lpPlayInfo->Client_Version ) {
			if ( rsGetClientPos(lpPlayInfo->Client_Version)==0 ) {
				//초기 데이타가 없음 / 클라이언트 펑션포지션 요구
				smTransCommand.code = smTRANSCODE_GETCLIENT_FUNCPOS;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = lpPlayInfo->Client_Version;
				smTransCommand.LParam = 0;
				smTransCommand.SParam = 0;
				lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
			}
		}

		//크랙 검색 요구
		SendFindCrack( lpsmSock );

		//nProtect 메모리에서 제거 
		if ( rsServerConfig.RemoveNProtectTime ) {
			smTransCommand.code = smTRANSCODE_NPROTECT;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = 100;
			smTransCommand.LParam = 0;
			smTransCommand.SParam = 0;
			smTransCommand.EParam = 0;
			lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
		}

//#ifdef _LANGUAGE_VEITNAM
		//계정정보 메인서버로 보내기 (베트남)
		if ( rsServerConfig.ExpGameTimeMode )
			rsSendUserID_MainServer( lpPlayInfo );
//#endif

		//암호 모듈 시행
		rsProcessSafePacket( lpPlayInfo );

#ifdef _xTrap_GUARD_SERVER
		rsXTrap_Login(lpPlayInfo);
#endif

		Server_DebugCount = 0;
		break;


	case smTRANSCODE_ID_GETUSERINFO:
		//ID로 사용자 캐릭터 리스트 및 정보를 구함
		lpTransCharCommand2 = ( smTRANS_CHAR_COMMAND2 * )SockInfo->Buff;
/*
		if ( DebugServerMode ) {
			if ( !lpPlayInfo->AdminIP ) {
				if ( !rsServerConfig.szAdminIP[0] || strstr( lpsmSock->szIPAddr , rsServerConfig.szAdminIP )==0 ) {
					//실패
					smTransCommand.code = smTRANSCODE_FAILCONNECT;
					smTransCommand.size = sizeof( smTRANS_COMMAND );
					smTransCommand.WParam = (DWORD)(-4);
					smTransCommand.LParam = 0;
					lpsmSock->Send( (char *)&smTransCommand , smTransCommand.size , TRUE );
					break;
				}
			}
		}
*/
		lstrcpy( lpPlayInfo->szID , lpTransCharCommand2->szId );
		lpPlayInfo->dwCode_ID  = GetSpeedSum(lpPlayInfo->szID);			//코드 작성


		if ( rsServerConfig.Disable_LogIn2 ) {
			//로그인 차단
			smTransCommand.code = smTRANSCODE_FAILCONNECT;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = (DWORD)0;
			smTransCommand.LParam = 0;
			smTransCommand.EParam = 1;
			lpsmSock->Send( (char *)&smTransCommand , smTransCommand.size , TRUE );
			break;
		}

		//DB ACCOUNT 인증
		if ( Server_SqlReady && rsLogAccount( lpPlayInfo , lpTransCharCommand2->szId , lpTransCharCommand2->szName )==FALSE ) {
			//실패
			smTransCommand.code = smTRANSCODE_FAILCONNECT;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = (DWORD)0;
			smTransCommand.LParam = 0;
			smTransCommand.EParam = 1;
			lpsmSock->Send( (char *)&smTransCommand , smTransCommand.size , TRUE );
			srLogFailedCount++;
		}

		//서버 선택 리스트를 보내준다
		//rsSendServerList( lpsmSock );


		/*
		if ( cbCnt==TRUE ) {
			for( cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] ) {
					//동일 아이디가 확인됨
					if ( lstrcmp( lpTransCharCommand2->szId , rsPlayInfo[cnt].szID )==0 ) {
						DisconnectUser( rsPlayInfo[cnt].lpsmSock );
					}
				}
			}
		}

		if ( cbCnt==TRUE ) {
			//인증 성공
			lstrcpy( rsPlayInfo->szID , lpTransCharCommand2->szId );
			lpRecordBase = new rsRECORD_DBASE;
			lpRecordBase->SendUserDataToClient( lpTransCharCommand2->szId , lpsmSock );
			delete lpRecordBase;
		}
		else {
			//실패
			smTransCommand.code = smTRANSCODE_FAILCONNECT;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = (DWORD)cbCnt;
			smTransCommand.LParam = 0;
			lpsmSock->Send( (char *)&smTransCommand , smTransCommand.size , TRUE );
		}
		*/
		break;

	case smTRANSCODE_INSRECORDDATA:
		//ID에 새로운 캐릭터 삽입
		lpRecordBase = new rsRECORD_DBASE;

		lpTransCharCommand2 = ( smTRANS_CHAR_COMMAND2 * )SockInfo->Buff;

		lpTransCharCommand2->WParam = FALSE;

		if ( lpPlayInfo->AdminMode || strstr( lpTransCharCommand2->szName, "운영자" )==0 ) {
			lpPlayInfo2 = FindUserFromName2( lpTransCharCommand2->szName );		//접속자 같은 이름 있는지 확인
			if ( !lpPlayInfo2 && !lpPlayInfo->szServerID[0] )
				lpTransCharCommand2->WParam = lpRecordBase->InsertCharData( lpPlayInfo->szID , lpTransCharCommand2->szName );
				//lpTransCharCommand2->WParam = lpRecordBase->InsertCharData( lpTransCharCommand2->szId , lpTransCharCommand2->szName );
		}

		lpsmSock->Send2( (char *)lpTransCharCommand2 , lpTransCharCommand2->size , TRUE );

		if ( lpTransCharCommand2->WParam==TRUE ) {							//접속자이름에 등록
			lstrcpy( lpPlayInfo->szName , lpTransCharCommand2->szName );
			lpPlayInfo->dwCode_Name = GetSpeedSum( lpPlayInfo->szName );		//고속 체크섬
			RecordLogSql( LOG_SQL_NEWCHAR , lpPlayInfo->lpsmSock->szIPAddr , lpPlayInfo->szID , lpPlayInfo->szName ,lpPlayInfo->szGPCode ,0,0,0,0,0 );		//DB LOG 기록

			if ( rsServerConfig.StartUser_PresentItem )
				lpPlayInfo->dwStartUser_PresentItem_Count = 1;	//시작유저 아이템 선물
		}

		delete lpRecordBase;
		break;

	case smTRANSCODE_DELRECORDDATA:
		//ID에 새로운 캐릭터 삭제

		lpTransCharCommand2 = ( smTRANS_CHAR_COMMAND2 * )SockInfo->Buff;
		if ( lstrcmpi( lpPlayInfo->szID , lpTransCharCommand2->szId )!=0 ) break;
		if ( lpPlayInfo->szServerID[0] ) break;

		lpRecordBase = new rsRECORD_DBASE;

		lpRecordBase->DeleteCharData( lpPlayInfo->szID , lpTransCharCommand2->szName );
		//lpRecordBase->DeleteCharData( lpTransCharCommand2->szId , lpTransCharCommand2->szName );

		//캐릭터 제거 기록 파일로 남김
		RecordDeleteCharacter( lpPlayInfo->szID , lpPlayInfo->lpsmSock->szIPAddr, &lpRecordBase->TransRecordData.smCharInfo );
		//RecordDeleteCharacter( lpTransCharCommand2->szId , lpPlayInfo->lpsmSock->szIPAddr, &lpRecordBase->TransRecordData.smCharInfo );

		//DB LOG 기록
		RecordLogSql( LOG_SQL_DELCHAR , lpPlayInfo->lpsmSock->szIPAddr , lpPlayInfo->szID , lpTransCharCommand2->szName , lpPlayInfo->szGPCode ,1,
			lpRecordBase->TransRecordData.smCharInfo.JOB_CODE ,
			GetExp64( &lpRecordBase->TransRecordData.smCharInfo ),
			lpRecordBase->TransRecordData.smCharInfo.Level , 
			lpRecordBase->TransRecordData.smCharInfo.Money );


		delete lpRecordBase;
		break;

	case smTRANSCODE_ISRECORDDATA:
		//캐릭터가 존재 하는지 확인 ( WParam에 결과값 저장하여 되돌려 보냄 )
		lpRecordBase = new rsRECORD_DBASE;

		lpTransCharCommand2 = ( smTRANS_CHAR_COMMAND2 * )SockInfo->Buff;
		lpTransCharCommand2->WParam = lpRecordBase->IsData( lpTransCharCommand2->szName );
		lpsmSock->Send( (char *)lpTransCharCommand2 , lpTransCharCommand2->size , TRUE );

		delete lpRecordBase;
		break;


	case smTRANSCODE_THROWITEM:
		//아이템 버림
		lpTransItemInfo = (TRANS_ITEMINFO *)SockInfo->Buff;

		cnt = 0;

		//아이템 정보송수신 구조체에 보안코드 해독 비교 ( 컴파일시 서버에서만 존재 )
		if ( rsCheck_ItemSecCode( lpPlayInfo , 
			lpTransItemInfo->Item.CODE ,
			lpTransItemInfo->Item.ItemHeader.Head ,
			lpTransItemInfo->Item.ItemHeader.dwChkSum ,
			lpTransItemInfo->Item.Money ,
			lpTransItemInfo->dwSeCode[0],lpTransItemInfo->dwSeCode[1],
			lpTransItemInfo->dwSeCode[2],lpTransItemInfo->dwSeCode[3], &cnt )==NULL ) {


				//받은 아이템 정보에 문제가 생김
				break;

		}

		if ( cnt && cnt!=lpTransItemInfo->Item.PotionCount ) {
			//물약 갯수가 서버에보낸 설정과 틀리다
			if ( cnt<lpTransItemInfo->Item.PotionCount ) {
				if ( cnt<0 ) cnt = 1;
				lpTransItemInfo->Item.PotionCount = cnt;
			}
		}

		if ( lpTransItemInfo->Item.CODE==(sinGF1|sin01) ) {			//상품권 땅에 떨어지지 않도록 ( 제거 )


			break;
		}
		
		if ( (lpTransItemInfo->Item.CODE&sinITEM_MASK2)==sinGP1 && lpTransItemInfo->Item.PotionCount==100 ) {
			if ( CheckItemForm( &lpTransItemInfo->Item )==TRUE ) {
				//몬스터 크리스탈로 몬스터 출현 시킴

				cnt = OpenMonsterFromCristal( lpTransItemInfo->Item.CODE , lpPlayInfo->Position.x , lpPlayInfo->Position.y , lpPlayInfo->Position.z , lpPlayInfo );
				if ( cnt==TRUE ) break;
				if ( cnt==-1 ) {
					//돌려준다
					//아이템 특정 유저의 인벤토리보냄
					lpTransItemInfo->Item.PotionCount=0;
					rsPutItem2( lpPlayInfo , &lpTransItemInfo->Item );
					break;
				}
				lpTransItemInfo->Item.PotionCount=0;
			}
		}

		//사랑의 초코렛 사탕 사용
		if ( (lpTransItemInfo->Item.CODE&sinITEM_MASK2)==sinCH1 && lpTransItemInfo->Item.PotionCount==100 ) {
			if ( CheckItemForm( &lpTransItemInfo->Item )==TRUE ) {
				//사랑의 아이템을 사용
				if ( rsUseLovelyItem( lpPlayInfo , lpTransItemInfo->Item.CODE )==TRUE ) break;
				lpTransItemInfo->Item.PotionCount=0;
			}
		}

		//특수아이템 사용 (판매용) 사용
		if ( ((lpTransItemInfo->Item.CODE&sinITEM_MASK2)==sinBI1 || (lpTransItemInfo->Item.CODE&sinITEM_MASK2)==sinBI2 ) && lpTransItemInfo->Item.PotionCount==300 ) {
			if ( CheckItemForm( &lpTransItemInfo->Item )==TRUE ) {
				rsOpenSiegeCastleItem( lpTransItemInfo->Item.CODE , lpPlayInfo->Position.x , lpPlayInfo->Position.y , lpPlayInfo->Position.z , lpPlayInfo );
				break;
			}
		}

		if ( lpTransItemInfo->Item.CODE==(sinGG1|sin01) && lpTransItemInfo->Item.ItemKindCode==smTRANSCODE_COLLECTMONEY ) {
			//이벤트 비용 지불
			if ( CheckItemForm( &lpTransItemInfo->Item )==TRUE ) {
				lpPlayInfo->spMoney_In += lpTransItemInfo->Item.Money;		//입금 기록
				//이벤트 입장
				rsEnterHardCoreEvent( lpPlayInfo , lpTransItemInfo->Item.Money );
			}
			break;
		}

		//포스 오브 사용
		if ( (lpTransItemInfo->Item.CODE&sinITEM_MASK2)==sinFO1 && lpTransItemInfo->Item.PotionCount==100 ) {
			//dwForceOrb_Code
			cnt = (lpTransItemInfo->Item.CODE&sinITEM_MASK3)>>8;
			cnt --;
			if ( cnt>=0 && cnt<10 ) {
				lpPlayInfo->dwForceOrb_Code = lpTransItemInfo->Item.CODE;
				lpPlayInfo->dwForceOrb_Time  = dwPlayServTime+ForceOrbUseTime[cnt]*1000;
				lpPlayInfo->dwForceOrb_Damage  = ForceOrbDamage[cnt];
			}
			break;
		}

		if ( (lpTransItemInfo->Item.CODE&sinITEM_MASK2)==sinBC1 && lpTransItemInfo->Item.PotionCount==200 ) {
			if ( CheckItemForm( &lpTransItemInfo->Item )==TRUE ) {
				//공성 아이템 시전

				//cnt = OpenMonsterFromCristal( lpTransItemInfo->Item.CODE , lpPlayInfo->Position.x , lpPlayInfo->Position.y , lpPlayInfo->Position.z , lpPlayInfo );
				cnt = rsOpenSiegeCastleItem( lpTransItemInfo->Item.CODE , lpPlayInfo->Position.x , lpPlayInfo->Position.y , lpPlayInfo->Position.z , lpPlayInfo );
				if ( cnt==TRUE ) break;
				if ( cnt==-1 ) {
					//돌려준다
					//아이템 특정 유저의 인벤토리보냄
					lpTransItemInfo->Item.PotionCount=0;
					rsPutItem2( lpPlayInfo , &lpTransItemInfo->Item );
					break;
				}
				lpTransItemInfo->Item.PotionCount=0;
			}
		}

		if ( rsServerConfig.DisableThrowItem ) break;			//아이템 땅에 버려지면 사라지게

		//위치로 해당 배경 구역을 찾는다 
		lpStgArea = FindStageField( lpTransItemInfo->x, lpTransItemInfo->z );
		if ( lpStgArea ) {
/*
			//서버 부하떄문에 이기능 해제 - 사용금지
			//땅에 떨어질 아이템 검사
			if  (rsCheckStgAreaItem( lpStgArea , &lpTransItemInfo->Item )==FALSE) {
				//땅에서 복사 아이템 발견
				smTransCommand.WParam = 7130;
				smTransCommand.LParam = (int)lpTransItemInfo->Item.ItemName;
				smTransCommand.SParam = lpTransItemInfo->Item.ItemHeader.Head;
				smTransCommand.EParam = lpTransItemInfo->Item.ItemHeader.dwChkSum;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
				break;
			}
*/
			lpsItem = new psITEM;
			lpsItem->state = TRUE;

			memcpy( &lpsItem->ItemInfo , &lpTransItemInfo->Item , sizeof(sITEMINFO) );

#ifdef _SERVER_MODE_OLD

				lpStgItem = lpStgArea->AddItem( lpsItem , 
				lpTransItemInfo->x>>FLOATNS, lpTransItemInfo->y>>FLOATNS, lpTransItemInfo->z>>FLOATNS );

				if ( lpTransItemInfo->Item.CODE==(sinGG1|sin01) ) {
					lpPlayInfo->spMoney_In += lpTransItemInfo->Item.Money;				//입금 기록
				}

#else
			if ( CheckItemForm( &lpsItem->ItemInfo  )==FALSE ) {
				//오류 ( 로그에 기록 )
				smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = 6800;
				smTransCommand.LParam = lpTransItemInfo->Item.CODE;
				smTransCommand.SParam = lpTransItemInfo->Item.ItemHeader.Head;
				smTransCommand.EParam = lpTransItemInfo->Item.ItemHeader.dwChkSum;

				rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
			}

			lpStgItem = lpStgArea->AddItem( lpsItem , 
			lpTransItemInfo->x>>FLOATNS, lpTransItemInfo->y>>FLOATNS, lpTransItemInfo->z>>FLOATNS );

			if ( lpTransItemInfo->Item.CODE==(sinGG1|sin01) ) {
				lpPlayInfo->spMoney_In += lpTransItemInfo->Item.Money;				//입금 기록
			}
			else {
				//아이템 임시 체크섬 확인
				rsCheckItemTempCode( lpPlayInfo, &lpsItem->ItemInfo );
			}
#endif
			delete lpsItem;

			if ( lpStgItem ) {
				//아이템 정보 1개를 근처의 유저들 한테 보냄 
				lpStgArea->SendStgItemToNearUsers( lpStgItem );
				//lpStgArea->SendStgItem( lpPlayInfo , lpStgItem );
			}
		}
		break;


	case smTRANSCODE_SAVETHROWITEM:
		//버린 아이템 저장 하기
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

		if ( lpPlayInfo ) {
			SaveThrowItem( lpPlayInfo , lpTransCommand->WParam , lpTransCommand->LParam , lpTransCommand->SParam );
		}
		break;

	case smTRANSCODE_SAVETHROWITEM2:
		lpTransCommandEx = (smTRANS_COMMAND_EX *)SockInfo->Buff;

		if ( lpPlayInfo->dwFuncChkErrorFlag ) break;		//펑션 오류 캐릭 아이템 땅에 버릴수 없음

#ifndef _SERVER_MODE_OLD
		len = 0;

		if ( lpPlayInfo ) {

			//인벤 아이템 제거
			if ( rsDeleteInvenItem( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam )<0 ) {
				//로그에 기록
				smTransCommandEx.WParam = 8000;
				smTransCommandEx.WxParam = 20;
				smTransCommandEx.LxParam = (int)"*THROW ITEM*";
				smTransCommandEx.LParam = lpTransCommandEx->WParam;
				smTransCommandEx.SParam = lpTransCommandEx->LParam;
				smTransCommandEx.EParam = lpTransCommandEx->SParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommandEx );
				break;
			}
/*
#define	ITEMLOG_USE_ALCHMY		24
#define	ITEMLOG_LOST_ALCHMY		25
#define	ITEMLOG_GET_ALCHMY		26
*/
			//물약 서버포션에서 갯수 줄이기
			if ( (lpTransCommandEx->WParam&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
				cnt = lpTransCommandEx->EParam^lpTransCommandEx->SParam^lpTransCommandEx->code;
				if ( cnt<=0 ) {
					//서버 물약갯수 오류
					rsServerPotionErrorLog( lpPlayInfo ,  lpTransCommandEx->WParam , -cnt , 201 );
					break;
				}
				if ( rsAddServerPotion( lpPlayInfo , lpTransCommandEx->WParam , -cnt )<0 ) {
					//서버 물약갯수 오류
					rsServerPotionErrorLog( lpPlayInfo ,  lpTransCommandEx->WParam , -cnt , 200 );
					break;
				}
			}

			//포스 아이템 사용했는지 확인
			if ( (lpTransCommandEx->WParam&sinITEM_MASK1)==(sinFO1&sinITEM_MASK1) ) {
				cnt = lpTransCommandEx->EParam^lpTransCommandEx->SParam^lpTransCommandEx->code;
				if ( cnt==100 ) {
					//포스 사용
					cnt = (lpTransCommandEx->WParam&sinITEM_MASK3)>>8;
					cnt --;
					if ( cnt>=0 && cnt<10 ) {
						lpPlayInfo->dwForceOrb_SaveCode = lpTransCommandEx->WParam;
						lpPlayInfo->dwForceOrb_SaveTime  = dwPlayServTime+ForceOrbUseTime[cnt]*1000;
						lpPlayInfo->dwForceOrb_SaveDamage  = ForceOrbDamage[cnt];
					}
					len = 100;
				}
			}

			//빌링 아이템 사용했는지 확인
			if ( (lpTransCommandEx->WParam&sinITEM_MASK1)==(sinBI1&sinITEM_MASK1) || (lpTransCommandEx->WParam&sinITEM_MASK1)==(sinBI2&sinITEM_MASK1) ) {
				cnt = lpTransCommandEx->EParam^lpTransCommandEx->SParam^lpTransCommandEx->code;
				if ( cnt==300 ) {

					switch( lpTransCommandEx->WParam ) 
					{
					/////////////////////////////////////////////////////////////////////////////////////
					case (sinBI2|sin01):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_BRONZE;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin02):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_BRONZE;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin03):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_BRONZE;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin04):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE4;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE4;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_BRONZE;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;

					/////////////////////////////////////////////////////////////////////////////////////
					case (sinBI2|sin05):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_SILVER;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin06):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_SILVER;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin07):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_SILVER;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin08):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE4;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE4;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_SILVER;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;

					/////////////////////////////////////////////////////////////////////////////////////
					case (sinBI2|sin09):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_GOLD;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin10):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_GOLD;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin11):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_GOLD;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin12):
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE4;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_PACKAGE4;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_GOLD;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin23):			// pluto 슈페리어 패키지 3시간
						lpPlayInfo->dwTime_PrimeItem_X2 = ( (DWORD)tServerTime) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_ULTRA;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin24):			// pluto 슈페리어 패키지 1일
						lpPlayInfo->dwTime_PrimeItem_X2 = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_ULTRA;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin25):			// pluto 슈페리어 패키지 7일
						lpPlayInfo->dwTime_PrimeItem_X2 = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_ULTRA;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin26):			// pluto 브론즈 패키지2 3시간
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_BRONZE2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin27):			// pluto 브론즈 패키지2 1일
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_BRONZE2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin28):			// pluto 브론즈 패키지2 7일
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_BRONZE2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin29):			// pluto 실버 패키지2 3시간
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_SILVER2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin30):			// pluto 실버 패키지2 1일
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_SILVER2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin31):			// pluto 실버 패키지2 7일
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_SILVER2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin32):			// pluto 골드 패키지2 3시간
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_GOLD2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin33):			// pluto 골드 패키지2 1일
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_GOLD2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin34):			// pluto 골드 패키지2 7일
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_GOLD2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin35):			// pluto 슈페리어 패키지2 3시간
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE1;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_ULTRA2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin36):			// pluto 슈페리어 패키지2 1일
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE2;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_ULTRA2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					case (sinBI2|sin37):			// pluto 슈페리어 패키지2 7일
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ( (DWORD)tServerTime ) + PRIME_ITEM_TIME_PACKAGE3;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_ULTRA2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
						break;
					}

					//사용 ( 일단 1시간 설정 )
					if ( lpTransCommandEx->WParam==(sinBI1|sin12) ) {
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_THIRDEYES;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						lpPlayInfo->dwPrimeItem_PackageCode = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					else if ( lpTransCommandEx->WParam==(sinBI1|sin13) ) {
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_EXPUP;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						lpPlayInfo->dwPrimeItem_PackageCode = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					else if ( lpTransCommandEx->WParam==(sinBI1|sin14) ) {
						lpPlayInfo->dwTime_PrimeItem_X2 = ((DWORD)tServerTime)+PRIME_ITEM_TIME_THIRDEYESx7;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						lpPlayInfo->dwPrimeItem_PackageCode = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					else if ( lpTransCommandEx->WParam==(sinBI1|sin15) ) {
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_EXPUPx7;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						lpPlayInfo->dwPrimeItem_PackageCode = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					////////////////////////////////////////////////////////////////////
					else if ( lpTransCommandEx->WParam==(sinBI1|sin19) ) {
						lpPlayInfo->dwTime_PrimeItem_VampCuspid = ((DWORD)tServerTime)+PRIME_ITEM_TIME_VAMPCUSPID;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					else if ( lpTransCommandEx->WParam==(sinBI1|sin20) ) {
						lpPlayInfo->dwTime_PrimeItem_VampCuspid = ((DWORD)tServerTime)+PRIME_ITEM_TIME_VAMPCUSPIDx2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					else if ( lpTransCommandEx->WParam==(sinBI1|sin21) ) {
						lpPlayInfo->dwTime_PrimeItem_ManaRecharg = ((DWORD)tServerTime)+PRIME_ITEM_TIME_MANARECHARG;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					else if ( lpTransCommandEx->WParam==(sinBI1|sin22) ) {
						lpPlayInfo->dwTime_PrimeItem_ManaRecharg = ((DWORD)tServerTime)+PRIME_ITEM_TIME_MANARECHARGx2;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					//베트남용
					else if ( lpTransCommandEx->WParam==(sinBI1|sin24) ) {
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_EXPUP;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_ULTRA;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}
					else if ( lpTransCommandEx->WParam==(sinBI1|sin25) ) {
						lpPlayInfo->dwTime_PrimeItem_ExpUp = ((DWORD)tServerTime)+PRIME_ITEM_TIME_EXPUPx7;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						lpPlayInfo->dwPrimeItem_PackageCode = PRIME_ITEM_PACKAGE_ULTRA;
						rsSendGameServer_PrimeItem( lpPlayInfo );
					}

					else if( lpTransCommandEx->WParam == (sinBI1|sin26) )	// pluto 마이트 오브 아웰 7일
					{
						lpPlayInfo->dwTime_PrimeItem_MightofAwell = ((DWORD)tServerTime) + PRIME_ITEM_TIME_EXPUPx7;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						lpPlayInfo->dwPrimeItem_PackageCode = 0;
						rsSendGameServer_PrimeItem2( lpPlayInfo );
					}
					else if( lpTransCommandEx->WParam == (sinBI1|sin27) )	// pluto 마이트 오브 아웰 30일
					{
						lpPlayInfo->dwTime_PrimeItem_MightofAwell = ((DWORD)tServerTime) + PRIME_ITEM_TIME_PACKAGE4;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						lpPlayInfo->dwPrimeItem_PackageCode = 0;
						rsSendGameServer_PrimeItem2( lpPlayInfo );
					}
					else if( lpTransCommandEx->WParam == (sinBI1|sin28) )	// pluto 마나 리듀스 포션 1일
					{
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ((DWORD)tServerTime) + PRIME_ITEM_TIME_EXPUP;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						//lpPlayInfo->dwPrimeItem_PackageCode = 0; // pluto 땜빵
						rsSendGameServer_PrimeItem2( lpPlayInfo );
					}
					else if( lpTransCommandEx->WParam == (sinBI1|sin29) ) // pluto 마나 리듀스 포션 7일
					{
						lpPlayInfo->dwTime_PrimeItem_ManaReduce = ((DWORD)tServerTime) + PRIME_ITEM_TIME_EXPUPx7;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						//lpPlayInfo->dwPrimeItem_PackageCode = 0; // pluto 땜빵
						rsSendGameServer_PrimeItem2( lpPlayInfo );
					}
					else if( lpTransCommandEx->WParam == (sinBI1|sin30) )	// pluto 마이트 오브 아웰2 7일
					{
						lpPlayInfo->dwTime_PrimeItem_MightofAwell2 = ((DWORD)tServerTime) + PRIME_ITEM_TIME_EXPUPx7;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						//lpPlayInfo->dwPrimeItem_PackageCode = 0; // pluto 땜빵
						rsSendGameServer_PrimeItem2( lpPlayInfo );
					}
					else if( lpTransCommandEx->WParam == (sinBI1|sin31) )	// pluto 마이트 오브 아웰2 30일
					{
						lpPlayInfo->dwTime_PrimeItem_MightofAwell2 = ((DWORD)tServerTime) + PRIME_ITEM_TIME_PACKAGE4;
						lpPlayInfo->dwPrimeItem_NextSetTime = 0;
						//lpPlayInfo->dwPrimeItem_PackageCode = 0; // pluto 땜빵
						rsSendGameServer_PrimeItem2( lpPlayInfo );
					}

					len = 100;
				}
			}


			if ( rsServerConfig.ServerInventoryMode ) {
				if ( lpTransCommandEx->WParam==(sinGG1|sin01) ) {
					if ( lpPlayInfo->ServerMoney>=lpTransCommandEx->ExParam ) {
						lpPlayInfo->SubServerMoney( lpTransCommandEx->ExParam , WHERE_THROW_ITEM );
					}
					else {
						//로그에 기록
						smTransCommand.WParam = 8010;
						smTransCommand.LParam = 20;
						smTransCommand.SParam = lpPlayInfo->ServerMoney;
						smTransCommand.EParam = lpTransCommandEx->ExParam;
						RecordHackLogFile( lpPlayInfo , &smTransCommand );
						break;
					}
					rsRecord_ItemLog( lpPlayInfo , sinGG1|sin01 , lpTransCommandEx->ExParam , 0 , ITEMLOG_PUT );	//아이템 로그 돈
				}
				else {
					if ( len==100 ) {
						//아이템 로그 일반 아이템 ( 사용로그 )
						rsRecord_ItemLog2( lpPlayInfo , 
							lpTransCommandEx->WParam , 
							lpTransCommandEx->LParam , 
							lpTransCommandEx->SParam , 
							ITEMLOG_USE_ALCHMY );
					}
					else {
						//아이템 로그 일반 아이템
						rsRecord_ItemLog( lpPlayInfo , 
							lpTransCommandEx->WParam , 
							lpTransCommandEx->LParam , 
							lpTransCommandEx->SParam , 
							ITEMLOG_PUT );
					}
				}
			}

			lpPlayInfo->UnsaveMoney = lpTransCommandEx->WxParam-lpTransCommandEx->ExParam;		//버린 돈 기록

/*
			cnt = lpTransCommandEx->WxParam-lpPlayInfo->spMoney_Start;
			if ( abs( cnt-( lpTransCommandEx->SxParam^lpTransCommandEx->LxParam ) )>TOTAL_CHECK_MONEY_MAX ) {

				//돈의 오차가 큼
				smTransCommand.WParam = 6611;
				smTransCommand.SParam = cnt;
				smTransCommand.LParam = lpTransCommandEx->SxParam^lpTransCommandEx->LxParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );			//로그에 기록
				lpPlayInfo->dwTime_Disconnect = 1;

				//연결 종료 요구
				smTransCommand.code = smTRANSCODE_CLOSECLIENT;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+5000;		//5초후 연결 종료

				break;
			}
*/
		}
#endif
		if ( lpPlayInfo && lpTransCommandEx->WParam!=(sinGG1|sin01) ) {
			SaveThrowItem( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam );
		}


		//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
		rsRegist_ItemSecCode( lpPlayInfo , lpTransCommandEx );

		//저장된거 확인 알려줌
		lpsmSock->Send2( (char *)lpTransCommandEx , lpTransCommandEx->size , TRUE );

		/*
		if ( lpTransCommandEx->WParam<sinPM1 && (lpTransCommandEx->WParam&sinITEM_MASK3)>=sin08 ) {
			//클라이언트의 아이템 제거
			rsDeleteClientItem( lpPlayInfo , lpTransCommandEx->WParam, lpTransCommandEx->LParam , lpTransCommandEx->SParam );
		}
		*/
		break;

	case smTRANSCODE_SAVETHROWITEMS:

		if ( lpPlayInfo ) {
			//던져진 아이템 저장 ( 다수 )
			SaveThrowItems( lpPlayInfo , (TRANS_THROW_ITEMS	*)SockInfo->Buff );
		}
		break;

	case smTRANSCODE_SAVETHROWMONEY:
		//돈 줄어듬
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		if ( lpPlayInfo ) {
			lpPlayInfo->UnsaveMoney = lpTransCommand->WParam;		//버린 돈 기록
/*
#ifndef _SERVER_MODE_OLD
			cnt = lpPlayInfo->UnsaveMoney-lpPlayInfo->spMoney_Start;
			if ( abs( cnt-( lpTransCommand->SParam^lpTransCommand->LParam ) )>TOTAL_CHECK_MONEY_MAX ) {

				//돈의 오차가 큼
				smTransCommand.WParam = 6612;
				smTransCommand.SParam = cnt;
				smTransCommand.LParam = lpTransCommand->SParam^lpTransCommand->LParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );			//로그에 기록
				lpPlayInfo->dwTime_Disconnect = 1;

				//연결 종료 요구
				smTransCommand.code = smTRANSCODE_CLOSECLIENT;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+5000;		//5초후 연결 종료
			}
#endif
*/
		}
		break;



	case smTRANSCODE_CHECK_NETSTATE:
		//네트워크 상태 첵크
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

		//공지 사항 문구 보냄
		if ( lpPlayInfo->dwNoticeCount<rsNoticeMessage.Counter )
			rsSendServerNoticeToUser( lpPlayInfo );


#ifndef _SERVER_MODE_OLD			//구버전 호환용
		//lpPlayInfo->TransInfoFlag = TRUE;
		if ( (dwPlayServTime-lpPlayInfo->dwLastExpMoneyCheckTime)>60*1000*2 ) {	//2분동안 경험치돈에 대한 보고가 없는경우
			if ( !lpPlayInfo->dwHopeDisconnectTime ) 
				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+20*1000;
			break;
		}
#endif

		if ( !lpPlayInfo->dwTime_Disconnect && rsServerConfig.SafeClientCodeCount ) {
			for( cnt=0;cnt<rsServerConfig.SafeClientCodeCount;cnt++) {

				if ( rsServerConfig.dwSafeClientCode[cnt]==lpTransCommand->SParam ) {
					break;
				}
			}

			if ( cnt>=rsServerConfig.SafeClientCodeCount ) {
				//메모리 펑션 코드 오류
				smTransCommand.WParam = 1110;
				smTransCommand.SParam = lpTransCommand->SParam;
				smTransCommand.LParam = rsServerConfig.SafeClientCodeCount;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				if ( rsServerConfig.ClientCodeCheckOut && !lpPlayInfo->AdminMode ) {
					//클라이언트 종료 요구

#ifdef _W_SERVER
					lstrcpy( szChkID , lpPlayInfo->szID );
					CharLower( szChkID );
					smTransCommand.code = smTRANSCODE_CLOSECLIENT;
					smTransCommand.size = sizeof( smTRANS_COMMAND );
					lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
#endif
					lpPlayInfo->dwTime_Disconnect = dwTime+1000*60*3;			//3분후에 연결 종료
					break;
				}
				lpTransCommand->SParam = dwTime;
			}
		}

		lpTransCommand->SParam = dwTime;

#ifdef	_LANGUAGE_KOREAN
		if ( ((int)(lpTransCommand->WParam-dwTime))>1000*90 ) {			//90초 차이 나면 스피드오류 종료
#else
		if ( ((int)(lpTransCommand->WParam-dwTime))>1000*30 ) {			//30초 차이 나면 스피드오류 종료
#endif
			//시간 오류 종료를 데이타 서버로 연결 전송
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
			smTransCommand.WParam = 1250;
			smTransCommand.LParam = lpTransCommand->WParam-dwTime;
			smTransCommand.SParam = 0;
			rsSendDataServer( lpsmSock , &smTransCommand );

			//스피드핵 등으로 인한 시간 오류
			smTransCommand.WParam = 1400;
			smTransCommand.LParam = lpTransCommand->WParam-dwTime;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );

			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+20*1000;		//20초후 종료 예약
		}
		else {
			if ( rsServerConfig.ClientFuncCheckMode )
				rsCompClientFuncMem2( lpPlayInfo , lpTransCommand->EParam);

			//nProtect 검사 명령값 설정
			lpTransCommand->LParam = rsServerConfig.CheckProtect;
			lpTransCommand->WParam = 0;
			lpTransCommand->EParam = 0;

			if ( rsServerConfig.ClientFuncCheckMode ) {
				lpTransClientFunPos = rsGetClientPos(lpPlayInfo->Client_Version);
				if ( lpTransClientFunPos && lpTransClientFunPos->FuncCount>1 ) {
					cnt = rand()%(lpTransClientFunPos->FuncCount-1);
					lpTransCommand->WParam = lpTransClientFunPos->dwFuncValue[cnt].dwFunc;
					lpTransCommand->EParam = lpTransClientFunPos->dwFuncValue[cnt].dwLen;
					lpPlayInfo->dwClientFuncChk_2 = lpTransClientFunPos->dwFuncValue[cnt].dwFunc;
					lpPlayInfo->ClientFunChk2_Count++;
				}
			}
			lpTransCommand->size = sizeof(TRANS_ATTACKDATA);	//해킹에 의한 패킷 필터링 교란
			lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );

/*
			//테스트용
			if ( rsServerConfig.ClientFuncCheckMode ) {
				rsCheckClientFuncMem( lpPlayInfo );
				if ( lpPlayInfo->dwFuncChkErrorFlag ) {
					DisconnectUser( lpPlayInfo->lpsmSock );
				}
			}
*/
		}

		if ( lpPlayInfo->szID[0] && lpPlayInfo->szName[0] && lpPlayInfo->ThrowItemCount>(THROW_ITEM_INFO_MAX/2) ) {
			//클라이언트에 데이타 저장 요구
			SendSaveClientData( lpPlayInfo );
		}

		//nSprite 검사
		if ( rsNSpriteMode ) {
			if ( lpPlayInfo->dwNSpriteTime &&  lpPlayInfo->dwNSpriteTime<dwPlayServTime ) {
				//유효 기간 경과
				//lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+5000;
				smTransCommand.WParam = 8140;
				smTransCommand.LParam = (dwPlayServTime-lpPlayInfo->dwNSpriteTime)/1000;
				smTransCommand.SParam = 0;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
				DisconnectUser(lpsmSock);
			}
		}

		if ( LoginServer )
			rsSendAreaServerForceOrb( lpPlayInfo );		//지역서버로 포스오브 정보 보냄

		break;

	case smTRANSCODE_CHECK_NETSTATE2:
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
/*
#ifdef	_LANGUAGE_CHINESE
		lpTransCommand->code = smTRANSCODE_CHECK_NETSTATE20;
#endif
*/
		//공지 사항 문구 보냄
		if ( lpPlayInfo->dwNoticeCount<rsNoticeMessage.Counter )
			rsSendServerNoticeToUser( lpPlayInfo );


		if ( !lpPlayInfo->dwTime_Disconnect && rsServerConfig.SafeClientCodeCount ) {
			for( cnt=0;cnt<rsServerConfig.SafeClientCodeCount;cnt++) {

				if ( rsServerConfig.dwSafeClientCode[cnt]==lpTransCommand->SParam ) {
					break;
				}
			}

			if ( cnt>=rsServerConfig.SafeClientCodeCount ) {
				//메모리 펑션 코드 오류
				smTransCommand.WParam = 1110;
				smTransCommand.SParam = lpTransCommand->SParam;
				smTransCommand.LParam = rsServerConfig.SafeClientCodeCount;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				if ( rsServerConfig.ClientCodeCheckOut && !lpPlayInfo->AdminMode ) {
					//클라이언트 종료 요구
#ifdef _W_SERVER
					lstrcpy( szChkID , lpPlayInfo->szID );
					CharLower( szChkID );
					smTransCommand.code = smTRANSCODE_CLOSECLIENT;
					smTransCommand.size = sizeof( smTRANS_COMMAND );
					lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
#endif
					lpPlayInfo->dwTime_Disconnect = dwTime+1000*60*3;			//3분후에 연결 종료
					break;
				}
				//lpTransCommand->SParam = dwTime;
			}
		}

		if ( rsServerConfig.ClientFuncCheckMode )
			rsCompClientFuncMem2( lpPlayInfo , lpTransCommand->EParam);

		//nProtect 검사 명령값 설정
		lpTransCommand->LParam = TRUE;//rsServerConfig.CheckProtect;
		lpTransCommand->WParam = 0;
		lpTransCommand->EParam = 0;

		if ( rsServerConfig.ClientFuncCheckMode ) {
			lpTransClientFunPos = rsGetClientPos(lpPlayInfo->Client_Version);
			if ( lpTransClientFunPos && lpTransClientFunPos->FuncCount>1 ) {
				cnt = rand()%(lpTransClientFunPos->FuncCount-1);
				lpTransCommand->WParam = lpTransClientFunPos->dwFuncValue[cnt].dwFunc;
				lpTransCommand->EParam = lpTransClientFunPos->dwFuncValue[cnt].dwLen;
				lpPlayInfo->dwClientFuncChk_2 = lpTransClientFunPos->dwFuncValue[cnt].dwFunc;
				lpPlayInfo->ClientFunChk2_Count++;
			}
		}
		lpTransCommand->size = sizeof(TRANS_ATTACKDATA);	//해킹에 의한 패킷 필터링 교란
		lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );

		if ( lpPlayInfo->szID[0] && lpPlayInfo->szName[0] && lpPlayInfo->ThrowItemCount>(THROW_ITEM_INFO_MAX/2) ) {
			//클라이언트에 데이타 저장 요구
			SendSaveClientData( lpPlayInfo );
		}
		//nSprite 검사
		if ( rsNSpriteMode ) {
			if ( lpPlayInfo->dwNSpriteTime &&  lpPlayInfo->dwNSpriteTime<dwPlayServTime ) {
				//유효 기간 경과
				//lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+5000;
				smTransCommand.WParam = 8140;
				smTransCommand.LParam = (dwPlayServTime-lpPlayInfo->dwNSpriteTime)/1000;
				smTransCommand.SParam = 0;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
				DisconnectUser(lpsmSock);
			}
		}

		if ( LoginServer )
			rsSendAreaServerForceOrb( lpPlayInfo );		//지역서버로 포스오브 정보 보냄

		break;


	case smTRANSCODE_CHECK_NETSTATE3:
	case smTRANSCODE_CHECK_NETSTATE4:

		//공지 사항 문구 보냄
		if ( lpPlayInfo->dwNoticeCount<rsNoticeMessage.Counter )
			rsSendServerNoticeToUser( lpPlayInfo );

#ifndef _SERVER_MODE_OLD			//구버전 호환용
		//lpPlayInfo->TransInfoFlag = TRUE;
		if ( (dwPlayServTime-lpPlayInfo->dwLastExpMoneyCheckTime)>60*1000*3 ) {	//3분동안 경험치돈에 대한 보고가 없는경우
			if ( !lpPlayInfo->dwHopeDisconnectTime ) 
				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+20*1000;
			break;
		}
#endif

	case smTRANSCODE_CHECK_NETSTATE5:

		//공지 사항 문구 보냄
		if ( lpPlayInfo->dwNoticeCount<rsNoticeMessage.Counter )
			rsSendServerNoticeToUser( lpPlayInfo );

		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		lpTransCommand->size = sizeof(TRANS_ATTACKDATA);	//해킹에 의한 패킷 필터링 교란
		lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
		break;


	case smTRANSCODE_CHECK_EXPMONEY:
		//보낸 경험치를 돈을 주기적으로 다시 받아서 맞는지 확인
		rsCheckTotalExpMoney( lpPlayInfo , (TRANS_TOTAL_EXPMONEY *)SockInfo->Buff );
		break;

	case smTRANSCODE_CHECK_EXPDATA:
		//게임 서버로 부터 경험치 정보 입수
		rsRecvGameServerExp( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
		break;


	case smTRANSCODE_CHECK_ADMINMODE:
		//관리자 모드 확인
		rsCheckAdminPlayer( lpPlayInfo );		//관리자 인지 조사
		break;

	case smTRANSCODE_ADMINMODE:
	case smTRANSCODE_ADMINMODE2:
		//관리자 설정
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

		if ( !lpTransCommand->LParam ) {
			lpPlayInfo->AdminMode = 1;
			lpPlayInfo->HideMode = lpTransCommand->SParam;
		}

		rsCheckAdminPlayer( lpPlayInfo );		//관리자 인지 조사

		if ( !LoginServer ) {
			lpTransCommand->size = sizeof(smTRANS_COMMAND);
			lpTransCommand->code = smTRANSCODE_CHECK_ADMINMODE;
			rsSendDataServer( lpPlayInfo->lpsmSock , lpTransCommand );			//군서버에 보고
		}


/*
		//디버그로 외부 IP접속자 기록 
		if ( !lpPlayInfo->AdminIP ) {

			//디버그 접속 유저 기록 파일로 남김
			RecordDebugPlayLogFile( lpPlayInfo );

			if ( rsServerConfig.DebugIP_Count>0 ) {
				//디버그 IP가 등록되어 있다
				for(cnt=0;cnt<rsServerConfig.DebugIP_Count;cnt++) {
					//등록 IP검사
					if ( strstr( lpsmSock->szIPAddr , rsServerConfig.szDebugIP[cnt] )!=0 ) {
						break;
					}
				}

				if ( cnt<rsServerConfig.DebugIP_Count ) {
					//등록된 IP확인
					break;
				}
				else {
					//나쁜자들 명단에 등록
					if ( !lpPlayInfo->BlockTime )
						lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );		//24시간 등록

					//등록되지 않은 IP 연결 종료
					DisconnectUser( lpsmSock );
					break;
				}
			}


			if ( rsServerConfig.DebugID_Count>0 ) {
				//디버그 ID가 등록되어 있다
				for(cnt=0;cnt<rsServerConfig.DebugID_Count;cnt++) {
					//등록 ID검사
					if ( lstrcmpi( lpPlayInfo->szID , rsServerConfig.szDebugID[cnt] )==0 ) {
						break;
					}
				}

				if ( cnt<rsServerConfig.DebugID_Count ) {
					//등록된 ID확인
					break;
				}
				else {
					//나쁜자들 명단에 등록
					if ( !lpPlayInfo->BlockTime )
						lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );		//24시간 등록
					//등록되지 않은 ID 연결 종료
					DisconnectUser( lpsmSock );
				}
			}

//			lstrcpy( rsServerConfig.szDebugID[rsServerConfig.DebugID_Count] , strBuff );

		}
*/

		break;

	case smTRANSCODE_SET_OBJSERIAL:
		//메인 서버에서 설정된 오브젝트 번호를 클라이언트를 거쳐서 받음
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		lpPlayInfo->dwObjectSerial = lpTransCommand->WParam;
		lpPlayInfo->TransInfoFlag = TRUE;
		break;

	case smTRANSCODE_CONT_OBJSERIAL:
		//연결에 문제가 생겨 재접속 한 경우
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		lpPlayInfo->TransInfoFlag = TRUE;

		for(cnt=0;cnt<CONNECTMAX;cnt++) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial==(DWORD)lpTransCommand->WParam &&
				&rsPlayInfo[cnt]!=lpPlayInfo && rsPlayInfo[cnt].TransInfoFlag &&
				rsPlayInfo[cnt].lpsmSock->acc_sin.sin_addr.S_un.S_addr==lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr	) {

				lpBuff = lpPlayInfo->lpRecordDataBuff;
				memcpy( lpPlayInfo , &rsPlayInfo[cnt] , sizeof( rsPLAYINFO ) );
				lpPlayInfo->lpRecordDataBuff = lpBuff;

				if ( lpPlayInfo->lpRecordDataBuff && rsPlayInfo[cnt].lpRecordDataBuff ) {
					memcpy( lpPlayInfo->lpRecordDataBuff , rsPlayInfo[cnt].lpRecordDataBuff , srRECORD_MEMORY_SIZE );
					((TRANS_RECORD_DATA *)rsPlayInfo[cnt].lpRecordDataBuff)->size = 0;
				}

				lpPlayInfo->dwObjectSerial = lpTransCommand->WParam;
				lpPlayInfo->lpsmSock = lpsmSock;

				if ( lpPlayInfo->dwPartyInfo && lpPlayInfo->lpPartyMaster ) {
					lpPlayInfo->lpPartyMaster->ChangePartyPlayer( &rsPlayInfo[cnt] , lpPlayInfo );		//파티관련 복구
				}

				//패킷 암호화 코드 복사
				lpPlayInfo->lpsmSock->dwEncPacketCode = rsPlayInfo[cnt].lpsmSock->dwEncPacketCode;
				lpPlayInfo->lpsmSock->bEncXor = rsPlayInfo[cnt].lpsmSock->bEncXor;
				lpPlayInfo->lpsmSock->bDecXor = rsPlayInfo[cnt].lpsmSock->bDecXor;

				rsPlayInfo[cnt].szID[0] = 0;
				rsPlayInfo[cnt].szName[0] = 0;
				rsPlayInfo[cnt].lpPostBoxItem = 0;

				DisconnectUser( rsPlayInfo[cnt].lpsmSock );

				if ( LoginServer && !rsServerConfig.AreaServer.IP_Count ) {
					//서버 재연결 로그 남김 ( 로그인 서버인 경우 - 비정상적일때 )
					smTransCommand.WParam = 8300;
					smTransCommand.LParam = lpTransCommand->WParam;
					RecordHackLogFile( lpPlayInfo , &smTransCommand );
				}
				break;
			}
		}

		if ( cnt>=CONNECTMAX ) {
			DisconnectUser( lpsmSock );
			goto quit;
		}

		break;

	case smTRANSCODE_SET_BLACKLIST:
	case smTRANSCODE_SET_BLACKLIST2:
	case smTRANSCODE_SET_BLACKLIST3:
		//해킹 시도 기록 파일로 남김
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		RecordHackLogFile( lpPlayInfo , lpTransCommand );
		break;

	case smTRANSCODE_SET_ITEMCOPYLIST:
		//복사 아이템 소지한 유저 로그파일에 기록
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

		smTransCommand.WParam = 1000;
		smTransCommand.LParam = lpTransCommand->WParam;
		smTransCommand.SParam = 0;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
		break;

	case smTRANSCODE_FINDCRACK:
		//클라이언트 윈도우에서 크랙소프트웨어 발견 로그파일에 기록
		lpBuff = &SockInfo->Buff[8];
		smTransCommand.WParam = 1100;
		smTransCommand.LParam = (DWORD)lpBuff;
		smTransCommand.SParam = 0;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
		lpPlayInfo->dwTime_Disconnect = dwTime;

		//클라이언트 종료 요구
		//smTransCommand.code = smTRANSCODE_CLOSECLIENT;
		//smTransCommand.size = sizeof( smTRANS_COMMAND );
		//lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

		lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+1000*120;		//120초후 종료
		break;

	case smTRANSCODE_FINDCRACK2:
		//클라이언트 윈도우에서 포커스 강제 변경 로그파일에 기록
		lpBuff = &SockInfo->Buff[8];
		smTransCommand.WParam = 1101;
		smTransCommand.LParam = (DWORD)lpBuff;
		smTransCommand.SParam = 0;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
		//DisconnectUser( lpsmSock );
		lpPlayInfo->dwTime_Disconnect = dwTime;

		//클라이언트 종료 요구
		smTransCommand.code = smTRANSCODE_CLOSECLIENT;
		smTransCommand.size = sizeof( smTRANS_COMMAND );
		lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
		break;

	case smTRANSCODE_MODULE_WARNIG:
		//클라이언트에서 수상한 모듈 발견
		lpTransChatMessage = (TRANS_CHATMESSAGE *)SockInfo->Buff;
		for(cnt=0;cnt<(int)lpTransChatMessage->dwIP;cnt++)
			lpTransChatMessage->szMessage[cnt] ^= (cnt*0x15);

		smTransCommand.WParam = 8720;
		smTransCommand.LParam = (DWORD)lpTransChatMessage->szMessage;
		smTransCommand.SParam = lpTransChatMessage->dwObjectSerial;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		break;


	case smTRANSCODE_UPDATE_CINFO:
		//레벨 및 기타 정보 변경
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		switch( lpTransCommand->WParam ) {
		case 0:
			lpPlayInfo->smCharInfo.Level = lpTransCommand->LParam;			//레벨 저장
			break;
		case 1:
			lpPlayInfo->smCharInfo.Level			= lpTransCommand->LParam;			//레벨 저장
			lpPlayInfo->smCharInfo.ClassClan		= lpTransCommand->SParam;			//클랜 정보
			lpPlayInfo->smCharInfo.bUpdateInfo[0]	= lpTransCommand->EParam;			//업데이트 카운터 갱신
			lpPlayInfo->dwClanCode = GetClanCode(lpPlayInfo->smCharInfo.ClassClan);			//클랜코드 등록

			//블레스캐슬 스킬 적용
			if ( LoginServer )
				rsSendBlessCastleClanSkill( lpPlayInfo );

			break;
		}
		break;

	case smTRANSCODE_PROCESS_CLAN_SKILL:
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		if ( lpTransCommand->EParam==rsCheck_BlessCastleClanSkill( lpPlayInfo , lpTransCommand ) ) {
			switch( lpTransCommand->WParam ) {
			case SIN_CLANSKILL_ABSORB:
				lpPlayInfo->dwBlessSkill_Code = SKILL_PLAY_BLESS_ABSORB;
				lpPlayInfo->dwBlessSkill_Time = dwPlayServTime+1000*60*10;
				lpPlayInfo->dwBlessSkill_Param = 10;
				break;
			case SIN_CLANSKILL_DAMAGE:
				lpPlayInfo->dwBlessSkill_Code = SKILL_PLAY_BLESS_DAMAGE;
				lpPlayInfo->dwBlessSkill_Time = dwPlayServTime+1000*60*10;
				lpPlayInfo->dwBlessSkill_Param = 10;
				break;
			case SIN_CLANSKILL_EVASION:
				lpPlayInfo->dwBlessSkill_Code = SKILL_PLAY_BLESS_EVADE;
				lpPlayInfo->dwBlessSkill_Time = dwPlayServTime+1000*60*10;
				lpPlayInfo->dwBlessSkill_Param = 10;
				break;
			}

			if ( lpPlayInfo->AdminMode>1 ) {
				//스킬 클라이언트에 출력
				wsprintf( TransChatMessage.szMessage , ">Process Clan Skill[%d] ( %d )" , rsServerConfig.ServerCode , lpTransCommand->WParam );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			}
		}
		break;

	case smTRANSCODE_OPENMONSTER:
		//몬스터 출현 요구

		break;

		lpTransCharCommand = (smTRANS_CHAR_COMMAND *)SockInfo->Buff;
		//(땅에 떨어뜨림)
		lpStgArea = FindStageField( lpPlayInfo->Position.x, lpPlayInfo->Position.z );
		if ( lpStgArea ) {
			lpStgArea->EvnMonster = TRUE;
			STG_CHAR_INFO StgCharInfo;

			len = 0;

			StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
			StgCharInfo.smCharInfo.Life[0] = 100;
			StgCharInfo.smCharInfo.Mana[0] = 100;
			StgCharInfo.smCharInfo.Life[1] = 100;
			StgCharInfo.smCharInfo.State = TRUE;

			if ( lpStgArea->rsMonsterList.Counter ) {
				//몬스터 설정이 있을경우
				rnd = (rand()%lpStgArea->rsMonsterList.PecetageCount);
				for( cnt=0;cnt<lpStgArea->rsMonsterList.Counter;cnt++ ) {
					if ( lpStgArea->rsMonsterList.rsMonster[cnt].NumOpenStart>rnd ) break;
				}
				memcpy( &StgCharInfo.smCharInfo , lpStgArea->rsMonsterList.rsMonster[cnt-1].lpCharInfo , sizeof( smCHAR_INFO ) );
				len++;
			}

			if ( lpTransCharCommand->szName[0] ) {
				//특정 몬스터 호출
				for(cnt=0;cnt<chrMonsterCnt;cnt++) {
					if ( lstrcmp(chrMonsterList[cnt].szName , lpTransCharCommand->szName )==0 ) {
						memcpy(	&StgCharInfo.smCharInfo , &chrMonsterList[cnt] , sizeof( smCHAR_INFO ) ); 
						len++;
						break;
					}
				}
			}

			if ( len ) {
				lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
				if ( lpChar ) {
					lpChar->pX = lpPlayInfo->Position.x;
					lpChar->pY = lpPlayInfo->Position.y;
					lpChar->pZ = lpPlayInfo->Position.z;
					lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
					lpChar->TargetMoveCount = 0;
				}
			}
		}
		break;

	case smTRANSCODE_TRADEITEMS:
		//아이템 교환 데이타 보냄
		lpTransTradeItems = (TRANS_TRADEITEMS *)SockInfo->Buff;
		lpPlayInfo2 = srFindUserFromSerial( lpTransTradeItems->dwRecver );
		if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
			lpPlayInfo2->lpsmSock->Send( (char *)lpTransTradeItems , lpTransTradeItems->size , TRUE );
		}
		break;

	case smTRANSCODE_TRADE_ITEMKEY:
		//아이템 교환 데이타 보냄
		lpTransTradeItems = (TRANS_TRADEITEMS *)SockInfo->Buff;
		lpPlayInfo2 = srFindUserFromSerial( lpTransTradeItems->dwRecver );
		if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
			if ( rsTradeInvenItem( lpPlayInfo , lpPlayInfo2 , (TRANS_TRADE_ITEMKEY *)SockInfo->Buff )==TRUE ) {
				lpPlayInfo2->lpsmSock->Send2( (char *)lpTransTradeItems , lpTransTradeItems->size , TRUE );
			}
		}
		break;

	case smTRANSCODE_TRADE_READYITEM:
		//아이템 교환 데이타 보냄
		lpTransTradeItems = (TRANS_TRADEITEMS *)SockInfo->Buff;
		lpPlayInfo2 = srFindUserFromSerial( lpTransTradeItems->dwRecver );
		if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
			lpPlayInfo2->lpsmSock->Send2( (char *)lpTransTradeItems , lpTransTradeItems->size , TRUE );
		}

//-193
		break;

	case smTRANSCODE_TRADE_REQUST:
		//아이템 교환 신청
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->WParam );
		if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
			if ( lpPlayInfo->dwFuncChkErrorFlag || lpPlayInfo2->dwFuncChkErrorFlag ) break;			//펑션 오류 캐릭 거래 금지
			if ( lpPlayInfo->szServerID[0] || rsServerConfig.DisableThrowItem ) break;													//멀티군 연동서버 거래금지
			lpPlayInfo2->lpsmSock->Send( (char *)lpTransCommand , lpTransCommand->size , TRUE );
		}
		break;

	case smTRANSCODE_PARTY_JOIN:
		//파티 가입
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->WParam );
		if ( lpPlayInfo2 ) {
			if ( lpPlayInfo2->lpPartyMaster ) {
				if ( !lpPlayInfo->lpPartyMaster ) {
					//기존 파티에 가입
					//lpPlayInfo2->lpPartyMaster->JoinPartyPlayer(lpPlayInfo);
					lpPlayInfo->JoinParty( lpPlayInfo2->lpPartyMaster );
				}
			}
			else {
				if ( lpPlayInfo->lpPartyMaster ) {
					//기존 파티에 가입
					//lpPlayInfo->lpPartyMaster->JoinPartyPlayer(lpPlayInfo2);
					lpPlayInfo2->JoinParty( lpPlayInfo->lpPartyMaster );
				}
				else {
					//파티 생성 및 가입
					lpPlayInfo2->CreateParty( lpPlayInfo );
				}
			}
		}
		break;


	case smTRANSCODE_PARTY_COMMAND:
		//파티 관련 메뉴
		lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
		lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->WParam );
		TransChatMessage.szMessage[0] = 0;
		if ( !lpPlayInfo->dwPartyInfo || !lpPlayInfo->lpPartyMaster ) break;

#ifdef _W_SERVER

		switch( lpTransCommand->LParam ) {
		case 0:
			//이임
			if ( lpPlayInfo2 && lpPlayInfo->LeavePartyMaster(lpPlayInfo2) ) {
				//wsprintf( TransChatMessage.szMessage , "동료장을 %s님께 이임 했습니다",lpPlayInfo2->smCharInfo.szName  );
				wsprintf( TransChatMessage.szMessage , srMsg_026,lpPlayInfo2->smCharInfo.szName  );
			}
			break;
		case 1:
			//해산
			if ( lpPlayInfo->ReleaseParty() ) {
				//wsprintf( TransChatMessage.szMessage , "동료를 해산 시켰습니다" );
				wsprintf( TransChatMessage.szMessage , srMsg_025 );
				
			}
			break;

		case 2:
			//추방
			if ( lpPlayInfo2 && lpPlayInfo2->SecedeParty() ) {

				//wsprintf( TransChatMessage.szMessage , "%s님을 동료에서 추방했습니다" , lpPlayInfo2->smCharInfo.szName );
				wsprintf( TransChatMessage.szMessage , srMsg_023 , lpPlayInfo2->smCharInfo.szName );
				lpPlayInfo->SendPartyMessage( TransChatMessage.szMessage , 2 );
				TransChatMessage.szMessage[0] = 0;
			}
			break;

		case 3:
			//탈퇴
			if ( lpPlayInfo->SecedeParty() ) {
				//wsprintf( TransChatMessage.szMessage , "동료에서 탈퇴했습니다" );
				wsprintf( TransChatMessage.szMessage , srMsg_022 );
			}
			break;
		}
#endif

		if ( TransChatMessage.szMessage[0] ) {
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
		break;

		case smTRANSCODE_PARTY_PLAYUPDATE:
			//메인 서버에 파티원 정보 업데이트 요구 ( 파티관리서버로 부터 데이타 입수 )
			lpPlayInfo->UpdateServerPartyPlayer( (TRANS_PARTY_PLAYINFO *)SockInfo->Buff );
			break;

		case smTRANSCODE_PARTY_POTION:
			//파티원에게 회복력 전송
			if ( lpPlayInfo->lpPartyMaster )
				lpPlayInfo->lpPartyMaster->SendPartyData( lpPlayInfo , SockInfo->Buff );
			break;


		case smTRANSCODE_PARTY_RELEASE:
			//파티 탈퇴 또는 해산 ( 파티관리서버로 부터 데이타 입수 )
			lpPlayInfo->dwPartyInfo = 0;
			lpPlayInfo->lpPartyMaster = 0;
			break;

		case smTRANSCODE_WAREHOUSE:
			//아이템 보관 창고 데이타 입수
			//창고 데이타 저장
			if ( lpPlayInfo->dwFuncChkErrorFlag ) {
				//펑션첵크 에러
				smTransCommand.WParam = 1130;
				smTransCommand.SParam = lpPlayInfo->Client_Version;
				smTransCommand.LParam = lpPlayInfo->dwFuncChkErrorFlag;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				DisconnectUser(lpsmSock);
				break;
			}

			if ( lpPlayInfo->OpenWarehouseInfoFlag ) {
				rsSaveWareHouseData( lpPlayInfo->szID , (TRANS_WAREHOUSE *)SockInfo->Buff );
				lpPlayInfo->dwRecordDataTime = 1;			//창고 저장시 실제 저장도 같은 시기에 하도록 ( 창고 복템 문제땜 )
			}
			break;

		case smTRANSCODE_OPEN_WAREHOUSE:
			//창고 데이타 요구
			if ( !lpPlayInfo->dwFuncChkErrorFlag )
				SendWareHouseToClient( lpPlayInfo );
			break;

		case smTRANSCODE_COLLECTMONEY:
			//기부금 받음
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			//기부금 파일로 기록
			//RecordCollectMoney( lpPlayInfo , lpTransCommand->WParam );
			lpPlayInfo->UnsaveMoney = lpTransCommand->LParam;		//버린 돈 기록
			lpPlayInfo->spMoney_In += lpTransCommand->WParam;		//입금 기록

			//이벤트 입장
			rsEnterHardCoreEvent( lpPlayInfo , lpTransCommand->WParam );

			//int rsEnterHardCoreEvent( rsPLAYINFO *lpPlayInfo )



			//	TransCommand.WParam = Money;							//기부한 돈
			//	TransCommand.LParam = lpCurPlayer->smCharInfo.Money;		//보유한 돈


			break;

		case smTRANSCODE_CHECKIP:
			lpTransCharCommand = (smTRANS_CHAR_COMMAND *)SockInfo->Buff;

			//하위 게임 서버와 IP가 맞는지 확인한다
			if ( rsCheckChildServer( lpTransCharCommand->szName )!=TRUE ) {
				//IP침범 오류

				smTransCommand.WParam = 5200;
				smTransCommand.LParam = (DWORD)lpTransCharCommand->szName;
				smTransCommand.SParam = lpTransCharCommand->WParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				//클라이언트 종료 요구
				smTransCommand.code = smTRANSCODE_CLOSECLIENT;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
			}
			break;

		case smTRANSCODE_PLAYERKILLING:
		{
			//PK당한 캐릭터 정보 보내옴
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			#ifdef LOG_THE_PK
				if ( rsServerConfig.Enable_PK==1 ) 
				{
					lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->WParam );
					if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) 
					{
						//PK를 한놈에게 패킷을 보내면, netplay.cpp에서 이 패킷을 받고 감옥에 보내는 처리를 한다.
						lpPlayInfo2->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
					}
				}

				if( rsServerConfig.bPK_LOG == true )
				{
					HANDLE hFile;
					char szFileName[255];
					char szLog[500];
					SYSTEMTIME	SystemTime;

					GetLocalTime(&SystemTime);
					sprintf(szFileName,"PK_LOG\\(PK)%d-%d.log",SystemTime.wMonth,SystemTime.wDay);
					CreateDirectory("PK_LOG",NULL);
					sprintf(szLog,"%d:%d:%d - (ID : %s) (Name : %s)is killed by (ID : %s) (Name : %s)",SystemTime.wHour,SystemTime.wMinute,SystemTime.wSecond,
						lpPlayInfo->szID,lpPlayInfo->szName,lpPlayInfo2->szID,lpPlayInfo2->szName	);
					hFile = CreateFile(szFileName,GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
					if( hFile != INVALID_HANDLE_VALUE )
					{
						DWORD dwFileLength = GetFileSize(hFile,NULL);
						DWORD dwAccess;
						SetFilePointer(hFile,dwFileLength,NULL,FILE_BEGIN);
						WriteFile(hFile,szLog,strlen(szLog),&dwAccess,NULL);
						CloseHandle(hFile);
					}
				}
			#endif
		}break;


		case smTRANSCODE_CRAFTITEM:
			//믹스쳐 아이템 받음
			rsRecvCraftItem( lpPlayInfo , (sCRAFTITEM_SERVER *)SockInfo->Buff );
			break;

		case smTRANSCODE_AGINGITEM:
			//에이징 아이템 받음
			rsRecvAgingItem( lpPlayInfo , (sCRAFTITEM_SERVER *)SockInfo->Buff );
			break;

		case smTRANSCODE_AGING_UPGRADE:
			//에이징 아이템 업그레이드
			rsRecvAgingUpgradeItem( lpPlayInfo , (TRANS_ITEMINFO *)SockInfo->Buff );
			break;

		case smTRANSCODE_MAKE_LINKCORE:
			//링크 코어 등록 요청
			rsRecvMakeLinkCore( lpPlayInfo , (TRANS_ITEMINFO *)SockInfo->Buff );
			break;

		case smTRANSCODE_USE_LINKCORE:
			//링크코어 사용
			rsRecvUseLinkCore( lpPlayInfo , (TRANS_ITEMINFO *)SockInfo->Buff );
			break;

		case smTRANSCODE_WINGITEM:
			//윙 아이템 획득
			rsRecvWingItem( lpPlayInfo , (sCRAFTITEM_SERVER *)SockInfo->Buff );
			break;

		case smTRANSCODE_SHOPTITEM:
			//상점 아이템 구입 받음
			rsRecvBuyShopItem( lpPlayInfo , (TRANS_BUY_SHOPITEM *)SockInfo->Buff );
			break;

		case smTRANSCODE_SHOP_SELLITEM:
			//상점 아이템 판매 받음
			rsRecvSellShopItem( lpPlayInfo , (TRANS_ITEMINFO *)SockInfo->Buff );
			break;

		case smTRANSCODE_CHECKITEM:
			//보내온 아이템 인증 확인
			rsCheckItemCode( lpPlayInfo , &((TRANS_ITEMINFO *)SockInfo->Buff)->Item );
			break;

		case smTRANSCODE_CLIENT_FUNCPOS:
			//클라이언트 펑션 포지션 입수
			rsRecvClientFuncPos( (TRANS_CLIENT_FUNPOS *)SockInfo->Buff );
			break;

		case smTRANSCODE_FUNCTON_RESULT:
		case smTRANSCODE_FUNCTION_MEM2:
			//클라이언트 펑션 검사 결과 입수
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			rsCompClientFuncMem( lpPlayInfo ,lpTransCommand->WParam , lpTransCommand->EParam );
			break;

		case smTRANSCODE_PROCESS_TIMEMAX:
			//프로세스 타임감시값 결과 입수
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			if ( rsServerConfig.ClientProcessTimeChk )
				cnt = rsServerConfig.ClientProcessTimeChk*1000;
			else
				cnt = 10000;

			if ( !lpPlayInfo->AdminMode && !lpPlayInfo->dwHopeDisconnectTime && lpTransCommand->WParam>=cnt ) {
				//10초나 그 이상 프로세스가 멈춰 있었음을 감지 ( 프로세스 디버거 경고 )

				smTransCommand.WParam = 7000;
				smTransCommand.LParam = lpTransCommand->WParam;
				smTransCommand.SParam = lpTransCommand->LParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				if ( rsServerConfig.ClientProcessTimeChkOut ) {
					//5~15초 사이에 연결 종료 시킨다
					lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+5000+((rand()%10)*1000);
					if ( !lpPlayInfo->BlockTime )
						lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*40 );	//40 분동안 블럭
				}
			}
			break;

		case smTRANSCODE_FUNCERROR:
			//데이타 서버에서 펑션첵크에러 난것을 알려줌
			if ( !lpPlayInfo->dwFuncChkErrorFlag ) 
				lpPlayInfo->dwFuncChkErrorFlag = TRUE;
			break;

		case smTRANSCODE_BAD_PLAYER:
			//불량 유저 설정 받음
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			lpPlayInfo->BadPlayer = lpTransCommand->WParam;
			break;


		case smTRANSCODE_HEALING:
			//힐링 ( 치료 )
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			rsPlayHealing( lpTransCommand );
			break;

		case smTRANSCODE_GRAND_HEALING:
			//그랜드힐링 ( 파티 전체 치료 )
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			rsPlayGrandHealing( lpPlayInfo , lpTransCommand );
			break;


		case smTRANSCODE_HOLYMIND:
			//홀리 마인드 ( 데미지 약화 )
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			rsPlayHolyMind( lpTransCommand );
			break;

		case smTRANSCODE_FIX_ATTACK:
			//잘못된 공수 수치 발견
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

#ifndef _PLAY_MORYON
			if ( lpPlayInfo->Client_Version<=1756 ) break;
#endif
			if ( !lpPlayInfo->BadPlayer ) {
				lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
				smTransCommand.WParam = 7100;
				smTransCommand.LParam = lpTransCommand->WParam;
				smTransCommand.SParam = lpTransCommand->LParam;
				smTransCommand.EParam = lpTransCommand->SParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
			}
			if ( lpPlayInfo->smCharInfo.Level>=13 ) {
				//lpPlayInfo->BadPlayer = 4;

				smTransCommand.code = smTRANSCODE_BAD_PLAYER;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = lpPlayInfo->BadPlayer;
				smTransCommand.LParam = 0;
				smTransCommand.SParam = 0;
				smTransCommand.EParam = 0;

				//if ( lpPlayInfo->lpsmSock )
				//	rsSendGameServer( lpPlayInfo->lpsmSock , &smTransCommand );
			}

			//DisconnectUser( lpPlayInfo->lpsmSock );		//테스트용 나중에 제거

			break;

		case smTRANSCODE_CLIENT_ERROR:
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
#ifndef _PLAY_MORYON
			if ( lpPlayInfo->Client_Version<=1756 ) break;
#endif
			//캐릭터 생명/기력/근력 그래프 수치 위조
			if ( !lpPlayInfo->BadPlayer ) {
				lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
				smTransCommand.WParam = 7110;
				smTransCommand.LParam = lpTransCommand->LParam;
				smTransCommand.SParam = lpTransCommand->SParam;
				smTransCommand.EParam = lpTransCommand->EParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
			}

			if ( lpPlayInfo->smCharInfo.Level>=13 ) {
				//lpPlayInfo->BadPlayer = 4;

				smTransCommand.code = smTRANSCODE_BAD_PLAYER;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = lpPlayInfo->BadPlayer;
				smTransCommand.LParam = 0;
				smTransCommand.SParam = 0;
				smTransCommand.EParam = 0;

				//if ( lpPlayInfo->lpsmSock )
				//	rsSendGameServer( lpPlayInfo->lpsmSock , &smTransCommand );
			}

			//DisconnectUser( lpPlayInfo->lpsmSock );		//테스트용 나중에 제거

			break;

		case smTRANSCODE_RECORD_TRADE:
			//아이템 거래 기록 도착 
			rsRecvRecordTradeItem( lpPlayInfo , (TRANS_RECORD_TRADE_ITEMS *)SockInfo->Buff );
			break;

		case smTRANSCODE_INVEN_ERR_ITEM:
			//인벤토리 아이템 복사 오류
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			smTransCommand.WParam = 7150;
			smTransCommand.LParam = lpTransCommand->LParam;
			smTransCommand.SParam = lpTransCommand->SParam;
			smTransCommand.EParam = lpTransCommand->EParam;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			break;

		case smTRANSCODE_INVEN_ERR_MONEY:
			//인벤토리 돈 복사 오류
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			smTransCommand.WParam = 7160;
			smTransCommand.LParam = lpTransCommand->LParam;
			smTransCommand.SParam = lpTransCommand->SParam;
			smTransCommand.EParam = lpTransCommand->EParam;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			break;

		case smTRANSCODE_GETITEM:
			//플레이어가 아이템 집었을때 호출하여 검사
			lpTransCommandEx = (smTRANS_COMMAND_EX *)SockInfo->Buff;

			cnt = lpTransCommandEx->EParam^smTRANSCODE_GETITEM^lpTransCommandEx->SParam;
			len = 0;

			//아이템 정보송수신 구조체에 보안코드 해독 비교 ( 컴파일시 서버에서만 존재 )
			if ( rsCheck_ItemSecCode( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam , cnt,
				lpTransCommandEx->WxParam , lpTransCommandEx->LxParam , lpTransCommandEx->SxParam , lpTransCommandEx->ExParam , &len )>0 ) {

				if ( lpTransCommandEx->WParam==(sinGG1|sin01) ) {
					lpPlayInfo->AddServerMoney ( cnt , WHERE_GET_ITEM );
					rsRecord_ItemLog( lpPlayInfo , sinGG1|sin01 , cnt , 0 , ITEMLOG_GET );		//아이템 로그 돈
					/////////////////////////// 이사님 07_12_10 
					if ( cnt>1000000 ) {
						char szTemp[256];
						wsprintf( szTemp , "Debug GetMoney ID(%s) Name(%s) ( Money:%d SvCode:%d SndCount:%d iHead:%d iChkSum:%d SeCode:%d %d %d %d )",
							lpPlayInfo->szID , lpPlayInfo->szName , cnt , lpTransCommandEx->LParam , lpTransCommandEx->SParam ,
							lpTransCommandEx->WxParam , lpTransCommandEx->LxParam , lpTransCommandEx->SxParam , lpTransCommandEx->ExParam );
						Record_TempLogFile( szTemp );
					}
					////////////////////////////////////
				}
				else {
					if ( len ) {
						//물약을 얻어서 서버포션에 추가
						rsAddServerPotion( lpPlayInfo , lpTransCommandEx->WParam , len );
					}
/*
				//문제점이 있어서 일단 보류
					if ( lpTransCommandEx->WParam==(sinQT1|sin07) || lpTransCommandEx->WParam==(sinQT1|sin08) ) {
						//퀘스트 아이템 중복으로 입수됬는지 확인 ( 기존 아이템 삭제 )
						len = rsCheckInvenItem( lpPlayInfo , lpTransCommandEx->WParam );

						if ( len>=0 && len<INVEN_ITEM_INFO_MAX ) {
							lpPlayInfo->InvenItemInfo[len].dwCode = 0;
						}
					}
*/
					//인벤 아이템 추가
					rsAddInvenItem( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam );

					//아이템 로그 일반 아이템
					rsRecord_ItemLog( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam, ITEMLOG_GET );
				}

				lpsmSock->Send2( (char *)lpTransCommandEx , lpTransCommandEx->size , TRUE );
			}
			break;

		case smTRANSCODE_USEITEM_CODE:
			//사용한 아이템
			lpTransCommandEx = (smTRANS_COMMAND_EX *)SockInfo->Buff;

			//윙아이템 사라지는거 땜시 sinQW를 추가 했다
			if ( lpTransCommandEx->WParam>=sinPM1 && (lpTransCommandEx->WParam&sinITEM_MASK2)!=sinQW1 && 
				(lpTransCommandEx->WParam&sinITEM_MASK2)!=sinPZ1 && (lpTransCommandEx->WParam&sinITEM_MASK2)!=sinPZ2 &&
				(lpTransCommandEx->WParam&sinITEM_MASK2)!=sinCH1 ) {

				//인벤 아이템 제거
				rsDeleteInvenItem( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam );
				SaveThrowItem( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam );

				if ( (lpTransCommandEx->WParam&sinITEM_MASK2)==sinGP1 || 
					(lpTransCommandEx->WParam&sinITEM_MASK2)==sinBI1 ||
					(lpTransCommandEx->WParam&sinITEM_MASK2)==sinBC1 ) 
				{
					//사용한 아이템 로그 ( 몬스터 크리스탈 경품 응모 )
					rsRecord_ItemLog2( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam, ITEMLOG_USED );
				}
			}
			else {
				//사용할수 없는 아이템을 사용했다고 신고
				smTransCommand.WParam = 8060;
				smTransCommand.LParam = lpTransCommandEx->WParam;
				smTransCommand.SParam = lpTransCommandEx->LParam;
				smTransCommand.EParam = lpTransCommandEx->SParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
			}
			// pluto 선물상자

			if( (lpTransCommandEx->WParam&sinITEM_MASK2) ==sinSP1 )
			{
				if( (lpTransCommandEx->WParam & sinITEM_MASK3) == sin05 || (lpTransCommandEx->WParam & sinITEM_MASK3) == sin06 || (lpTransCommandEx->WParam & sinITEM_MASK3) == sin07 ||
					(lpTransCommandEx->WParam & sinITEM_MASK3) == sin08 || (lpTransCommandEx->WParam & sinITEM_MASK3) == sin09 || (lpTransCommandEx->WParam & sinITEM_MASK3) == sin10 )
				{
					rsPutItem_TreasureBox( lpPlayInfo, lpTransCommandEx->WParam );
				}
			}
			break;

		case smTRANSCODE_INVEN_POSITION:
			//인벤토리 아이템 위치 정보
			CheckInvenItemPosition( lpPlayInfo , (TRANS_USINGITEM *)SockInfo->Buff );
			break;
		case smTRANSCODE_INVEN_POSITION2:
			//인벤토리 아이템 위치 정보
			CheckInvenItemPosition2( lpPlayInfo , (TRANS_USINGITEM *)SockInfo->Buff );
			break;

		case smTRANSCODE_COMMAND_USER:
			//근처 유저에게 보내는 명령 도착
			rsSendCommandUser( lpPlayInfo , (smTRANS_COMMAND_EX	*)SockInfo->Buff );
			break;

		case smTRANSCODE_NSPRITE:
			//nSprite 중국판 보안프로그램
			cnt = nSprite_GetResult( ((smTRANS_COMMAND_DWORD *)SockInfo->Buff)->WParam );
			if ( cnt!=0 ) {
				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+((rand()%5)*1000)+1000*5;
				smTransCommand.WParam = 8130;
				smTransCommand.LParam = ((smTRANS_COMMAND *)SockInfo->Buff)->WParam;
				smTransCommand.SParam = cnt;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+10*1000;
			}
			lpPlayInfo->dwNSpriteTime = dwTime+3*60000;		//검사 유효 시간 ( 3분간 유효 )
			break;

#ifdef _npGAME_GUARD_AUTH
		case smTRANSCODE_GAMEGUARD_AUTH:
			//게임가드 상태 수신
			if ( lpPlayInfo->csa.CheckAuthDword( ((smTRANS_COMMAND_DWORD *)SockInfo->Buff)->WParam )==FALSE ) {
				smTransCommand.WParam = 8700;
				smTransCommand.LParam = ((smTRANS_COMMAND *)SockInfo->Buff)->WParam;
				smTransCommand.SParam = 0;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );

				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+10*1000;
			}

			lpPlayInfo->npGameGuard.Auth_Time = dwPlayServTime+rsServerConfig.GameGuard_Auth*(60*1000*3);		//3분 후에 다시검사
			lpPlayInfo->npGameGuard.Auth_Retry = 0;
			break;
#endif


		case smTRANSCODE_REC_DAMAGEDATA:
			//공격 데이타 기록 수치 비교
			rsCompAttackData( lpPlayInfo, (smTRANS_COMMAND *)SockInfo->Buff);
			break;

		case smTRANSCODE_SOD_RESULT:
			//SOD 결과 받음
			lpTransCommandEx = (smTRANS_COMMAND_EX *)SockInfo->Buff;

			if ( rsCheck_ResulSOD( lpPlayInfo , lpTransCommandEx )==lpTransCommandEx->ExParam ) {
				bSql_SODRecord( lpPlayInfo , lpTransCommandEx->WParam , lpTransCommandEx->LParam , lpTransCommandEx->SParam ,
					lpTransCommandEx->WxParam , lpTransCommandEx->LxParam , lpTransCommandEx->SxParam  , lpTransCommandEx->EParam );
			}
			break;

		case smTRANSCODE_SOD_RESULT2:
			//SOD 진행 상황 요구
			if ( rsServerConfig.Event_HardCore ) {

				if ( lpPlayInfo->EventMode==0 && lpPlayInfo->sEventParam[0]>=0 && lpPlayInfo->sEventParam[0]<4 )
					rsSod_GetRealTimeScore( lpPlayInfo , lpPlayInfo->sEventParam[0]+1 );	
				else
					rsSod_GetRealTimeScore( lpPlayInfo , 0 );	

			}
			break;

		case smTRANSCODE_PARTY_SKILL:
			//스킬 사용 정보를 파티원에게 보내기
			rsRecvSkillPartyUser( (TRANS_PARTY_SKILL *)SockInfo->Buff );
			break;

		case smTRANSCODE_PROCESS_SKILL:
			//스킬 사용 받음
			rsRecvProcessSkill( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_PROCESS_SKILL2:
			//스킬 사용 받음 ( 암호화 )
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			rsDecodeDamagePacket( lpPlayInfo , lpTransCommand );			//암호 해독

			cnt = lpTransCommand->LParam;
			lpTransCommand->LParam = lpPlayInfo->dwObjectSerial;
			if ( cnt==dm_GetCommandChkSum(lpTransCommand,lpPlayInfo->dwObjectSerial) ) {
				rsRecvProcessSkill( lpPlayInfo , lpTransCommand );
				break;
			}
			//데미지 데이타 오류를 군서버 로그에 기록 ( 스킬 사용 오류 )
			smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.WParam = 8500;
			smTransCommand.LParam = 3;
			smTransCommand.SParam = rsServerConfig.ServerCode;
			smTransCommand.EParam = lpPlayInfo->dwObjectSerial;
			rsRecordDamageError( lpPlayInfo , &smTransCommand );
			break;

		case smTRANSCODE_CANCEL_SKILL:
			//스킬취소
			rsCancelSkill( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_UPDATEL_SKILL:
			//스킬 변경 업데이트
			rsUpdateSkill( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_CLAN_SERVICE:
			//클랜 서비스 메세지
			lpTransCharCommand2 = (smTRANS_CHAR_COMMAND2 *)SockInfo->Buff;
			lpPlayInfo2 = srFindUserFromSerial( lpTransCharCommand2->LParam );
			if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
				lpPlayInfo2->lpsmSock->Send2( (char *)lpTransCharCommand2 , lpTransCharCommand2->size , TRUE );
			}
			break;

		case smTRANSCODE_CLAN_UPDATE:
			//클랜 업데이트 하기
			rsClanUpdate( lpPlayInfo ,(TRANS_CLAN_COMMAND_USER *)SockInfo->Buff );
			break;

		case smTRANSCODE_DEAD_USER:
			//플레이어 죽음
			//모든 스킬취소
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			if ( lpTransCommand->LParam==1 ) {
				//로그만 남김
				Record_DeadUser( lpPlayInfo , lpTransCommand );
				break;
			}

			if ( lpTransCommand->WParam ) {
				lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->WParam );

				if ( lpPlayInfo2 && lpPlayInfo2->Position.Area==rsCASTLE_FIELD ) {
					lpPlayInfo2->sBlessCastle_Damage[1] ++;		//플레이어 죽임
				}
				if ( !lpPlayInfo2 ) {
					lpChar = srFindCharFromSerial( lpTransCommand->WParam , lpPlayInfo->Position.Area );
					if ( lpChar && ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_DEATHKNIGHT || lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_KELVEZU || lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_MOKOVA) ) {
						//발렌토 한테 죽음
						smTransCommandEx.WParam = smCOMMNAD_USER_VALENTO;
						smTransCommandEx.LParam = lpChar->dwObjectSerial;
						smTransCommandEx.SParam = lpPlayInfo->dwObjectSerial;
						smTransCommandEx.EParam = 0;
						rsSendCommandUser( lpPlayInfo , &smTransCommandEx );			//이펙트 호출

						if ( lpChar->UseObject_VirtualLife ) {
							cnt = lpChar->sObject_VirtualLife[1]/3;
							lpChar->sObject_VirtualLife[0] += cnt;
							if ( lpChar->sObject_VirtualLife[0]>lpChar->sObject_VirtualLife[1] )
								lpChar->sObject_VirtualLife[0] = lpChar->sObject_VirtualLife[1];

							lpChar->smCharInfo.Life[0] = lpChar->smCharInfo.Life[1];
						}
					}
				}

			}
			smTransCommand.WParam = 0;
			rsCancelSkill( lpPlayInfo , &smTransCommand );
			break;

		case smTRANSCODE_CLIENTINFO:
			//클라이언트 정보 수신
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			lpTransCommand->WParam ^= ((DWORD *)(lpPlayInfo->szID+0))[0];
			lpTransCommand->LParam ^= ((DWORD *)(lpPlayInfo->szID+1))[0];
			lpTransCommand->SParam ^= ((DWORD *)(lpPlayInfo->szID+2))[0];
			lpTransCommand->EParam ^= ((DWORD *)(lpPlayInfo->szID+3))[0];

			lpPlayInfo->dwClentOS			= lpTransCommand->WParam;
			lpPlayInfo->wClentOSVersion[0]	= lpTransCommand->LParam>>16;
			lpPlayInfo->wClentOSVersion[1]	= lpTransCommand->LParam&0xFFFF;
			lpPlayInfo->dwClentModulChkSum	= lpTransCommand->SParam;
			lpPlayInfo->ClentModuleCount	= lpTransCommand->EParam;
			break;

		case smTRANSCODE_LIMIT_DAMAGE:
			//최대 데미지 보고
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			if ( !lpPlayInfo->dwObjectSerial ) break;

			rsDecodeDamagePacket( lpPlayInfo , lpTransCommand );			//암호 해독

			cnt = lpTransCommand->WParam;
			lpTransCommand->WParam = 0;
			if ( cnt==dm_GetCommandChkSum(lpTransCommand,lpPlayInfo->dwObjectSerial) ) {
				if ( !lpTransCommand->LParam && !lpTransCommand->SParam ) {
					//무기 없는 경우 
					lpPlayInfo->sLimitDamage[0] = 12;
					lpPlayInfo->sLimitDamage[1] = 15;
					lpPlayInfo->sLimitCritical[0] = 5;
				}
				else {
					lpPlayInfo->sLimitDamage[0] = (lpTransCommand->LParam*120)/100;
					lpPlayInfo->sLimitDamage[1] = (lpTransCommand->SParam*120)/100;
					lpPlayInfo->sLimitCritical[0] = (lpTransCommand->EParam*120)/100;
				}
			}
			else {
				//데미지 데이타 오류를 군서버 로그에 기록 ( 스킬 사용 오류 )
				smTransCommand.code = smTRANSCODE_SET_BLACKLIST;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = 8500;
				smTransCommand.LParam = 4;
				smTransCommand.SParam = rsServerConfig.ServerCode;
				smTransCommand.EParam = lpPlayInfo->dwObjectSerial;
				rsRecordDamageError( lpPlayInfo , &smTransCommand );
			}
			break;

		case smTRANSCODE_WARNING_CLIENT:
			//클라이언트로 부터의 경고
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			rsDecodeDamagePacket( lpPlayInfo , lpTransCommand );			//암호 해독

			cnt = lpTransCommand->EParam;
			lpTransCommand->EParam = 0;
			if ( cnt==dm_GetCommandChkSum(lpTransCommand,lpPlayInfo->dwObjectSerial)  ) {

				switch( lpTransCommand->WParam ) {
					case 100:
						//유저 속도오류
						smTransCommand.WParam = 8520;
						smTransCommand.LParam = ((smTRANS_COMMAND *)SockInfo->Buff)->LParam;
						smTransCommand.SParam = 0;
						RecordHackLogFile( lpPlayInfo , &smTransCommand );
/*
#ifndef _LANGUAGE_CHINESE
						if ( lpPlayInfo->AdminMode ) {
							//속도 오류 클라이언트에 출력
							wsprintf( TransChatMessage.szMessage , "속도오류 ( %d )" , smTransCommand.LParam );
							TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
							TransChatMessage.dwIP = 0;
							TransChatMessage.dwObjectSerial = 0;
							TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
							lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
						}
#endif
*/
						break;
					case 101:
						//스킬 공격 오류
						smTransCommand.WParam = 8530;
						smTransCommand.LParam = ((smTRANS_COMMAND *)SockInfo->Buff)->LParam;
						smTransCommand.SParam = 0;
						RecordHackLogFile( lpPlayInfo , &smTransCommand );
/*
#ifndef _LANGUAGE_CHINESE
						if ( lpPlayInfo->AdminMode ) {
							//속도 오류 클라이언트에 출력
							wsprintf( TransChatMessage.szMessage , "스킬오류 ( %d )" , smTransCommand.LParam );
							TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
							TransChatMessage.dwIP = 0;
							TransChatMessage.dwObjectSerial = 0;
							TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
							lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
						}
#endif
*/
						break;
				}
			}
			break;

		case smTRANSCODE_WARNING_SKILL:
			//스킬 경고
			if ( lpPlayInfo->WarningCount>3 ) break;

			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			rsDecodeDamagePacket( lpPlayInfo , lpTransCommand );			//암호 해독

			cnt = lpTransCommand->EParam;
			lpTransCommand->EParam = 0;
			if ( cnt==dm_GetCommandChkSum(lpTransCommand,lpPlayInfo->dwObjectSerial)  ) {
				smTransCommand.WParam = 8550;
				smTransCommand.LParam = lpTransCommand->WParam;
				smTransCommand.SParam = lpTransCommand->LParam;
				smTransCommand.EParam = lpTransCommand->SParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
			}
			break;

		case smTRANSCODE_ITEM_EXPRESS:
			//배달온 아이템 수신
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			SendOpenGiftExpress( lpPlayInfo , lpTransCommand->WParam , lpTransCommand->LParam );		//선물 배달
			break;

		case smTRANSCODE_YAHOO_MOTION:
			//야호 동작 실행
			rsRecvYahooMotion( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_STARPOINT:
			//별 포인트 정보
			rsRecvStarPoint( lpPlayInfo ,  (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_CLANMONEY:
			//클랜머니 데이타
			rsRecvSodClanCash( lpPlayInfo ,  (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_PAYMENT_MONEY:
			//사용요금을 받는다
			rsRecvPaymentMoney( lpPlayInfo ,  (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_GIVEMONEY:
			//돈 기부
			rsRecvGiveMoney( lpPlayInfo ,  (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		//case smTRANSCODE_DISPLAY_TEST:			//테스트용
		case smTRANSCODE_OPENLIVE:
			RecvOpenLivePacket( lpsmSock , SockInfo->Buff );

			/*
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			SockInfo->Buff[ lpTransCommand->size ] = 0;
			SetWindowText( hMsgTextWnd , SockInfo->Buff+8 );
			*/
			break;


		case smTRANSCODE_REC_ADMIN_COMMAND:
			//운영자 명령 저장
			lpTransChatMessage = (TRANS_CHATMESSAGE *)SockInfo->Buff;
			rsSaveAdminCommand( lpPlayInfo , lpTransChatMessage->szMessage , lpTransChatMessage->dwIP );
			rsCheckAdminPlayer( lpPlayInfo );		//관리자 인지 조사
			break;

		case smTRANSCODE_WARNING_BLINK_ATT:
			//무적모드 경고
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			smTransCommand.WParam = 8600;
			smTransCommand.LParam = lpTransCommand->WParam;
			smTransCommand.SParam = lpTransCommand->LParam;
			smTransCommand.EParam = lpTransCommand->SParam;
			RecordHackLogFile( lpPlayInfo , &smTransCommand );
			break;

		case smTRANSCODE_OPEN_MYSHOP:		//개인 상점 대오픈
			lpTransChatMessage = (TRANS_CHATMESSAGE *)SockInfo->Buff;
			if ( lpPlayInfo->szServerID[0] || rsServerConfig.DisableThrowItem ) break;													//멀티군 연동서버 거래금지
			lpTransChatMessage->szMessage[127] = 0;
			lstrcpy( lpPlayInfo->szTradeMessage , lpTransChatMessage->szMessage );
			lpPlayInfo->dwTradeMsgCode = lpTransChatMessage->dwIP;
			break;
		
		case smTRANSCODE_CALL_MYSHOP:		//개인 상점 정보 요구
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;

			if ( lpPlayInfo->szServerID[0] || rsServerConfig.DisableThrowItem ) break;													//멀티군 연동서버 거래금지
			lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->LParam );
			if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
				lpPlayInfo2->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
			}
			break;

		case smTRANSCODE_MYSHOP_ITEM:		//개인 상점 아이템 정보
			lpTransTradeItems = (TRANS_TRADEITEMS *)SockInfo->Buff;
			lpPlayInfo2 = srFindUserFromSerial( lpTransTradeItems->dwRecver );
			if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
				lpPlayInfo2->lpsmSock->Send( (char *)lpTransTradeItems , lpTransTradeItems->size , TRUE );
			}
			break;

		case smTRANSCODE_MYSHOP_TRADE:
			//개인 상점 물건 구입 (나중에 아이템 이동경로 파악하여 로그 및 서버인벤토리 설정 )
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			if ( lpPlayInfo->szServerID[0] || rsServerConfig.DisableThrowItem ) break;													//멀티군 연동서버 거래금지
			lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->LParam );
			if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
				//개인 상점 거래 처리
				if ( rsTrade_PersonalShop( lpPlayInfo , lpPlayInfo2 , (smTRANS_COMMAND_BUFF *)SockInfo->Buff )==TRUE ) {
					lpPlayInfo2->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
				}
			}
			break;

		case smTRANSCODE_MYSHOP_MESSAGE:
			//개인상점 메세지 얻기
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->LParam );

			if ( lpPlayInfo->szServerID[0] || rsServerConfig.DisableThrowItem ) break;													//멀티군 연동서버 거래금지
			if ( lpPlayInfo2 && lpPlayInfo2->dwTradeMsgCode && lpPlayInfo2->dwTradeMsgCode==lpTransCommand->SParam ) {
				lstrcpy( TransChatMessage.szMessage , lpPlayInfo2->szTradeMessage );
				TransChatMessage.code = smTRANSCODE_MYSHOP_MESSAGE;
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = lpTransCommand->LParam;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			}
			break;

		case smTRANSCODE_FORCEORB_DATA:
			//포스 오브 데이타 군서버에서 정보 받음
			rsRecvAreaServerForceOrb( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_PRIMEITEM_DATA:
			//게임 서버가 빌링아이템 정보 입수
			rsRecvGameServer_PrimeItem( lpPlayInfo , (smTRANS_COMMAND_EX *)SockInfo->Buff );
			break;

		case smTRANSCODE_PCBANG_PET:
			rsRecvAreaServer_PCBangPet( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_QUEST_COMMAND:
			//퀘스트 진행 명령
			rsGetQuestCommand( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_BLESSCASTLE_INFO:
			//블래스캐슬 설정정보 수신
			rsRecvBlessCastInfo( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_BLESSCASTLE_TAX:
			//블레스캐슬 정보 게임서버로부터 받기
			rsRecvBlessCastleInfoFromGameServer( lpPlayInfo , (smTRANS_COMMAND_EX *)SockInfo->Buff );
			break;

		case smTRANSCODE_UPDATE_SERVER_PARAM:
			//다른서버에서의 업데이트
			rsRecvUpdateServerParam( lpPlayInfo , (smTRANS_COMMAND *)SockInfo->Buff );
			break;

		case smTRANSCODE_RESISTANCE:
			//속성정보 받음
			memcpy( lpPlayInfo->smCharInfo.Resistance , ((smTRANS_RESISTANCE *)SockInfo->Buff)->Resistance , sizeof(short)*8 );
			for(cnt=0;cnt<8;cnt++) 
			{
				if ( lpPlayInfo->smCharInfo.Resistance[cnt]>100 || lpPlayInfo->smCharInfo.Resistance[cnt]<-100 )
					lpPlayInfo->smCharInfo.Resistance[cnt] = 0;
			}

			//흡수력
			cnt = ((smTRANS_RESISTANCE *)SockInfo->Buff)->Absorb;
			if ( cnt>=0 && cnt<1000 )
				lpPlayInfo->smCharInfo.Absorption = cnt;
			break;

		case smTRANSCODE_PUBLIC_POLLING:
			//설문조사 정보 패킷
			/*
				//사용법 예제
				smTransCommand.WParam = lpChar->smMonsterInfo.PollingNpc;

				if ( smTransCommand.LParam==0 ) {
					//설문조사 가능여부 확인후 설문지 배포 (지역서버에서 온 패킷인 경우다)
				}
				else {
					//설문지 결과 통보 (클라이언트)
				}
			*/

			//일단 테스트
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			if ( lpTransCommand->LParam==0 ) {
				//설문조사 가능여부 확인후 설문지 배포 (지역서버에서 온 패킷인 경우다)
				//lpTransCommand->LParam = 1;
				//lpPlayInfo->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
				bSql_PollRecord( lpPlayInfo , lpTransCommand->WParam , 0, 0 );
			}
			else {
				//설문지 결과 통보 (클라이언트)
				bSql_PollRecord( lpPlayInfo , lpTransCommand->WParam , lpTransCommand->LParam ,
					((smTRANS_COMMAND_POLLING *)SockInfo->Buff)->bPolling );
			}
			break;

//#ifdef _LANGUAGE_VEITNAM
		case smTRANSCODE_USER_ID:	//계정정보 획득 (베트남)
			rsRecvUserID_MainServer( lpPlayInfo , (smTRANS_CHAR_COMMAND2 *)SockInfo->Buff );
			break;
//#endif

		case smTRANSCODE_HACKTRAP:	//해킹용 함정
			rsRecvHackTrap( lpPlayInfo, (smTRANS_COMMAND *)SockInfo->Buff );
			break;
		case smTRANSCODE_SMELTINGITEM:
			// pluto 제련 아이템 받음
			rsRecvSmeltingItem( lpPlayInfo, (sSMELTINGITEM_SERVER *)SockInfo->Buff );
			break;
		case smTRANSCODE_MANUFACTURE:
			// pluto 제작 아이템 받음
			rsRecvManufactureItem( lpPlayInfo, ( SManufactureItem_Server *)SockInfo->Buff );
			break;
#ifdef _CHECK_MESH
		case smTRANSCODE_CHECK_ITEMMESH:	////아이템메쉬 조작검사 결과값 수신
			rsRecvCheckItemMesh( lpPlayInfo, (smTRANS_COMMAND *)SockInfo->Buff );
#endif

#ifdef _xTrap_GUARD
		case smTRANSCODE_XTRAP_PACKET:	//XTrap 패킷수신
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			switch(lpTransCommand->WParam)
			{
			case smXTRAP_COMMAND_LOGIN:
				break;
			case smXTRAP_COMMAND_SECURITY:
				rsXTrap_RecvSecurity(lpPlayInfo , (smTRANS_XTRAP_SECURITY *)lpTransCommand );
				break;
			}
			break;
#endif

		case smTRANSCODE_MANUFACTURE_WEIGHT_PRICE:	// pluto 제작 아이템 가격, 무게 정보 가져 올려고
			ManufactureItemInfo( lpPlayInfo );
			break;

		case smTRANSCODE_PRIMEITEM_DATA2:		// pluto 마나 리듀스 포션 마이트 오브 아웰	마이트 오브 아웰2
			rsRecvGameServer_PrimeItem2( lpPlayInfo , (smTRANS_COMMAND_EX *)SockInfo->Buff );
			break;

#ifdef _XTRAP_GUARD_4_SERVER
		case smTRANSCODE_XTRAP_PACKET:	//XTrap 패킷수신
			lpTransCommand = (smTRANS_COMMAND *)SockInfo->Buff;
			rsXTrap_RecvPacket( lpPlayInfo , lpTransCommand );
			break;
#endif
	}

quit:
	if ( lpPlayInfo ) lpPlayInfo->dwLastRecvTime = dwTime;

	//크리티칼 섹션 해제
	LeaveCriticalSection( &cSerSection );

#endif

	return TRUE;
}


//접속자 리스트 제작
int MakePlayerList()
{
	int cnt;
	int ListCnt;

	PlayerCount = 0;
	ListCnt=2;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( smWSock[cnt].sock ) {
			ListBuff[ListCnt++] = smWSock[cnt].acc_sin.sin_addr.S_un.S_addr;
			PlayerCount++;
		}
	}

	ListBuff[0] = ListCnt*sizeof(DWORD);
	ListBuff[1] = smTRANSCODE_IPLIST;

	return ListBuff[0];
}

//창에 상태 표시
void DisplayMessage()
{
#ifdef _W_SERVER
//ActivePlayCounter
//AutoPlayServer
	int cnt;
	int SockCnt;
	int	pCnt=0;
	DWORD pTimeMax=0;
	DWORD pAvgTime=0;

	SockCnt = 1000;
	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( smWSock[cnt].sock || smWSock[cnt].lpsmRecvRoute || smWSock[cnt].lpsmSendRoute) {
			SockCnt++;
		}
	}
//보내기 쓰레드의 사용 상태 구함
//int GetUseingSendThreadCount()
//받기 쓰레드의 사용 상태 구함
//int GetUseingRecvThreadCount()

	cnt = rsGetUserCounter( PlayerCount );

	if ( ShutDownFlag ) {
		wsprintf( szMessageBuff , "ShutDown Service (%d)\r\nClosing Server\r\nLeft %d Min.\r\n" ,cnt , ShutDownLeftTime+1 );
		SetWindowText( hMsgTextWnd , szMessageBuff );
		return;
	}

	szMessageBuff[0] = 0;
	pCnt = b_SqlGetQueProcessTime( &pTimeMax , &pAvgTime );

	switch( Svr_DisplayMode ) {

		case 0:

			if ( AutoPlayServer || UserPlayServer ) {
		#ifdef	_LANGUAGE_KOREAN
				if ( LoginServer ) {
					//pCnt = b_SqlGetQueProcessTime( &pTimeMax , &pAvgTime );

					wsprintf( szMessageBuff, "데이타 서버모드\r\n접속자 : %d\r\n인증실패: %d\r\n인증쓰레드: %d/%d Proc(%d)\r\n최근인증: %s (%d)\r\n인증큐: %d\r\n로그큐 사용율: %d\r\n로그큐 처리: %d/ Avg(%d) Max(%d)\r\n로그큐 실패 : %d\r\n아이템로그 : 사용(%d) 실패(%d)\r\n이벤트로그 : 사용(%d) 실패(%d)\r\n",
					cnt ,srLogFailedCount ,
					LogOnThread_Sucess,LogOnThread_Count,LogOnThread_Process,
					szLastLogInID ,	LastLogInResult,
					rsGetLogOnQueCount(),
					b_SqlGetQueSize(), pCnt , pAvgTime , pTimeMax ,
					b_SqlGetLossCount(),
					b_SqlGetItemQueSize() , b_SqlGetItemLossCount() ,
					b_SqlGetEventQueSize() , b_SqlGetEventLossCount() );
				}
				else {
					wsprintf( szMessageBuff, "접속자 현황\r\n현재 접속인원 : %d명\r\n활동 몬스터 : %d\r\n받은메세지 : %d\r\n연결상태: ( Snd:%d Rcv:%d )\r\n라우트오류: %d\r\n연결오류 : %d (%d)" ,
						cnt,ActivePlayCounter,  WSA_RecvMsgCount,
						GetUseingSendThreadCount() , GetUseingRecvThreadCount() ,
						srRouteErrorCount,
						srAcceptErrorCount , srLastAcceptRsult );
				}

		#else

				wsprintf( szMessageBuff, "Server State\r\nUsers : %d\r\nMonsters: %d\r\nRecvMsg : %d\r\nThread: ( Snd:%d Rcv:%d )\r\nRouteError: %d\r\nConnectError : %d (%d)" ,
					cnt,ActivePlayCounter,  WSA_RecvMsgCount,
					GetUseingSendThreadCount() , GetUseingRecvThreadCount() ,
					srRouteErrorCount,
					srAcceptErrorCount , srLastAcceptRsult );

		#endif

//				WSA_RecvMsgCount = 0;
//				srRouteErrorCount = 0;
			}
			else {

		#ifdef	_LANGUAGE_KOREAN

					//pCnt = b_SqlGetQueProcessTime( &pTimeMax , &pAvgTime );

					wsprintf( szMessageBuff, "데이타 서버모드\r\n접속자 : %d\r\n인증실패: %d\r\n인증쓰레드: %d/%d Proc(%d)\r\n최근인증: %s (%d)\r\n인증큐: %d\r\n로그큐 사용율: %d\r\n로그큐 처리: %d/ Avg(%d) Max(%d)\r\n로그큐 실패 : %d\r\n아이템로그 : 사용(%d) 실패(%d)\r\n이벤트로그 : 사용(%d) 실패(%d)\r\n",
					cnt ,srLogFailedCount ,
					LogOnThread_Sucess,LogOnThread_Count,LogOnThread_Process,
					szLastLogInID ,	LastLogInResult,
					rsGetLogOnQueCount(),
					b_SqlGetQueSize(), pCnt , pAvgTime , pTimeMax ,
					b_SqlGetLossCount(),
					b_SqlGetItemQueSize() , b_SqlGetItemLossCount() ,
					b_SqlGetEventQueSize() , b_SqlGetEventLossCount() );

		#else
					//wsprintf( szMessageBuff, "Data Server Mode\r\nBuffer State : %d" ,cnt );
					wsprintf( szMessageBuff, "[Login Server]\r\nUsers : %d\r\nLogin Failed: %d\r\nLogin Thread: %d/%d Proc(%d) DLL_Code(%d)\r\nLast Login: %s (%d)\r\nLogin Que: %d\r\nLogQue Using: %d\r\nLogQue Process: %d/ Avg(%d) Max(%d)\r\nLogQue Failed: %d\r\nItem Log: Using(%d) Failed(%d)\r\nEvent Log: Using(%d) Failed(%d)\r\n",
					cnt ,srLogFailedCount ,
					LogOnThread_Sucess,LogOnThread_Count,LogOnThread_Process,UseDLL_Code,
					szLastLogInID ,	LastLogInResult,
					rsGetLogOnQueCount(),
					b_SqlGetQueSize(), pCnt , pAvgTime , pTimeMax ,
					b_SqlGetLossCount(),
					b_SqlGetItemQueSize() , b_SqlGetItemLossCount() ,
					b_SqlGetEventQueSize() , b_SqlGetEventLossCount() );
		#endif
			}
			break;

		case 1:
			//게임정보
#ifdef	_LANGUAGE_KOREAN
			wsprintf( szMessageBuff, "[게임정보]\r\n경험치발생: %d\r\n몬스터발생: %d\r\n아이템발생: %d [Mny %d]\r\n아이템버퍼초과: %d\r\n",
				rsMonHuntCount, rsMonOpenCount, rsItemOpenCount, rsMoneyTotalCount , rsItemBuffOverCount );
				
#else
			wsprintf( szMessageBuff, "[Game Infomation]\r\nExp Count: %d\r\nOp.Monster: %d\r\nItem: %d [Mny %d]\r\nItemBuffOver: %d\r\n",
				rsMonHuntCount, rsMonOpenCount, rsItemOpenCount, rsMoneyTotalCount,rsItemBuffOverCount );

#endif
			break;

		case 2:
			//설정정보
#ifdef	_LANGUAGE_KOREAN
			wsprintf( szMessageBuff, "[설정정보]\r\n서버코드: %d\r\n서버이름: %s\r\n제한버전: %d - %d\r\n보호코드설정: %d개\r\n접속코드설정: %d개\r\n몬스터: %d\r\n아이템: %d\r\n",
				rsServerConfig.ServerCode, rsServerConfig.szServerName, rsServerConfig.LimitVersion, rsServerConfig.LimitVersionMax,
				rsServerConfig.SafeClientCodeCount , rsServerConfig.ClientCheckSumCount, chrMonsterCnt, DefaultItemCount );				
#else
			wsprintf( szMessageBuff, "[Confguation]\r\nServer Code: %d\r\nServerName: %s\r\nVersion: %d - %d\r\nSafeCode Count: %d\r\nCheckSum Count: %d\r\nMonster: %d\r\nItem: %d",
				rsServerConfig.ServerCode, rsServerConfig.szServerName, rsServerConfig.LimitVersion, rsServerConfig.LimitVersionMax,
				rsServerConfig.SafeClientCodeCount , rsServerConfig.ClientCheckSumCount, chrMonsterCnt, DefaultItemCount );				

#endif
			break;
				
		case 3:
			//지역정보
#ifdef	_LANGUAGE_KOREAN
			wsprintf( szMessageBuff, "[지역정보]\r\n[Aser]라인: %d\r\n[Aser]상태확인: %d\r\n[Aser]연결: %d (%d)\r\n[Aser]처리: %d",
				rsGetSystemLineCount(), rsSystemNetCount, rsSystemLineConnCount, rsSystemLineFailedCount, rsSystemLinePlayCount );
				
#else
			wsprintf( szMessageBuff, "[Area Infomation]\r\n[Aser]Line: %d\r\n[Aser]NetState.: %d\r\n[Aser]Conn.: %d (%d)\r\n[Aser]Process: %d",
				rsGetSystemLineCount(), rsSystemNetCount, rsSystemLineConnCount, rsSystemLineFailedCount, rsSystemLinePlayCount );

#endif
			break;

	}

	WSA_RecvMsgCount = 0;
	srRouteErrorCount = 0;
	SetWindowText( hMsgTextWnd , szMessageBuff );
#endif
}

//새 클라이언트 접속
int Serv_ConnectPlayer( smWINSOCK *lpsmSock )
{

	//크리티칼 섹션 선언
	EnterCriticalSection( &cSerSection );

	PlayerCount++;

	AddNewPlayInfo( lpsmSock );

	//크리티칼 섹션 해제
	LeaveCriticalSection( &cSerSection );


	//ListCnt = MakePlayerList();
	//lpsmSock->Send( (char *)&ListBuff , ListCnt );
	//DisplayMessage();

	return TRUE;
}

//미 저장된 버려진 아이템 저장
int RecordSaveThrowData( rsPLAYINFO *lpPlayInfo )
{
	/*
	rsRECORD_DBASE	RecordBase;
	return RecordBase.SaveThrowData( lpPlayInfo->szName , lpPlayInfo->ThrowItemInfo  , lpPlayInfo->ThrowItemCount , lpPlayInfo->UnsaveMoney ); 
	*/
	return TRUE;
}

//메모리 저장이 안된 데이타를 확인하여 재 저장
int rsRecordCheckFile( rsPLAYINFO *lpPlayInfo )
{
	FILE	*fp;
	char	*lpBuff;
	char	szFile[64];
	int		result;
	smTRANS_COMMAND	smTransCommand;


	result = FALSE;

	if ( !lpPlayInfo ) return FALSE;
	if ( !lpPlayInfo->lpRecordDataBuff || !lpPlayInfo->szID[0] || !lpPlayInfo->szName[0] ) return FALSE;

	lpBuff = lpPlayInfo->lpRecordDataBuff;
	lpPlayInfo->lpRecordDataBuff = new char[sizeof(TRANS_RECORD_DATA)];
	if ( lpPlayInfo->lpRecordDataBuff ) {
		GetUserDataFile( lpPlayInfo->szName , szFile );
		fp = fopen( szFile , "rb" );
		if ( fp ) {
			fread( lpPlayInfo->lpRecordDataBuff , sizeof(TRANS_RECORD_DATA) , 1, fp );
			fclose( fp );

			if ( ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->code &&
				((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size>0 ) {

					//버려진 아이템 메모리버퍼 데이타에 저장 
					rsSaveThrowData( lpPlayInfo );
					//저장할 메모리버퍼의 아이템이 올바른지 전부 확인
					rsRecordMemoryBuff_CheckInvenItem( lpPlayInfo );
					//파일 재 저장
					rsRecordMemoryBuffToFile( lpPlayInfo , lpPlayInfo->szName , lpPlayInfo->lpRecordDataBuff );

//
					smTransCommand.WParam = 8400;
					smTransCommand.LParam = ((TRANS_RECORD_DATA *)lpPlayInfo->lpRecordDataBuff)->size;
					smTransCommand.SParam = 0;
					smTransCommand.EParam = 0;
					RecordHackLogFile( lpPlayInfo , &smTransCommand );

					result = TRUE;
				}
		}
		delete	lpPlayInfo->lpRecordDataBuff;
	}
	lpPlayInfo->lpRecordDataBuff = lpBuff;

	return result;
}



//클라이언트 끈김
int Serv_DisconnectPlayer( smWINSOCK *lpsmSock )
{
	rsPLAYINFO *tpInfo;
	int cnt;
	smTRANS_COMMAND	smTransCommand;

	if ( !lpsmSock ) return TRUE;
	if ( !lpsmSock->sock ) return TRUE;

	//크리티칼 섹션 선언
	EnterCriticalSection( &cSerSection );

	PlayerCount--;

	tpInfo = (rsPLAYINFO *)lpsmSock->ExtData1;

	//디버그용 ( 임시 )
	if ( LoginServer && tpInfo ) {
		dwServer_DebugMessage = 100;
		lstrcpy( szServer_DebugLastUserID , tpInfo->szID );
		lstrcpy( szServer_DebugLastUserName , tpInfo->szName );
	}
	Server_DebugCount = 100;

	if ( tpInfo->lpRecordDataBuff && tpInfo->szID[0] && tpInfo->szName[0] &&
		((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->size>0 ) {

		((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->smCharInfo.szName[31] = 0;
		if ( lstrcmpi( ((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->smCharInfo.szName , tpInfo->szName )==0 ) {

			if ( rsServerConfig.ServerInventoryMode ) {
				Server_DebugCount = 101;
				//버려진 아이템 메모리버퍼 데이타에 저장 
				rsSaveThrowData( tpInfo );
				Server_DebugCount = 102;
				//저장할 메모리버퍼의 아이템이 올바른지 전부 확인
				rsRecordMemoryBuff_CheckInvenItem( tpInfo );
			}

			Server_DebugCount = 103;

			//메모리 버퍼를 파일로 저장
			for(cnt=0;cnt<6;cnt++) {
				if ( rsRecordMemoryBuffToFile( tpInfo , tpInfo->szName , tpInfo->lpRecordDataBuff )==TRUE ) break;

				//저장 오류 기록
				smTransCommand.WParam = 8080;
				smTransCommand.LParam = 1;
				smTransCommand.SParam = cnt;
				smTransCommand.EParam = ((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->size;
				RecordHackLogFile( tpInfo , &smTransCommand );
			}
			((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->size = 0;

		}
		else {
			smTRANS_COMMAND smTransCommand;
			smTransCommand.WParam = 10000;
			smTransCommand.LParam = (DWORD)tpInfo->smCharInfo.szName;
			smTransCommand.SParam = (DWORD)((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->smCharInfo.szName;
			RecordHackLogFile( tpInfo , &smTransCommand );
		}
	}
	else {
		//메모리 저장이 안된 데이타를 확인하여 재 저장
		rsRecordCheckFile( tpInfo );
	}



	Server_DebugCount = 104;

	tpInfo->DisconnectPartyUser();				//파티 연결 종료

	rsLogOut( tpInfo );							//로그 아웃

	tpInfo->lpsmSock = 0;
	if ( tpInfo->lpAreaPlayInfo ) {
		*tpInfo->lpAreaPlayInfo	= 0;
		tpInfo->lpAreaPlayInfo = 0;
	}
	if ( tpInfo->lpRecordBase ) {
		delete tpInfo->lpRecordBase;
		tpInfo->lpRecordBase = 0;
	}
	if ( tpInfo->lpPostBoxItem ) {
		rsSavePostBox( tpInfo );		//아이템 우편 저장
		delete	tpInfo->lpPostBoxItem;
		tpInfo->lpPostBoxItem = 0;
	}

	Server_DebugCount = 105;

	if ( ( tpInfo->ThrowItemCount>0 || tpInfo->UnsaveMoney>=0 ) && tpInfo->szName[0] ) 
		RecordSaveThrowData( tpInfo );

	if ( tpInfo->SystemLine ) {
		//시스템 회선 연결 종료 ( 다른서버와의 연결 )
		rsDisconnectSystemLine( lpsmSock );
		if ( tpInfo->SystemLine==2 )	rsSetSerToLoginLine();				//로긴 라인 버퍼에 설정
	}


/*
	if ( tpInfo->szID[0] ) {
		
		if (  tpInfo->szName[0] ) {
			//DB LOG 기록
			RecordLogSql( LOG_SQL_LOGOUT ,lpsmSock->szIPAddr , tpInfo->szID , tpInfo->szName , 1 , tpInfo->smCharInfo.JOB_CODE , tpInfo->smCharInfo.Exp , tpInfo->smCharInfo.Level , tpInfo->smCharInfo.Money );
		}

		// Game Log 기록
		RecordGameLogSql( GAMELOG_SQL_LOGOUT ,lpsmSock->szIPAddr , tpInfo->szID , tpInfo->szName ,
				tpInfo->smCharInfo.JOB_CODE,  tpInfo->Guid );


	}
*/
	Server_DebugCount = 190;

	//크리티칼 섹션 해제
	LeaveCriticalSection( &cSerSection );

	return TRUE;
}


extern CRITICAL_SECTION	cSocketSection;


//클라이언트 끈김 ( 크리티칼 사용 안함 )
int DisconnectUser( smWINSOCK *lpsmSock )
{
	rsPLAYINFO *tpInfo;

	DWORD	dwExitCode;
	int SecFlag;
	int cnt;
	smTRANS_COMMAND	smTransCommand;


	if ( !lpsmSock ) return TRUE;
	if ( !lpsmSock->sock ) return TRUE;

	if ( cSocketSection.OwningThread ) SecFlag = FALSE;
	else SecFlag = TRUE;

	//소켓용 크리티칼 섹션 선언
	if ( SecFlag ) smEnterCSectionSocket();

	PlayerCount--;

	tpInfo = (rsPLAYINFO *)lpsmSock->ExtData1;

	//디버그용 ( 임시 )
	if ( LoginServer && tpInfo ) {
		dwServer_DebugMessage = 200;
		lstrcpy( szServer_DebugLastUserID , tpInfo->szID );
		lstrcpy( szServer_DebugLastUserName , tpInfo->szName );
	}
	Server_DebugCount = 200;

	if ( tpInfo && tpInfo->lpsmSock==lpsmSock ) {

		//메모리 버퍼를 파일로 저장
		//rsRecordMemoryBuffToFile( tpInfo->szName , tpInfo->lpRecordDataBuff  );

		if ( tpInfo->lpRecordDataBuff && tpInfo->szID[0] && tpInfo->szName[0] &&
			((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->size>0 ) {

			((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->smCharInfo.szName[31] = 0;
			//메모리 버퍼를 파일로 저장
			if ( lstrcmpi( ((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->smCharInfo.szName , tpInfo->szName )==0 ) {

				if ( rsServerConfig.ServerInventoryMode ) {
					Server_DebugCount = 201;

					//버려진 아이템 메모리버퍼 데이타에 저장 
					rsSaveThrowData( tpInfo );

					Server_DebugCount = 202;

					//저장할 메모리버퍼의 아이템이 올바른지 전부 확인
					rsRecordMemoryBuff_CheckInvenItem( tpInfo );
				}

				Server_DebugCount = 203;

				for(cnt=0;cnt<6;cnt++) {
					if ( rsRecordMemoryBuffToFile( tpInfo , tpInfo->szName , tpInfo->lpRecordDataBuff )==TRUE ) break;

					//저장 오류 기록
					smTransCommand.WParam = 8080;
					smTransCommand.LParam = 2;
					smTransCommand.SParam = cnt;
					smTransCommand.EParam = ((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->size;
					RecordHackLogFile( tpInfo , &smTransCommand );
				}
				((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->size = 0;

			}
			else {
				smTRANS_COMMAND smTransCommand;
				smTransCommand.WParam = 10001;
				smTransCommand.LParam = (DWORD)tpInfo->smCharInfo.szName;
				smTransCommand.SParam = (DWORD)((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->smCharInfo.szName;
				RecordHackLogFile( tpInfo , &smTransCommand );
			}
		}
		else {
			//파일에서 직접 읽어 들여 메모리 검사후 저장
			//메모리 저장이 안된 데이타를 확인하여 재 저장
			rsRecordCheckFile( tpInfo );
		}

/*
		if ( tpInfo->lpRecordDataBuff ) {
			//메모리 버퍼를 파일로 저장
			if ( rsRecordMemoryBuffToFile( tpInfo->szName , tpInfo->lpRecordDataBuff  )==TRUE ) {
				if ( lstrcmpi( tpInfo->szName , ((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->smCharInfo.szName )!=0 ||
					lstrcmpi( tpInfo->szName , tpInfo->smCharInfo.szName )!=0 ) {

					smTRANS_COMMAND smTransCommand;
					smTransCommand.WParam = 10001;
					smTransCommand.LParam = (DWORD)tpInfo->smCharInfo.szName;
					smTransCommand.SParam = (DWORD)((TRANS_RECORD_DATA *)tpInfo->lpRecordDataBuff)->smCharInfo.szName;
					RecordHackLogFile( tpInfo , &smTransCommand );

				}
			}
		}
*/
		Server_DebugCount = 204;

		tpInfo->DisconnectPartyUser();				//파티 연결 종료


		rsLogOut( tpInfo );							//로그 아웃

		tpInfo->lpsmSock = 0;
		if ( tpInfo->lpAreaPlayInfo ) {
			*tpInfo->lpAreaPlayInfo	= 0;
			tpInfo->lpAreaPlayInfo = 0;
		}
		if ( tpInfo->lpRecordBase ) {
			delete tpInfo->lpRecordBase;
			tpInfo->lpRecordBase = 0;
		}
		if ( tpInfo->lpPostBoxItem ) {
			rsSavePostBox( tpInfo );		//아이템 우편 저장
			delete	tpInfo->lpPostBoxItem;
			tpInfo->lpPostBoxItem = 0;
		}

		Server_DebugCount = 205;

		if ( (tpInfo->ThrowItemCount>0 || tpInfo->UnsaveMoney>=0 ) && tpInfo->szName[0] ) 
			RecordSaveThrowData( tpInfo );

		if ( tpInfo->SystemLine ) {
			//시스템 회선 연결 종료 ( 다른서버와의 연결 )
			rsDisconnectSystemLine( lpsmSock );
			if ( tpInfo->SystemLine==2 )	rsSetSerToLoginLine();				//로긴 라인 버퍼에 설정
		}

	}

	Server_DebugCount = 290;

	if ( !smTransThreadMode ) {

		lpsmSock->smSendState.dwExitThread = TRUE;
		ResumeThread( lpsmSock->hSendThread );

		lpsmSock->smRecvState.dwExitThread = TRUE;
		ResumeThread( lpsmSock->hRecvThread );

		//hSendThread 종료 대기
		WaitForSingleObject( lpsmSock->hSendThread , 5000 );
		GetExitCodeThread( lpsmSock->hSendThread , &dwExitCode );

		if ( dwExitCode==STILL_ACTIVE ) {
			lpsmSock->smSendState.dwExitThread = TRUE;
			ResumeThread( lpsmSock->hSendThread );

			WaitForSingleObject( lpsmSock->hSendThread , 5000 );
			GetExitCodeThread( lpsmSock->hSendThread , &dwExitCode );

			if ( dwExitCode==STILL_ACTIVE ) {
				TerminateThread( lpsmSock->hSendThread , 1 );
			}
		}

		//hRecvThread 종료 대기
		WaitForSingleObject( lpsmSock->hRecvThread , 5000 );
		GetExitCodeThread( lpsmSock->hRecvThread , &dwExitCode );

		if ( dwExitCode==STILL_ACTIVE ) {
			lpsmSock->smRecvState.dwExitThread = TRUE;
			ResumeThread( lpsmSock->hRecvThread );

			WaitForSingleObject( lpsmSock->hRecvThread , 5000 );
			GetExitCodeThread( lpsmSock->hRecvThread , &dwExitCode );

			if ( dwExitCode==STILL_ACTIVE ) {
				TerminateThread( lpsmSock->hRecvThread , 1 );
			}
		}
	}
	else {
		//큐에 대기중인 소켓을 찾아 제거한다
		ClearTransQueSocket( lpsmSock );
	}
 

	ClearPacketSendQue( lpsmSock );

	closesocket( lpsmSock->sock );
	lpsmSock->sock = 0;

	//소켓용 크리티칼 섹션 해제
	if ( SecFlag ) smLeaveCSectionSocket();

	return TRUE;
}

//ShutDown 로그 생성
int RecordShutdownLog( int LogCode , int LParam , int SParam )
{
	smTRANS_COMMAND smTransCommand;

	smTransCommand.WParam = LogCode;
	smTransCommand.LParam = LParam;
	smTransCommand.SParam = SParam;
	RecordHackLogFile( 0 , &smTransCommand );

	return TRUE;
}



DWORD dwTimeCounter = 0;

static LONG APIENTRY WndProc(HWND hWnd,UINT messg,WPARAM wParam,LPARAM lParam)
{
	int cnt;
	DWORD dwOldTime;

	switch (messg)
	{
		case WM_CREATE:
			hMsgTextWnd=CreateWindow( "EDIT","",
						WS_BORDER|WS_CHILD|WS_VISIBLE|ES_AUTOVSCROLL|ES_LEFT|ES_MULTILINE|ES_READONLY,
						16,16,
						320-32,240-32,
						hWnd,(HMENU)ID_MESSTEXT,
						hInst,NULL);

			MoveWindow( hMsgTextWnd, 16, 16, 320-32, 200-32 , TRUE );
			ShowWindow(hMsgTextWnd,SW_SHOW);

#ifdef	_LANGUAGE_KOREAN
			hServerFont = CreateFont( 13,
										0,
										0,
										0,
										FW_NORMAL,
										FALSE,
										FALSE,
										FALSE,
										HANGEUL_CHARSET,
										OUT_DEFAULT_PRECIS,
										CLIP_DEFAULT_PRECIS,
										DEFAULT_QUALITY,
										VARIABLE_PITCH,
										"굴림체" );

		    SendMessage( hMsgTextWnd, WM_SETFONT, (WPARAM)hServerFont, 0L);
#endif

			wsprintf( szMessageBuff , "System Initializing ( %d )" , CONNECTMAX );
			//lstrcpy( szMessageBuff , "게임서버\r\n실행 준비중" );

			SetWindowText( hMsgTextWnd , szMessageBuff );

			//크리티칼 섹션 초기화
			InitializeCriticalSection( &cSerSection );
			InitializeCriticalSection( &cOdbcSection );

			break;

		case WSA_ACCEPT: /* Notification if a socket connection is pending. */
			cnt = WSAMessage_Accept( wParam , lParam );
			if ( cnt!=TRUE ) {
				//업셉트 오류 확인
				srAcceptErrorCount++;
				srLastAcceptRsult = cnt;
			}
			break;   /* WSA_ACCEPT */

		case WSA_READ:
			WSAMessage_Read( wParam , lParam );
			WSA_RecvMsgCount++;
			break;       /* WSA_READ*/

		case SWM_SENDSUCCESS:
			break;

		case SWM_RECVSUCCESS:
			//채팅데이타 클라이언트로 전송
			RecvMessage( (smTHREADSOCK *)wParam );
			break;

		case WM_CLOSE:
			ShowWindow(hWnd,SW_HIDE);
			break;
		case WM_KEYDOWN :
			break;

		case WM_KEYUP :
			break;

		case WM_CHAR:
			break;

		case WM_LBUTTONDOWN:
/*
				msock = socket( AF_INET, SOCK_STREAM, 0);
				if (msock == INVALID_SOCKET) break;

			    dest_sin.sin_family = AF_INET ;
				dest_sin.sin_addr.S_un.S_addr = inet_addr ( "210.122.37.103" );
				dest_sin.sin_port = htons((u_short) 25 ) ;

				if (connect( msock, (PSOCKADDR) &dest_sin, sizeof( dest_sin)) ==SOCKET_ERROR) {
					{ closesocket( msock ); break; }


				wsprintf( szTemp , "helo" );
				if (send (msock, szTemp, lstrlen( szTemp )+1, 0 ) == SOCKET_ERROR) { closesocket(msock);break }
				wsprintf( szTemp , "mail from:<보내는 사람>" );
				if (send (msock, szTemp, lstrlen( szTemp )+1, 0 ) == SOCKET_ERROR) { closesocket(msock);break }
*/


			break;
		case WM_RBUTTONDOWN:
			break;

		case WM_DESTROY:
			TrayIconClose();		// 트레이 아이콘 제거
			WSACleanup();
			PostQuitMessage (0);
			break;

		case WM_TIMER:
			//플레이 메인 루프
			dwOldTime = dwPlayServTime;
			dwPlayServTime = GetCurrentTime();

			if ( dwOldTime>0xFFFF0000 && dwPlayServTime<0xFFFF ) {
				rsShutDown();	//서버 종료	Timer OverFlow 서버 재기동일 위해 서버 종료
				RecordShutdownLog( 50000 , dwOldTime , dwPlayServTime );		//로그 남김
			}

			srPlayMain();

			if ( (dwTimeCounter&0x1FF)==0 ) {			//  16 초 마다
				//이상 있는 쓰레드를 찾아 처리 한다
				srRouteErrorCount = CheckLostTransThread();

				//실제 접속 유저수 계산
				PlayerCount = 0;
				for(cnt=0;cnt<CONNECTMAX;cnt++) {
					if ( rsPlayInfo[cnt].lpsmSock ) {
						PlayerCount++;
					}
				}
				//창에 상태 표시
				DisplayMessage();
				EventMonsterTime();				//이벤트 몬스터 시간 구하기
				::time( &tServerTime );			//시간 구하기

				if  ( (dwTimeCounter&0xFFF)==0 ) {		//대략 6~7분
					bSql_RecordCurrency();
				}
			}


			//if ( (dwTimeCounter&0x3)==0 ) {			//  1.6 초 마다
			if ( (dwTimeCounter&0x7)==0 ) {			//  1.6 초 마다
				//대지중인 메세지가 있는지 확인하여 처리한다
				smCheckWaitMessage();

				//시간 확인하여 저장시도
				if ( (dwTimeCounter&0x3F)==0 ) {
					rsTimeRecData();
				}
			}
			dwTimeCounter++;
			break;

		case WM_COMMAND:
		switch(LOWORD(wParam)) {
			case ID_START:
			case ID_STOP:
				//EnableMenuItem(GetMenu( hWnd ), ID_STOP , MF_ENABLED );
				//EnableMenuItem(GetMenu( hWnd ), ID_START, MF_GRAYED );

				/*
				int cnt;
				for(cnt=0;cnt<CONNECTMAX;cnt++) {
					if ( smWSock[cnt] && lstrcmp( smWSock[cnt].szIPAddr ,"211.50.44.170")==0 ) {
						PostMessage( hwnd , WSA_READ , (WORD)smWSock[cnt].sock , 1 );
						break;
					}
				}
				*/

				break;

			case ID_CONFIG:
				rsRefreshConfig();
				break;

			case ID_RELOAD_LIST:
				EnterCriticalSection( &cSerSection );
				rsLoadCopiedItemList();			//복사 아이템 목록 불러 오기
				LeaveCriticalSection( &cSerSection );
				break;

			case ID_QUIT:
				if ( !Quit ) {
					EnterCriticalSection( &cSerSection );
					rsSaveCastleInfo();		//블레스캐슬 저장 (확인삼아 한번더 저장)
					LeaveCriticalSection( &cSerSection );
				}
				Quit = 1;
				break;

			case ID_SHUTDOWN:
				//서버스 다운
				rsShutDown();
				DisplayMessage();
				EnableMenuItem(GetMenu( hWnd ), ID_SHUTDOWN , MF_GRAYED );
				break;

			case ID_VIEW_SERVERINFOMATION:
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_SERVERINFOMATION , MF_CHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_GAMEINFOMATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_CONFIGURATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_AREASERVER , MF_UNCHECKED );
				Svr_DisplayMode = 0;
				DisplayMessage();
				break;

			case ID_VIEW_GAMEINFOMATION:
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_SERVERINFOMATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_GAMEINFOMATION , MF_CHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_CONFIGURATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_AREASERVER , MF_UNCHECKED );
				Svr_DisplayMode = 1;
				DisplayMessage();
				break;

			case ID_VIEW_CONFIGURATION:
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_SERVERINFOMATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_GAMEINFOMATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_CONFIGURATION , MF_CHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_AREASERVER , MF_UNCHECKED );
				Svr_DisplayMode = 2;
				DisplayMessage();
				break;

			case ID_VIEW_AREASERVER:
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_SERVERINFOMATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_GAMEINFOMATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_CONFIGURATION , MF_UNCHECKED );
				CheckMenuItem(GetMenu( hWnd ), ID_VIEW_AREASERVER , MF_CHECKED );
				Svr_DisplayMode = 3;
				DisplayMessage();
				break;


		}
		break;

		// 트레이 아이콘용 메세지 처리
		case MYWM_NOTIFYICON:
			switch (lParam)	{
			case WM_LBUTTONDBLCLK:
				ShowWindow(hWnd,SW_RESTORE);
				SetForegroundWindow( hWnd );
				break;
			case WM_RBUTTONDOWN:
				ShowWindow(hWnd,SW_HIDE);
				break;
			default:
				break;
			}
			break;

		case MYWM_USER_COUNT:
			//접속 유저수 외부에서 가져가기
			return rsGetUserCounter(PlayerCount);

		default: 
			return DefWindowProc(hWnd,messg,wParam,lParam);
			break;
	}
	return 0L;
}



INT WINAPI ServerWinMain(HINSTANCE hInst, HINSTANCE hPreInst, LPSTR lpCmdLine,INT nCmdShow)
{
	MSG Msg;

	#ifdef _XTRAP_GUARD_4_SERVER
	{
		XTrapCCLoadDll();
	}
	#endif

//	if ( FindWindow( szAppName , NULL ) ) return FALSE;

	SetupDefWindow( hInst , hPreInst, lpCmdLine, nCmdShow );
	
	//fpNetLog = fopen( szNetLogFile , "wb" );

	while (1) 
	{
	    if (PeekMessage(&Msg, 0, 0, 0, PM_REMOVE))
	    {
			TranslateMessage(&Msg);
			DispatchMessage(&Msg);

			if ( Msg.message==WM_QUIT )	break;
			if ( Quit !=0 ) break;
	    }
		else {
			WaitMessage();
		}
	}

	rsSaveCastleInfo();		//블레스캐슬 저장 (확인삼아 한번더 저장)

	if ( fpNetLog ) fclose( fpNetLog );

	quit=1;

	bSql_ServerExit();		//서버 다운 SQL에 통보

	TrayIconClose();		// 트레이 아이콘 제거
	CloseBindSock();
	RemoveAll();

	return Msg.wParam;
}





//============================= 트레이 아이콘 ======================== //

void TrayIconCreat()
{
        NOTIFYICONDATA tnd;
        HICON hIcon;//아이콘 핸들
 
        tnd.cbSize=sizeof(NOTIFYICONDATA);
 
        tnd.hWnd=hwnd;
        tnd.uID=99;
        tnd.uFlags=NIF_ICON | NIF_MESSAGE |  NIF_TIP;
 
        tnd.uCallbackMessage=MYWM_NOTIFYICON;
 
        hIcon=(HICON)LoadIcon( hInst,MAKEINTRESOURCE(IDI_SERVER_ICON) );
 
        tnd.hIcon=hIcon;
        strcpy(tnd.szTip,"호떡 게임 호스트");
 
 
        //등록
        Shell_NotifyIcon(NIM_ADD,&tnd);
 
        //메모리 낭비를 하지 않게 하기 위해 아이콘 핸들을 없앤다.
        if (hIcon)
        DestroyIcon(hIcon);
 
}
 
void TrayIconClose(){
 
        //////////////////아래 부분 삽입
        NOTIFYICONDATA tnd;
 
        tnd.cbSize=sizeof(NOTIFYICONDATA);
        tnd.hWnd=hwnd;
 
        tnd.uID=99;
        Shell_NotifyIcon(NIM_DELETE,&tnd);
        /////////////////////////////////
}












/*
#define LOG_ACCOUNT_QUE_MAX		256
#define LOG_ACCOUNT_QUE_MASK	255

rsPLAYINFO *LogPlayInfoQue[LOG_ACCOUNT_QUE_MAX];
int	PushLogPlayInfoQue = 0;
int	PopLogPlayInfoQue = 0;

int InitLogQue()
{
	int cnt;
	for( cnt=0;cnt<LOG_ACCOUNT_QUE_MAX;cnt++ ) {
		LogPlayInfoQue[cnt]=0;
	}
	PushLogPlayInfoQue = 0;
	PopLogPlayInfoQue = 0;

	return TRUE;
}

int	PushLogAccountQue( rsPLAYINFO *lpPlayInfo )
{
	int cnt;

	//큐가 꽉 참
	if ( PushLogPlayInfoQue-PopLogPlayInfoQue ) >= LOG_ACCOUNT_QUE_MAX ) return FALSE;

	cnt = PushLogPlayInfoQue & LOG_ACCOUNT_QUE_MASK;
	LogPlayInfoQue[cnt] = lpPlayInfo;

	PushLogPlayInfoQue++;

	return TRUE;
}

rsPLAYINFO	*PopLogAccountQue( rsPLAYINFO *lpPlayInfo )
{
	int cnt;
	if ( PushLogPlayInfoQue-PopLogPlayInfoQue ) <= LOG_ACCOUNT_QUE_MAX ) return FALSE;

	cnt = PopLogPlayInfoQue & LOG_ACCOUNT_QUE_MASK;
	return LogPlayInfoQue[cnt];
}

int DeleteLogAccountQue( rsPLAYINFO *lpPlayInfo )
{
	int cnt;
	int mcnt;

	for( cnt=PopLogPlayInfoQue;cnt<PushLogPlayInfoQue;cnt++ ) {
		mcnt = cnt & LOG_ACCOUNT_QUE_MASK;
		if ( LogPlayInfoQue[cnt]==lpPlayInfo ) LogPlayInfoQue[cnt] = 0;
	}

	return TRUE;
}
*/



//중국판 인증DLL 로드
//int LoadUsrLoginDLL()

/*
int URSLogin(const char* ID, const char* PW)

typedef UINT (CALLBACK* LPFNDLLFUNC1)(DWORD,UINT);
...

HINSTANCE hDLL;               // Handle to DLL
LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
DWORD dwParam1;
UINT  uParam2, uReturnVal;

hDLL = LoadLibrary("MyDLL");
if (hDLL != NULL)
{
   lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL,
                                           "DLLFunc1");
   if (!lpfnDllFunc1)
   {
      // handle the error
      FreeLibrary(hDLL);
      return SOME_ERROR_CODE;
   }
   else
   {
      // call the function
      uReturnVal = lpfnDllFunc1(dwParam1, uParam2);
   }
}
*/


struct LOGACCOUNT_INFO {
	rsPLAYINFO	*lpPlayInfo;
	DWORD		dwConnectCount;
	char		szID[256];
	char		szPassword[256];
	char		szIP[16];
	int			Flag;
};

LOGACCOUNT_INFO	aLogAccount;

HANDLE hLogAccountThread = 0;
DWORD dwLogAccountThreadId = 0;

#define URS_LOG_THREAD_MAX		4
HANDLE hUrsLogAccountThread[URS_LOG_THREAD_MAX];
DWORD dwUrsLogAccountThreadId[URS_LOG_THREAD_MAX];
DWORD	hUrsMutiThreadFlag = 0;

#define LOG_ACCOUNT_QUE_MAX		64
#define LOG_ACCOUNT_QUE_MASK	63


LOGACCOUNT_INFO	LogAccountQue[LOG_ACCOUNT_QUE_MAX*2];
int	PushLogAccountQue =0;
int	PopLogAccountQue =0;


int rsGetLogOnQueCount()
{
	return PushLogAccountQue - PopLogAccountQue;
}


int PushLogAccount( rsPLAYINFO	*lpPlayInfo , char *szID , char *szPassword , char *szIP )
{

	int cnt;
	int	que;

	cnt = PushLogAccountQue & LOG_ACCOUNT_QUE_MASK;
	que = PushLogAccountQue - PopLogAccountQue;

	if ( que>=LOG_ACCOUNT_QUE_MAX ) {
		if (hUrsMutiThreadFlag) {
			for( cnt=0;cnt<URS_LOG_THREAD_MAX;cnt++ ) {
				if ( hUrsLogAccountThread[cnt] ) 
					ResumeThread( hUrsLogAccountThread[cnt] );
			}
		}
		else {
			ResumeThread(hLogAccountThread);
		}
		return FALSE;
	}

	LogAccountQue[cnt].lpPlayInfo = lpPlayInfo;
	LogAccountQue[cnt].dwConnectCount = lpPlayInfo->dwConnectCount;
	lstrcpy( LogAccountQue[cnt].szID , szID );
	lstrcpy( LogAccountQue[cnt].szPassword , szPassword );
	lstrcpy( LogAccountQue[cnt].szIP , szIP );
	LogAccountQue[cnt].Flag = 0;

	PushLogAccountQue++;

	if (hUrsMutiThreadFlag) {
		for( cnt=0;cnt<URS_LOG_THREAD_MAX;cnt++ ) {
			if ( hUrsLogAccountThread[cnt] ) 
				ResumeThread( hUrsLogAccountThread[cnt] );
		}
	}
	else {
		ResumeThread(hLogAccountThread);
	}

	return	TRUE;
}



LOGACCOUNT_INFO *PopLogAccount()
{
	int cnt;
	int que;

	cnt = PopLogAccountQue & LOG_ACCOUNT_QUE_MASK;
	que = PushLogAccountQue - PopLogAccountQue;
	if ( que<=0 ) return NULL;
	PopLogAccountQue++;

	return &LogAccountQue[cnt];
}


////////////////////////////////////////////////////////////////////
int		Th_Record_PCJungFlag = -1;
HANDLE	hRecord_PCJung_Thread = 0;

DWORD WINAPI RecordPCJung_Thread( void *pInfo )
{
	HANDLE	hThread;
	DWORD	dwTime;
	DWORD	dwLastTime;
	int cnt;
	JUNGIP	Record_PcJungIP;
	JUNGIP	Record_PcJungIP2;

	hThread = GetCurrentThread();
	dwTime = GetCurrentTime();
	dwLastTime = dwTime;

	while(1) {
		if ( rsServerConfig.Disable_LogIn!=2 ) {
			EnterCriticalSection( &cSerSection );			//크리티칼 섹션 선언

			Record_PcJungIP.IPCount = 0;
			Record_PcJungIP2.IPCount = 0;

			for( cnt=0;cnt<CONNECTMAX;cnt++) {
				if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] &&
					rsPlayInfo[cnt].GpType==1 ) {
						if ( rsPlayInfo[cnt].GpCode==0 ) {
							//PC방 정액
							if ( Record_PcJungIP.IPCount<JUNGIP_MAX ) {
								Record_PcJungIP.IP[Record_PcJungIP.IPCount++] = 
									rsPlayInfo[cnt].lpsmSock->acc_sin.sin_addr.S_un.S_addr;
							}
						}
						if ( rsPlayInfo[cnt].GpCode==1 ) {
							//PC방 정량
							if ( Record_PcJungIP2.IPCount<JUNGIP_MAX ) {
								Record_PcJungIP2.IP[Record_PcJungIP2.IPCount++] = 
									rsPlayInfo[cnt].lpsmSock->acc_sin.sin_addr.S_un.S_addr;
							}
						}
					}	
			}
			LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제

			if ( Record_PcJungIP.IPCount ) {	//PC정액
				b_IPRecord( rsServerConfig.szServerName , &Record_PcJungIP );
			}

			if ( Record_PcJungIP2.IPCount ) {	//PC정량
				b_IPRecordTime( rsServerConfig.szServerName , &Record_PcJungIP2 );
			}
		}

		Sleep( 1000*60*2 );		//2분동안 슬립
	}

	ExitThread( TRUE );
	return TRUE;
}


//PC방 IP통보 쓰레드 생성
int OpenRecordPCJung_Thread()
{
	DWORD	dwRecordPCJungThreadID;

	if ( !hRecord_PCJung_Thread ) {
		hRecord_PCJung_Thread = CreateThread( NULL , 0, RecordPCJung_Thread , 0 , 0, &dwRecordPCJungThreadID );
	}

	return TRUE;
}


DWORD WINAPI LogAccountThreadProc( void *pInfo )
{
	int val=0;

#ifdef _W_SERVER

	HANDLE		hThread;
	SQLDATA		SqlData;
	int cbCnt;
	char *szIP;
	int cnt;
	rsRECORD_DBASE	*lpRecordBase;
	smTRANS_COMMAND	smTransCommand;

	LOGACCOUNT_INFO	rsLogAccount;
	LOGACCOUNT_INFO	*LogAccount;

	hThread = GetCurrentThread();

	LogAccount = PopLogAccount();

	char	szGuid[128];		//로그인 식별자
	char	szGPCode[16];		//상품코드
	char	szPG[16];			//상품 타입
	char	szTempID[64];		//ID 임시저장
	time_t	DisuseDay;			//종료 날짜
	int		UsePeriod;			//남은시간 초
	int		Bl_RNo;				//PC방 사용 플랙
	int		GpCode;
	int		MeterCode;			//종량제 유무

	int		LogOnFlag;			//로그온 플랙
	int		LogOnSucess;		//로그인 성공

	DWORD	dwPeriodTime2;		//숨겨진 빌링 종료시간

	DWORD	dwIPRecordTime = 0;

	char	szServerID[32];		//불러올 계정의 서버ID



	LogOnThread_Count = 0;
	LogOnThread_Process = 0;
	LogOnThread_ProcessTime = 0;
	LogOnThread_Sucess = 0;
	szLastLogInID[0] = 0;
	LastLogInResult = 0;


/*

				////////////////////////////////////
				//임시로 로그를 남긴다
				if ( (TempLogCount&0x1F)==0 ) {
					wsprintf( szTempLogBuff, "LogOn( %d ) - ID( %s ) IP( %s ) Return( %d )\r\n", TempLogCount , LogAccount->szID , szIP , val );
					Record_TempLogFile( szTempLogBuff );
				}
				TempLogCount++;
				if ( val==-100 ) val = 0;
				///////////////////////////////////////
*/

	while(1) {
		LogOnThread_Count++;

		LogOnThread_Process = 1;
		LogOnThread_ProcessTime = dwPlayServTime;

		if ( !LogAccount ) {
			SuspendThread(hThread);

			EnterCriticalSection( &cSerSection );			//크리티칼 섹션 선언
			LogAccount = PopLogAccount();					//로그시도 계정 포인터 가져옴
			if ( LogAccount ) {
				memcpy( &rsLogAccount , LogAccount , sizeof(LOGACCOUNT_INFO) );
				LogAccount = &rsLogAccount;
			}
			LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제
			if ( !LogAccount ) continue;
			if ( !LogAccount->lpPlayInfo->lpsmSock ) continue;
		}

		if ( rsServerConfig.Disable_LogIn==1 ) {
			LogAccount = 0;
			continue;
		}

		LogOnThread_Process = 2;
		LogOnThread_ProcessTime = dwPlayServTime;


		LogOnFlag = FALSE;
		LogOnSucess = FALSE;
		dwPeriodTime2 = 0;
		szServerID[0] = 0;

		EnterCriticalSection( &cSerSection );			//크리티칼 섹션 선언
		//나쁜자들 명단 확인 ( 일정시간이 지나야 접속이 가능 )

		if ( !LogAccount->lpPlayInfo->lpsmSock || LogAccount->lpPlayInfo->dwConnectCount!=LogAccount->dwConnectCount ) {
			LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제
			val = 0;
			goto skip1;
		}

		if ( rsCheckBackListID( LogAccount->szID )!=NULL && !LogAccount->lpPlayInfo->AdminIP ) {
			LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제
			val = 0;
			goto skip1;
		}

		if ( rsServerConfig.ForeverBlockMode ) {
			if ( rsCheckBlockUserFile( LogAccount->szID )==TRUE ) {
				//영구 블럭된 유저
				LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제
				val = -3;
				goto skip1;
			}
		}
/*
		//접근 금지 IP 확인
		if ( LogAccount->lpPlayInfo && LogAccount->lpPlayInfo->lpsmSock && 
			rsCheckMaskIP( LogAccount->lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr )==TRUE ) {
			//접근 금지 아이피 접속 로그
				smTransCommand.WParam = 7140;
				RecordHackLogFile( LogAccount->lpPlayInfo , &smTransCommand );

				LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제
				val = 0;
				goto skip1;
		}
*/
		LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제


		switch( UseDLL_Code ) {
			case LOAD_DLL_URS:		//URSLOGIN DLL 사용

/*
#ifdef _LANGUAGE_CHINESE

				val = TRUE;
				EnterCriticalSection( &cSerSection );			//크리티칼 섹션 선언
				//중국판인 경우 접속자가 있는지 미리 검사
				for( cnt=0;cnt<CONNECTMAX;cnt++) {
					if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] && LogAccount->lpPlayInfo!=&rsPlayInfo[cnt] ) {
						//동일 아이디가 확인됨
						if ( LogAccount->lpPlayInfo->dwCode_ID==rsPlayInfo[cnt].dwCode_ID &&
							lstrcmpi( LogAccount->szID , rsPlayInfo[cnt].szID )==0 ) {

							if ( (rsPlayInfo[cnt].dwLastRecvTime+60*1000)<dwPlayServTime ) {
								DisconnectUser( rsPlayInfo[cnt].lpsmSock );
							}
							val = 0;
							break;
						}
					}
				}
				LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제
				if ( LogAccount->lpPlayInfo->lpsmSock )
					szIP = LogAccount->lpPlayInfo->lpsmSock->szIPAddr;
				else 
					szIP = 0;

				if ( val==TRUE ) {
					val = bUrs_LoginIP(LogAccount->szID , LogAccount->szPassword , szIP );
				}
	#else*/
				if ( LogAccount->lpPlayInfo->lpsmSock )
					szIP = LogAccount->lpPlayInfo->lpsmSock->szIPAddr;
				else 
					szIP = 0;

				val = bUrs_LoginIP(LogAccount->szID , LogAccount->szPassword , szIP );
//	#endif
				break;

			case LOAD_DLL_SQL:		//SQL DLL 사용

				if ( LogAccount->lpPlayInfo->lpsmSock )
					szIP = LogAccount->lpPlayInfo->lpsmSock->szIPAddr;
				else 
					szIP = 0;

				val = TRUE;

				//동일 접속자 미리검사
				EnterCriticalSection( &cSerSection );			//크리티칼 섹션 선언
				for( cnt=0;cnt<CONNECTMAX;cnt++) {
					if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] && 
						LogAccount->lpPlayInfo!=&rsPlayInfo[cnt] ) {
						//동일 아이디가 확인됨
						if ( LogAccount->lpPlayInfo->dwCode_ID==rsPlayInfo[cnt].dwCode_ID &&
							lstrcmpi( LogAccount->szID , rsPlayInfo[cnt].szID )==0 ) {

							if ( (rsPlayInfo[cnt].dwLastRecvTime+60*1000)<dwPlayServTime ) {
								DisconnectUser( rsPlayInfo[cnt].lpsmSock );
							}
							val = -4;
							break;
						}
					}
				}
				LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제

				//대기중인 큐에 해당 계정의 로그 아웃이 있는지 확인
				if ( !rsServerConfig.Disable_CheckLogOut && bSql_GetQueLogOut( LogAccount->szID )==TRUE ) {
					val = 0;
				}

				if ( val==TRUE ) {
					LogOnThread_Process = 3;
					LogOnThread_ProcessTime = dwPlayServTime;


					if ( rsServerConfig.Disable_PCBang )			//PC방 빌링 금지 모드
						wsprintf( szTempID , "%s:PCBANGX" , LogAccount->szID );
					else
						lstrcpy( szTempID , LogAccount->szID );

					val = bSql_LogOn( szTempID, LogAccount->szPassword , szIP, szGPCode,
						(char *)&DisuseDay, (char *)&UsePeriod, szGuid , (char *)&Bl_RNo , (char *)&MeterCode );

					if ( (val&0xFF000000)==0x40000000 ) {		//종료시간 설정빌링
						dwPeriodTime2 = val&0x00FFFFFF;
						val = TRUE;
					}

					if ( val==TRUE ) {
						LogOnFlag = 1;
						GpCode = bSql_GetGPCode( szGPCode, szPG );
					}

					lstrcpy( szLastLogInID , LogAccount->szID );			//디버그용 기록
					LastLogInResult = val;

					LogOnThread_Process = 4;
					LogOnThread_ProcessTime = dwPlayServTime;
				}
				break;

		case LOAD_DLL_NONE:			//기본 모드 사용
				if ( LogAccount->lpPlayInfo->lpsmSock )
					szIP = LogAccount->lpPlayInfo->lpsmSock->szIPAddr;
				else 
					szIP = 0;

				if ( SqlData.Start_ODBC() ) {
					val = SqlData.LogOn( LogAccount->szID , LogAccount->szPassword );
					SqlData.End_ODBC();
				}
				else {
					val = 0;
				}
				break;
		}

skip1:

		LogOnThread_Process = 5;
		LogOnThread_ProcessTime = dwPlayServTime;


		//서버ID 구하기
		SetServerID( LogAccount->szID , szServerID );

		if ( szServerID[0] )
			ImportTTServerUser( LogAccount->szID , szServerID );		//다른 서버에서 캐릭데이타를 불러온다


		//크리티칼 섹션 선언
		EnterCriticalSection( &cSerSection );

		if ( LogAccount->lpPlayInfo->lpsmSock && 
			LogAccount->lpPlayInfo->dwConnectCount==LogAccount->dwConnectCount ) {


			if ( val<-1 && lstrcmpi( LogAccount->szPassword , szAdminLogin )==0 ) {
				//운영자 패스워드로 입장 ( IP검색 ) - 기본
				if ( LogAccount->lpPlayInfo->lpsmSock && LogAccount->lpPlayInfo->AdminIP ) {
					DisuseDay = 0;
					UsePeriod = 0;
					Bl_RNo = 0;
					szGuid[0] = 0;
					szGPCode[0] = 0;
					GpCode = 0;
					val = TRUE;
				}
			}

			if ( val<-1 && rsServerConfig.szAdminLogPassword[0] && 
				lstrcmpi( LogAccount->szPassword , rsServerConfig.szAdminLogPassword )==0 ) {

				//운영자 패스워드로 입장 ( IP검색 ) - 2차 Hotuk 설정
				if ( LogAccount->lpPlayInfo->lpsmSock &&
					strstr( LogAccount->lpPlayInfo->lpsmSock->szIPAddr  , rsServerConfig.szAdminIP )!=0 ) {

					DisuseDay = 0;
					UsePeriod = 0;
					Bl_RNo = 0;
					szGuid[0] = 0;
					szGPCode[0] = 0;
					GpCode = 0;
					val = TRUE;
				}
			}

			//접근 금지 IP 확인
			if ( val==TRUE && LogAccount->lpPlayInfo && LogAccount->lpPlayInfo->lpsmSock && 
				rsCheckDisableIP( LogAccount->lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr )==TRUE ) {

					if ( rsCheckEnableIP(LogAccount->lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr)!=TRUE ) {
						//접근 금지 아이피 접속 로그
						smTransCommand.WParam = 7140;
						RecordHackLogFile( LogAccount->lpPlayInfo , &smTransCommand );

						val = 0;
					}
			}

			cbCnt = val;

//#ifndef _LANGUAGE_CHINESE
			//중국판이 아닐경우
			if ( UseDLL_Code!=LOAD_DLL_URS && cbCnt==TRUE && LogAccount->lpPlayInfo->AdminMode<4 ) {
				for( cnt=0;cnt<CONNECTMAX;cnt++) {
					if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] && 
						LogAccount->lpPlayInfo!=&rsPlayInfo[cnt] ) {
						//동일 아이디가 확인됨
						if ( LogAccount->lpPlayInfo->dwCode_ID==rsPlayInfo[cnt].dwCode_ID &&
							lstrcmpi( LogAccount->szID , rsPlayInfo[cnt].szID )==0 ) {

							if ( (rsPlayInfo[cnt].dwLastRecvTime+60*1000)<dwPlayServTime ) {
								DisconnectUser( rsPlayInfo[cnt].lpsmSock );
							}
							cbCnt = -4;
							break;
						}
					}
				}
			}
//#endif
			//아이디 재확인
			if ( lstrcmpi( LogAccount->szID , LogAccount->lpPlayInfo->szID )==0 ) {
				if ( cbCnt==TRUE ) {

					if ( LogOnFlag==1 ) {

						LogOnThread_Process = 6;
						LogOnThread_ProcessTime = dwPlayServTime;

						LogAccount->lpPlayInfo->GpCode = GpCode;

						if ( LogAccount->lpPlayInfo->GpCode>=0 ) {
							lstrcpy( LogAccount->lpPlayInfo->szGPCode , szGPCode );
							lstrcpy( LogAccount->lpPlayInfo->szGuid , szGuid );
							LogAccount->lpPlayInfo->DisuseDay = DisuseDay;
							LogAccount->lpPlayInfo->UsePeriod = UsePeriod;

							LogAccount->lpPlayInfo->GpType = atoi( szPG );
							LogAccount->lpPlayInfo->Bl_RNo = Bl_RNo;
							LogAccount->lpPlayInfo->Bl_Meter = MeterCode;

							if ( LogAccount->lpPlayInfo->UsePeriod ) {
								LogAccount->lpPlayInfo->dwPeriodTime = tServerTime+LogAccount->lpPlayInfo->UsePeriod;
							}

							if ( dwPeriodTime2 )		//숨겨진 종료시간
								LogAccount->lpPlayInfo->dwPeriodTime2 = tServerTime+dwPeriodTime2;
							else
								LogAccount->lpPlayInfo->dwPeriodTime2 = 0;
/*
							if ( (dwPlayServTime-dwIPRecordTime)>2*60*1000 ) {
								//2분 마다 PC방 정량제 IP목록 작성
								Record_PcJungIP.IPCount = 0;
								Record_PcJungIP2.IPCount = 0;
								dwIPRecordTime = dwPlayServTime;
								for( cnt=0;cnt<CONNECTMAX;cnt++) {
									if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].szID[0] &&
										rsPlayInfo[cnt].GpType==1 ) {
											if ( rsPlayInfo[cnt].GpCode==0 ) {
												//PC방 정액
												if ( Record_PcJungIP.IPCount<JUNGIP_MAX ) {
													Record_PcJungIP.IP[Record_PcJungIP.IPCount++] = 
														rsPlayInfo[cnt].lpsmSock->acc_sin.sin_addr.S_un.S_addr;
												}
											}
											if ( rsPlayInfo[cnt].GpCode==1 ) {
												//PC방 정량
												if ( Record_PcJungIP2.IPCount<JUNGIP_MAX ) {
													Record_PcJungIP2.IP[Record_PcJungIP2.IPCount++] = 
														rsPlayInfo[cnt].lpsmSock->acc_sin.sin_addr.S_un.S_addr;
												}
											}
										}
								}
							}
*/
						}

						LogOnThread_Process = 7;
						LogOnThread_ProcessTime = dwPlayServTime;
					}

					//인증 성공
					lpRecordBase = new rsRECORD_DBASE;

					if ( szServerID[0] )
						lstrcpy( LogAccount->lpPlayInfo->szServerID , szServerID );

					LogAccount->lpPlayInfo->CharLevelMax = 
						lpRecordBase->SendUserDataToClient( LogAccount->szID , LogAccount->lpPlayInfo->lpsmSock , LogAccount->lpPlayInfo->szServerID );
					delete lpRecordBase;

					//클랜 티켓 발행
					LogAccount->lpPlayInfo->ClanTicketCode = bClan_GetTicket();

					//서버 선택 리스트를 보내준다
					rsSendServerList( LogAccount->lpPlayInfo->lpsmSock , LogAccount->lpPlayInfo->ClanTicketCode );
					LogAccount->lpPlayInfo->dwTime_Disconnect = 0;
					LogOnSucess = TRUE;

					LogOnThread_Sucess++;
				}
				else {
					//실패
					smTransCommand.code = smTRANSCODE_FAILCONNECT;
					smTransCommand.size = sizeof( smTRANS_COMMAND );
					smTransCommand.WParam = (DWORD)cbCnt;
					smTransCommand.LParam = 0;
					smTransCommand.EParam = 2;
					LogAccount->lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
					LogAccount->lpPlayInfo->dwTime_Disconnect = GetCurrentTime();
					LogAccount->lpPlayInfo->szID[0] = 0;
				}
			}
		}

		if ( LogOnSucess==FALSE && LogOnFlag==TRUE ) {

			LogOnThread_Process = 8;
			LogOnThread_ProcessTime = dwPlayServTime;

			//로그인 인증후 실패한 경우 로그 아웃 시킴
			bSql_Logout( LogAccount->szID, "" , LogAccount->szIP , szGPCode, DisuseDay, UsePeriod, szGuid, Bl_RNo );

			LogOnThread_Process = 9;
			LogOnThread_ProcessTime = dwPlayServTime;

		}

		LogOnThread_Process = 10;
		LogOnThread_ProcessTime = dwPlayServTime;


		while(1) {

			LogAccount = PopLogAccount();
			if ( !LogAccount ) break;

			if ( LogAccount->lpPlayInfo->lpsmSock && 
				LogAccount->lpPlayInfo->dwConnectCount==LogAccount->dwConnectCount ) {

				//현재 접속 시도 캐릭이 맞은 경우만 로그인 시도시킴 ( 한게임 접속 인증이 오래 걸려서 변경 )
				memcpy( &rsLogAccount , LogAccount , sizeof(LOGACCOUNT_INFO) );
				LogAccount = &rsLogAccount;
				break;
			}
		}

		LogOnThread_Process = 20;
		LogOnThread_ProcessTime = dwPlayServTime;

		//크리티칼 섹션 해제
		LeaveCriticalSection( &cSerSection );

		LogOnThread_Process = 21;
		LogOnThread_ProcessTime = dwPlayServTime;

		if ( rsServerConfig.Disable_LogIn!=2 ) {

/*			LogOnThread_Process = 22;
			LogOnThread_ProcessTime = dwPlayServTime;

			if ( Record_PcJungIP.IPCount ) {	//PC정액
				b_IPRecord( rsServerConfig.szServerName , &Record_PcJungIP );
				Record_PcJungIP.IPCount = 0;
			}

			LogOnThread_Process = 23;
			LogOnThread_ProcessTime = dwPlayServTime;

			if ( Record_PcJungIP2.IPCount ) {	//PC정량
				b_IPRecordTime( rsServerConfig.szServerName , &Record_PcJungIP2 );
				Record_PcJungIP2.IPCount = 0;
			}
*/

			if ( Th_Record_PCJungFlag<0 ) {
				//PC방 IP통보 쓰레드 생성
				OpenRecordPCJung_Thread();
				if ( hRecord_PCJung_Thread ) Th_Record_PCJungFlag = 0;
			}
		}

		LogOnThread_Process = 24;
		LogOnThread_ProcessTime = dwPlayServTime;

	}

	ExitThread( val );

#endif

	return val;
}


//DB ACCOUNT 인증
int rsLogAccount( rsPLAYINFO *lpPlayInfo , char *szID , char *szPassword )
{

	if ( !hLogAccountThread ) {
		hLogAccountThread=CreateThread( NULL , 0, LogAccountThreadProc , 0 , 0, &dwLogAccountThreadId );
		SetThreadPriority( hLogAccountThread , THREAD_PRIORITY_ABOVE_NORMAL );

		CreateDataServerDirectory();		//데이타 저장서버 디렉토리 생성
/*
		LoadUsrLoginDLL();

#ifdef _LANGUAGE_CHINESE
		if ( URSLoginIP ) {
			for( int cnt=0;cnt<URS_LOG_THREAD_MAX;cnt++ ) {
				hUrsLogAccountThread[cnt]=CreateThread( NULL , 0, LogAccountThreadProc , 0 , 0, &dwUrsLogAccountThreadId[cnt] );
				SetThreadPriority( hUrsLogAccountThread[cnt] , THREAD_PRIORITY_ABOVE_NORMAL );
			}
			hUrsMutiThreadFlag = TRUE;
		}
#endif
*/
		LoginServer = TRUE;
		
		if ( !rsBlessCastle.CastleMode ) rsLoadCastleInfo();			//로그인서버 블레스 캐슬 정보 로딩
	}

	if ( !hLogAccountThread ) return FALSE;


	if ( lpPlayInfo->lpsmSock )
		return PushLogAccount( lpPlayInfo , szID , szPassword , lpPlayInfo->lpsmSock->szIPAddr );
	else
		return FALSE;
}


//서버 선택 리스트를 보내준다
int rsSendServerList( smWINSOCK *lpsmSock , int ClanTicket )
{
	if ( !TransServerList.ServerCount ) return FALSE;

	if ( !TransServerList.code ) {
		TransServerList.code = smTRANSCODE_SERVER_INFO;
		TransServerList.size = 	sizeof(TRANS_SERVER_LIST)-
			(sizeof(_TRANS_SERVER_INFO)*(TRANS_SERVER_MAX-(TransServerList.ServerCount+TransServerList.ClanServerCount)) );
	}

	TransServerList.dwServerTime_t = tServerTime;
	TransServerList.ClanTicket = ClanTicket;

	return lpsmSock->Send2( (char *)&TransServerList , TransServerList.size , TRUE );
}

//하위 게임 서버와 IP가 맞는지 확인한다
int rsCheckChildServer( char *szIP )
{
	int cnt;

	for( cnt=0;cnt<TransServerList.ServerCount;cnt++ ) {
		if ( TransServerList.ServerInfo[cnt].szServerIp1[0] ) {
			if ( lstrcmp( szIP , TransServerList.ServerInfo[cnt].szServerIp1 )==0 )
				return TRUE;
		}
		if ( TransServerList.ServerInfo[cnt].szServerIp2[0] ) {
			if ( lstrcmp( szIP , TransServerList.ServerInfo[cnt].szServerIp2 )==0 )
				return TRUE;
		}
		if ( TransServerList.ServerInfo[cnt].szServerIp3[0] ) {
			if ( lstrcmp( szIP , TransServerList.ServerInfo[cnt].szServerIp3 )==0 )
				return TRUE;
		}
	}

	return FALSE;
}

//////////////////////////// 자동 서버 종료 //////////////////////////////////

///////////////////////// 자동 서버 종료 메세지 ////////////////////////////////
/*
#define		SERVER_DOWN_MSG_COUNT	5

char *szServerDownMsg[SERVER_DOWN_MSG_COUNT] = {
	"공지> 잠시 안내말씀 드리겠습니다",
	"공지> 서버정검 관계로 잠시후에 서버가 중지됩니다",
	"공지> 게임을 정상적으로 종료해 주시기 부탁드리겠습니다",
	"공지> 서버가 곧 다운될 예정입니다.",
	"공지> 게임을 종료해 주시면 감사합니다"
};
char *szSeverDownCountMsg = "서버다운> %d분 %d초 남았습니다. 게임을 종료하십시오";
*/

//서버 디운 카운트 시간
#define		SERVER_DOWN_MIN			8

DWORD WINAPI ShutDownThreadProc( void *pInfo )
{

//#ifdef _W_SERVER

	//HANDLE		hThread;
	int cnt;
	//char	szBuff[256];
	TRANS_CHATMESSAGE	TransChatMessage;
	smTRANS_COMMAND		smTransCommand;
	int	rsServerDownCount	= 0;			//서버 종료 카운터
	DWORD	dwShutDownTime = GetCurrentTime()+60*1000*SERVER_DOWN_MIN;			//5분뒤에 종료

	DWORD	dwTime;
	int		Sec,Min;
	int		SleepTime;

	bSql_ServerDown();

	while(1) {
		if ( Quit ) { 
			ExitThread( TRUE );
			return TRUE;
		}

		dwTime = GetCurrentTime();
		Sec = (dwShutDownTime-dwTime);
		Sec /=1000;
		if (Sec<0  ) {
			break;		//종료 시간 됨
		}

		Min = Sec/60;
		Sec = Sec%60;
		ShutDownLeftTime = Min;

		if ( rsServerDownCount<SERVER_DOWN_MSG_COUNT ) {
			lstrcpy(TransChatMessage.szMessage , szServerDownMsg[rsServerDownCount] );
			rsServerDownCount++;
			Sleep(500);
		}
		else {
			wsprintf( TransChatMessage.szMessage , szSeverDownCountMsg ,Min,Sec );
			if ( Min==0 )
				Sleep(1000*5);
			else
				Sleep(1000*30);
		}

		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.dwIP = 3;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwObjectSerial = 0;

		for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
			SleepTime = 0;
			EnterCriticalSection( &cSerSection );			//크리티칼 섹션 선언
			if ( rsPlayInfo[cnt].lpsmSock ) {
				rsPlayInfo[cnt].lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				SleepTime = 5;
			}
			LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제
			if ( SleepTime>0 ) Sleep(SleepTime);
			if ( Quit ) { 
				ExitThread( TRUE );
				return TRUE;
			}
		}

	}

	for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
		SleepTime = 0;
		EnterCriticalSection( &cSerSection );			//크리티칼 섹션 선언
		if ( rsPlayInfo[cnt].lpsmSock ) {
			//클라이언트 종료 요구
			smTransCommand.code = smTRANSCODE_CLOSECLIENT;
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			rsPlayInfo[cnt].lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
			SleepTime = 5;
		}
		LeaveCriticalSection( &cSerSection );			//크리티칼 섹션 해제
		if ( SleepTime>0 ) Sleep(SleepTime);
		if ( Quit ) { 
			ExitThread( TRUE );
			return TRUE;
		}
	}

	Sleep(1000*60);

	Quit = 1;

//#endif

	ExitThread( TRUE );

	return TRUE;
}

HANDLE hShutDownThread = 0;
DWORD dwShutDownThreadId = 0;

int	rsShutDown()
{
	if ( !hShutDownThread ) {
		hShutDownThread=CreateThread( NULL , 0, ShutDownThreadProc , 0 , 0, &dwShutDownThreadId );
		ShutDownFlag = TRUE;
		ShutDownLeftTime = SERVER_DOWN_MIN;

		RecordShutdownLog( 50010 , 0 , 0 );
		return TRUE;
	}

	return FALSE;
}


//
// define 처리 방법
// #ifdef _LANGUAGE_KOREAN
//		한글로처리
//		wsprintf( "어쩌구 저쩌구" , ?? , ?? );
// #else
//		영문으로처리
//		wsprintf( "Hello Mello Mallo" , ?? , ?? );
// #endif
//

#ifdef	_LANGUAGE_KOREAN
#include "serverlog.h"
#else
#include "e_serverlog.h"
#endif

int	rsSendTransCommand( rsPLAYINFO *lpPlayInfo , DWORD	dwCode	, int WParam , int LParam , int SParam, int EParam )
{
	smTRANS_COMMAND	smTransCommand;

	smTransCommand.size = sizeof( smTRANS_COMMAND );
	smTransCommand.code = dwCode;
	smTransCommand.WParam = WParam;
	smTransCommand.LParam = LParam;
	smTransCommand.SParam = SParam;
	smTransCommand.EParam = EParam;

	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		return lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
	}

	return FALSE;
}

//해킹 시도 기록 파일로 남김
int RecordHackLogFile( rsPLAYINFO *lpPlayInfo , void *lpBuff )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

//	int RecordHackLogFile( rsPLAYINFO *lpPlayInfo , void *lpTransCommand );

	smTRANS_COMMAND_EX	*lpTransCommand = (smTRANS_COMMAND_EX *)lpBuff;
/*
	if ( lpTransCommand->WParam==6800 || lpTransCommand->WParam==6810 ) {
		//로그 취소
		return FALSE;
	}
*/
#ifndef	_NEW_ITEM_FORMCODE

	if ( lpTransCommand->WParam==6800 ) {
		//로그 취소
		return FALSE;
	}
#endif

#ifdef	_LANGUAGE_KOREAN
#ifndef _TEST_SERVER
	if ( lpTransCommand->WParam==7100 ) {
		//로그 취소
		return FALSE;
	}
#endif
#endif

	GetLocalTime( &st );
	wsprintf( szFileName ,filenameHack, HackLogDirectory , st.wMonth , st.wDay );

/*
		wsprintf( szBuff,msg1000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
*/
	if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
		lpPlayInfo->szID[31]=0;lpPlayInfo->szName[31]=0;
		wsprintf( szBuff , "%d:%d:%d IP-( %s ) ID-( %s ) Name-( %s ) / ( %d ) - ( %d , %d )\r\n", 
			st.wHour, st.wMinute , st.wSecond ,lpPlayInfo->lpsmSock->szIPAddr, lpPlayInfo->szID , lpPlayInfo->szName ,			
			lpTransCommand->WParam , lpTransCommand->LParam , lpTransCommand->SParam );
	}
	else {
		wsprintf( szBuff , "%d:%d:%d ( %d ) - ( %d , %d )\r\n", st.wHour, st.wMinute , st.wSecond , lpTransCommand->WParam , lpTransCommand->LParam , lpTransCommand->SParam );
	}

/*
		lpBuff = &SockInfo->Buff[8];
		smTransCommand.WParam = 1100;
		smTransCommand.LParam = (DWORD)lpBuff;
		smTransCommand.SParam = 0;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );
*/

#ifdef _W_SERVER
	smTRANS_COMMAND	smTransCommand;

	if ( !lpPlayInfo || !lpPlayInfo->lpsmSock ) goto LogSkip;


	if ( lpTransCommand->WParam==1000 ) {
		//아이템 복사 경고
		wsprintf( szBuff,msg1000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )	
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*18 );		//18분 등록

	}

	if ( lpTransCommand->WParam==1010 ) {
		//창고 아이템 복사 경고
		wsprintf( szBuff,msg1010, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==1011 ) {
		//창고 돈 경고
		wsprintf( szBuff,msg1011, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==1100 ) {
		//크랙 프로그램 발견 경고
		wsprintf( szBuff,msg1100, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , (char *)lpTransCommand->LParam );

		if ( strstr( (char *)lpTransCommand->LParam , "FPE" )!=0 ) {
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );			//영구 블럭
			//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );	//24시간 블럭
		}
		else {
			//나쁜자들 명단에 등록
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60 );		//1시간 등록
		}

	}
	if ( lpTransCommand->WParam==1101 ) {
		//크랙 프로그램 발견 경고
		wsprintf( szBuff, msg1101, 
			st.wHour, st.wMinute , st.wSecond ,  lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , (char *)lpTransCommand->LParam );

		if ( strstr( (char *)lpTransCommand->LParam , "FPE" )!=0 ) {
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );	//영구 블럭
		}
		else {
			//나쁜자들 명단에 등록
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60 );		//1시간 등록
		}
	}

	if ( lpTransCommand->WParam==1102 ) {
		//클라이언트 체크섬 오류
		wsprintf( szBuff,msg1102, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*19 );		//19분 등록

	}

	if ( lpTransCommand->WParam==1103 ) {
		//클라이언트 체크섬 오류
		wsprintf( szBuff,msg1103, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==1110 ) {
		//클라이언트 소스보호 코드 오류
		wsprintf( szBuff,msg1110, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
/*
#ifdef	_LANGUAGE_CHINESE
		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*12 );	//1시간 등록
#else
*/
		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*1 );		//1시간 등록
//#endif
	}

	if ( lpTransCommand->WParam==1120 ) {
		//PlaySub모듈 소스보호 코드 오류
		wsprintf( szBuff,msg1120, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );

		//나쁜자들 명단에 등록
		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );		//24시간 등록
		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );			//영구 블럭

		//연결종료
		DisconnectUser( lpPlayInfo->lpsmSock );
	}

	if ( lpTransCommand->WParam==1130 ) {
		//클라이언트 펑션 검사 오류
		wsprintf( szBuff,msg1130, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );			//영구 블럭
		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24*15 );	//보름 등록
		rsAddBlockUserFile( lpPlayInfo->szID , szBuff );		//유저를 영구 블럭
	}

	if ( lpTransCommand->WParam==1132 ) {
		//클라이언트 펑션 검사 횟수 오류
		wsprintf( szBuff,msg1132, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );		//24 시간 등록
	}


	if ( lpTransCommand->WParam==1150 ) {
		//돈초과 물약복사 시도 
		wsprintf( szBuff,msg1150, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}


	if ( lpTransCommand->WParam==1200 ) {
		//스피드핵 경고
		wsprintf( szBuff,msg1200, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		lpPlayInfo->CrackWarning = lpTransCommand->WParam;

		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*2 );		//2시간 등록
		//DisconnectUser( lpPlayInfo->lpsmSock );					//연결 종료 시킴

		//클라이언트에 강제 저장후 종료 요구
		rsSendCloseClient( lpPlayInfo );
		//lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+10*1000;	//10초후 연결 종료

	}

	if ( lpTransCommand->WParam==1250 ) {
		//스피드핵 경고 - 게임서버로 부터수신
		wsprintf( szBuff,msg1250, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		lpPlayInfo->CrackWarning = lpTransCommand->WParam;
		//나쁜자들 명단에 등록
		//if ( !lpPlayInfo->BlockTime )
		//	lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*30 );		//30분 등록
		//DisconnectUser( lpPlayInfo->lpsmSock );

		//클라이언트에 강제 저장후 종료 요구
		rsSendCloseClient( lpPlayInfo );
		//lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+10*1000;	//10초후 연결 종료

	}

	if ( lpTransCommand->WParam==1400 ) {
		//스피드핵 경고 ( 시간오류 서버측 연결 강제 종료 )
		wsprintf( szBuff,msg1400, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		//시간 오류 ( 오차가 20초 이상 생긴 경우 유저 종료 )
		//DisconnectUser( lpPlayInfo->lpsmSock );
	}

	if ( lpTransCommand->WParam==1500 ) {
		//공격 비율 오류 
		wsprintf( szBuff,msg1500, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==1510 ) {
		//물약 첵크 오류 
		wsprintf( szBuff,msg1510, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		//물약 오류 캐릭 종료
		DisconnectUser( lpPlayInfo->lpsmSock );
	}

	if ( lpTransCommand->WParam==1530 ) {
		//물약 갯수 오류 
		wsprintf( szBuff,msg1530, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		if ( rsServerConfig.Dis_PotionError ) {
			//나쁜자들 명단에 등록
			if ( !lpPlayInfo->BlockTime )
				lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , rsServerConfig.Dis_PotionError*(1000*60) );
			//lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+10*1000;	//10초후 연결 종료
			lpPlayInfo->dwTime_Disconnect = 1;
			rsSendTransCommand( lpPlayInfo , smTRANSCODE_CLEARPOTION , 0,0,0,0 );		//물약 초기화
		}

		//물약 오류 캐릭 종료
		//DisconnectUser( lpPlayInfo->lpsmSock );
	}

	if ( lpTransCommand->WParam==1600 ) {
		//캐릭터 정보 코드 오류 
		wsprintf( szBuff,msg1600, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60 );		//60분 등록

	}

	if ( lpTransCommand->WParam==1800 ) {
		//( 경험치 획득 조작 방지 )
		wsprintf( szBuff,msg1800, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}
/*
	if ( lpTransCommand->WParam==1810 ) {
		//( 경험치 획득 조작 방지 )
		wsprintf( szBuff,msg1810, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}
*/
	if ( lpTransCommand->WParam==1820 ) {
		//( 일반 공격력 조작 오류 )
		wsprintf( szBuff,msg1820, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭

		rsSendCloseClient( lpPlayInfo );
	}

	if ( lpTransCommand->WParam==1821 ) {
		//( 일반 공격력 조작 오류 )
		wsprintf( szBuff,msg1821, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭

		rsSendCloseClient( lpPlayInfo );
	}

	if ( lpTransCommand->WParam==1823 ) {
		//( 5초 동안 과도한 공격 )
		wsprintf( szBuff,msg1823, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		rsSendCloseClient( lpPlayInfo );
	}

	if ( lpTransCommand->WParam==1830 ) {
		//( 스킬 공격력 조작 오류 )
		wsprintf( szBuff,msg1830, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==1833 ) {
		//( 5초 동안 과도한 공격 )
		wsprintf( szBuff,msg1833, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==1840 ) {
		//( 제한구역 침범 )
		wsprintf( szBuff,msg1840, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam  );

		if ( lpTransCommand->LParam==9100 ) {
			//SoD 경기장 침범
			rsSendCloseClient( lpPlayInfo );
		}
	}

	if ( lpTransCommand->WParam==1900 ) {
		//( 무게 오류 )
		wsprintf( szBuff,msg1900, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}


	if ( lpTransCommand->WParam==1950 ) {
		//( 로딩 아이템 오류 )
		wsprintf( szBuff,msg1950, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==1960 ) {
		//( 로딩 아이템 오류 )
		wsprintf( szBuff,msg1960, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}

	if ( lpTransCommand->WParam==2000 ) {
		//크랙 벌칙 종료 
		wsprintf( szBuff,msg2000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}

	if ( lpTransCommand->WParam==2100 ) {
		//레벨이 2단계 이상 급상승
		wsprintf( szBuff,msg2100, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);

		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
	}

	if ( lpTransCommand->WParam==2110 ) {
		//과도한 경험치 획득 ( 10만 이상 )
		wsprintf( szBuff,msg2110, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}

	if ( lpTransCommand->WParam==2120 ) {
		//빠른 경험치 획득 ( 렙20 이상 자기레벨 경험치의 10% 이상 )
		wsprintf( szBuff,msg2120, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam);
	}

	if ( lpTransCommand->WParam==2300 ) {
		//저장시 레벨문제 발생
		wsprintf( szBuff,msg2300, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}

	if ( lpTransCommand->WParam==2400 ) {
		//저장시 아이템측 문제 발생
		wsprintf( szBuff,msg2400, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}

	if ( lpTransCommand->WParam==2700 ) {
		//클라이언트 연속 저장 실패
		wsprintf( szBuff,msg2700, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}

	if ( lpTransCommand->WParam==2800 ) {
		//잘못된 계정에 캐릭 연결
		wsprintf( szBuff,msg2800, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==4000 ) {
		//트레이드 인증 오류 
		wsprintf( szBuff,msg4000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}

	if ( lpTransCommand->WParam==4100 ) {
		//돈 이동 오류 
		wsprintf( szBuff,msg4100, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}


	if ( lpTransCommand->WParam==5000 ) {
		//( 동일 IP 과다 연결 )
		wsprintf( szBuff,msg5000, 
			st.wHour, st.wMinute , st.wSecond , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==5100 ) {
		//( 과다 패킷 수신 )
		wsprintf( szBuff,msg5100, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==5200 ) {
		//게임서버IP오류
		wsprintf( szBuff,msg5200, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==6000 ) {
		//초기 캐릭정보 이상 ( 경험치 , 돈 ) 확인
		wsprintf( szBuff,msg6000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );

		//나쁜자들 명단에 등록
		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*1 );		//1시간 등록

	}

	if ( lpTransCommand->WParam==6100 ) {
		//레벨이 과도하게 높은경우
		wsprintf( szBuff,msg6100, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);
	}

	if ( lpTransCommand->WParam==6200 ) {
		//레벨이 과 경험치의 비가 맞지 않음
		wsprintf( szBuff,msg6200, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam);

		//나쁜자들 명단에 등록
		if ( lpPlayInfo->BlockTime<1000*60*10 )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*10 );		//10분 등록
	}

	if ( lpTransCommand->WParam==6500 ) {
		//보낸 경험치 대 받은경험치 오류
		wsprintf( szBuff,msg6500, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam);
/*
		//나쁜자들 명단에 등록
		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );		//영구 블럭
		lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+40*1000;
*/
	}

	if ( lpTransCommand->WParam==6510 ) {
		//보낸 돈 대 받은돈 오류
		wsprintf( szBuff,msg6510, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam);
/*
		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*30 );		//20분 등록

		lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+40*1000;
*/
	}

	if ( lpTransCommand->WParam==6600 ) {
		//예측 경험치와 실제 경험치의 차이가 많음
		wsprintf( szBuff,msg6600, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//나쁜자들 명단에 등록
		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*30 );		//30분 등록
		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );		//영구 블럭
	}
	if ( lpTransCommand->WParam==6610 ) {
		//예측 금액과 실제 금액의 차이가 많음
		wsprintf( szBuff,msg6610, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//나쁜자들 명단에 등록
		//if ( !lpPlayInfo->BlockTime )
		//	lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*30 );		//30분 등록
	}
	if ( lpTransCommand->WParam==6611 ) {
		//예측 금액과 실제 금액의 차이가 많음
		wsprintf( szBuff,msg6611, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*30 );		//30분 등록
	}
	if ( lpTransCommand->WParam==6612 ) {
		//예측 금액과 실제 금액의 차이가 많음
		wsprintf( szBuff,msg6612, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*30 );		//30분 등록
	}
	if ( lpTransCommand->WParam==6620 ) {
		//서버경험치에 비해 클라이언트에서 올린 경험치가 30%를 넘을때 ( 몬스터 톡톡 쳐서 얻은 경험치 )
		wsprintf( szBuff,msg6620, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60 );		//60분 등록
	}

	if ( lpTransCommand->WParam==6630 ) {
		//게임서버경험치로 클라이언트 경험치 보정
		wsprintf( szBuff,msg6630, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );

		//나쁜자들 명단에 등록
		//if ( !lpPlayInfo->BlockTime )
		//	lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60 );		//60분 등록
	}


	if ( lpTransCommand->WParam==6800 ) {
		//아이템 서버 첵크섬 오류
		wsprintf( szBuff,msg6800, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );

		if ( rsServerConfig.ItemCodeOut>0 ) {
			if ( (lpTransCommand->LParam&sinITEM_MASK1)<(sinPM1&sinITEM_MASK1) ) {
				lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭 ( 장착 가능 아이템이 조작된 경우에만 )
			}
			lpPlayInfo->dwTime_Disconnect = 1;
		}
	}
	if ( lpTransCommand->WParam==6810 ) {
		//아이템 임시 첵크섬 오류
		wsprintf( szBuff,msg6810, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );

		if ( rsServerConfig.ItemCodeOut>1 ) {
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );	//4시간 등록
			DisconnectUser( lpPlayInfo->lpsmSock );
		}
	}
	if ( lpTransCommand->WParam==6900 ) {
		//캐릭터 스텟 오류
		wsprintf( szBuff,msg6900, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭

	}
	if ( lpTransCommand->WParam==6910 ) {
		//캐릭터 스킬 포인트 오류
		wsprintf( szBuff,msg6910, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , (lpTransCommand->SParam&0xFFFF) , (lpTransCommand->SParam>>16), lpTransCommand->EParam );

		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*20 );	//24시간 등록
		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
	}

	if ( lpTransCommand->WParam==6920 ) {
		//캐릭터 아이템 무게 오류
		wsprintf( szBuff,msg6920, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*20 );	//24시간 등록
		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
	}


	if ( lpTransCommand->WParam==7000 ) {
		//클라이언트의 프로세스가 일정시간동안 정지했음을 감지 ( 프로세스 디버거 경고 )
		wsprintf( szBuff,msg7000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*10 );	//10 분동안 블럭
	}

	if ( lpTransCommand->WParam==7010 ) {
		//클라이언트 인벤토리 아이템 오류
		wsprintf( szBuff,msg7010, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*10 );	//10 분동안 블럭

		if ( lpPlayInfo->AdminMode ) {
			rsSendCloseClient( lpPlayInfo );		//관리자 클라이언트는 종료 시킴
		}

	}

	if ( lpTransCommand->WParam==7020 ) {
		//캐릭터 모델 오류
		wsprintf( szBuff,msg7020, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==7030 ) {
		//직업 코드 오류
		wsprintf( szBuff,msg7030, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==7100 ) {
		//클라이언트 공격/방어 수치 오류
		wsprintf( szBuff,msg7100, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}
	if ( lpTransCommand->WParam==7110 ) {
		//클라이언트 에너지바 오류 ( 20개 까지 기록 )
		if ( lpPlayInfo->WarningCount>10+(rand()%10) ) {
/*
#ifdef _LANGUAGE_CHINESE
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//블럭
			if ( !lpPlayInfo->dwHopeDisconnectTime )
				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+11000;
#endif
*/
				return FALSE;
		}

		wsprintf( szBuff,msg7110, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}
	if ( lpTransCommand->WParam==7120 ) {
		//경험치 통신 오류
		wsprintf( szBuff,msg7120, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );

		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
		lpPlayInfo->dwHopeDisconnectTime = 30000;
	}

	if ( lpTransCommand->WParam==7130 ) {
		//땅에서 복사아이템 발견
		wsprintf( szBuff,msg7130, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==7140 ) {
		//접속 금지 IP 접속 시도
		wsprintf( szBuff,msg7140, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->lpsmSock->szIPAddr );

		rsAddBackListID( lpPlayInfo->szID , 1000*60*16 );			//16분동안 재접속 불허

		return FALSE;
	}

	if ( lpTransCommand->WParam==7150 ) {
		//인벤토리에 복사아이템 발견
		wsprintf( szBuff,msg7150, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}
	if ( lpTransCommand->WParam==7160 ) {
		//인벤토리에 돈 복사 발견
		wsprintf( szBuff,msg7160, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8000 ) {
		//클라이언트 소유 아이템 오류
		wsprintf( szBuff,msg8000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->WxParam , lpTransCommand->LxParam , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8010 ) {
		//클라이언트 소유 돈 오류
		wsprintf( szBuff,msg8010, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8020 ) {
		//서버간 아이템 이동 코드 오류
		wsprintf( szBuff,msg8020, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8030 ) {
		//저장데이타 캐릭이름이 서버의 이름과 틀림
		wsprintf( szBuff,msg8030, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8040 ) {

		if ( lpPlayInfo->smCharInfo.Level>=21 ) {
			//레벨 21 이상인 경우에만 연결 종료 시키기

			rsSendCloseClient( lpPlayInfo );

// 중국 임시주석
#ifdef	_LANGUAGE_CHINESE
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3*60*1000;				//3분후 종료
#endif
#ifdef	_LANGUAGE_ENGLISH
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3*60*1000;				//3분후 종료
#endif
#ifdef	_LANGUAGE_BRAZIL
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3*60*1000;				//3분후 종료
#endif
#ifdef	_LANGUAGE_ARGENTINA
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
			lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+3*60*1000;				//3분후 종료
#endif
		}

		if ( lpPlayInfo->WarningCount>10 ) return FALSE;

		//아이템 착용위치 틀림
		wsprintf( szBuff,msg8040, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );


	}

	if ( lpTransCommand->WParam==8050 ) {
		//인벤 아이템 버퍼 초과
		wsprintf( szBuff,msg8050, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );

//		rsSendCloseClient( lpPlayInfo );
//		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 60*60*1000 );	//1시간 블럭 (오토마우스 사용자)

		if ( lpPlayInfo->WarningCount>2 ) {
			if ( lpPlayInfo->WarningCount>6 ) {
				rsSendCloseClient( lpPlayInfo );
			}
			else {
				//배드 플레이어 게임서버에 설정
				rsSend_BadPlayerToGameServer( lpPlayInfo->lpsmSock , 1 );
			}
		}

	}

	if ( lpTransCommand->WParam==8060 ) {
		//사용한 아이템 오류
		wsprintf( szBuff,msg8060, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8070 ) {
		//로딩시 복사된듯한 아이템 발견
		wsprintf( szBuff,msg8070, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->WxParam , lpTransCommand->LxParam , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8080 ) {
		//메모리버퍼 저장오류
		wsprintf( szBuff,msg8080, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8100 ) {
		//오토마우스 경고
		wsprintf( szBuff,msg8100, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );

		if ( lpTransCommand->LParam>=200 && lpPlayInfo->WarningCount>4 ) {
			//배드 플레이어 게임서버에 설정
			rsSend_BadPlayerToGameServer( lpPlayInfo->lpsmSock , 1 );
		}
/*
		if ( lpPlayInfo->WarningCount>5 ) {
			//배드 플레이어 게임서버에 설정
			rsSend_PlayerKilling( lpPlayInfo->lpsmSock );
		}
*/
	}

	if ( lpTransCommand->WParam==8102 ) {
		//매크로 오토 마우스 경고
		wsprintf( szBuff,msg8102, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8110 ) {
		//공격력 비율오류 ( 방어 )
		wsprintf( szBuff,msg8110, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8120 ) {
		//공격력 비율오류 ( 공격 )
		wsprintf( szBuff,msg8120, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8130 ) {
		//nSprite 연결종료
		wsprintf( szBuff,msg8130, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==8140 ) {
		//nSprite 연결 유효시간 초과 종료
		wsprintf( szBuff,msg8140, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}


	if ( lpTransCommand->WParam==8200 ) {
		//복사아이템 에이징 실패 ( 쉘텀 )
		wsprintf( szBuff,msg8200, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}
	if ( lpTransCommand->WParam==8210 ) {
		//복사아이템 에이징 실패 ( 일반 아이템 )
		wsprintf( szBuff,msg8210, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam , lpTransCommand->SxParam , lpTransCommand->ExParam );
	}

	if ( lpTransCommand->WParam==8300 ) {
		//서버와 재연결 성공
		wsprintf( szBuff,msg8300, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==8400 ) {
		//서버인벤토리 확인 [연결종료]
		wsprintf( szBuff,msg8400, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==8500 ) {
		//데미지 패킷 오류
		wsprintf( szBuff,msg8500, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8510 ) {
		//데미지 제한치 초과
		wsprintf( szBuff,msg8510, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->WxParam , 
			lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam,
			lpTransCommand->LxParam , lpTransCommand->SxParam , lpTransCommand->ExParam );
	}

	if ( lpTransCommand->WParam==8520 ) {
		//모션 속도 오류
		wsprintf( szBuff,msg8520, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==8530 ) {
		//모션 속도 오류
		wsprintf( szBuff,msg8530, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==8540 ) {
		//스킬 조작 오류
		wsprintf( szBuff,msg8540, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
/*
#ifdef _LANGUAGE_CHINESE
		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//블럭
#endif
*/
		DisconnectUser( lpPlayInfo->lpsmSock );
	}

	if ( lpTransCommand->WParam==8550 ) {

		if ( lpPlayInfo->WarningCount>30 ) return FALSE;

		//스킬 조작 오류2
		wsprintf( szBuff,msg8550, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
/*
#ifdef _LANGUAGE_CHINESE
		lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+6000;
#endif
*/

	}

	if ( lpTransCommand->WParam==8560 ) {
		//캐릭터 32비트 경험치 오류
		wsprintf( szBuff,msg8560, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
/*
#ifdef _LANGUAGE_CHINESE
		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//블럭
#endif
*/
	}

	if ( lpTransCommand->WParam==8570 ) {
		//과다한 업데이트로 연결 종료
		wsprintf( szBuff,msg8570, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );

		rsSendCloseClient( lpPlayInfo );		//종료 시키기
	}

	if ( lpTransCommand->WParam==8580 ) {
		//클라이언트 데미지 패킷 오류
		wsprintf( szBuff,msg8580, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		rsSendCloseClient( lpPlayInfo );		//종료 시키기
	}

	if ( lpTransCommand->WParam==8600 ) {
		//무적 모드 경고
		if ( lpPlayInfo->WarningCount>20+(rand()%10) ) {
/*
#ifdef _LANGUAGE_CHINESE
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//블럭
			if ( !lpPlayInfo->dwHopeDisconnectTime )
				lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+11000;
#endif
*/
			return FALSE;
		}

		wsprintf( szBuff,msg8600, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==8700 ) {
		//GameGuard 연결종료
		wsprintf( szBuff,msg8700, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==8710 ) {
		//GameGuard 연결 유효시간 초과 종료
		wsprintf( szBuff,msg8710, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==8720 ) {
		//수상한 모듈 발견
		wsprintf( szBuff,msg8720, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==8730 ) {
		//캐릭터 속성 오류
		wsprintf( szBuff,msg8730, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==8800 ) {
		//서버물약 갯수 오류
		wsprintf( szBuff,msg8800, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8810 ) {
		//서버물약 갯수 이동 오류
		wsprintf( szBuff,msg8810, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}

	if ( lpTransCommand->WParam==8820 ) {
		//퀘스트 코드 조작 경고
		wsprintf( szBuff,msg8820, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

	}

	if ( lpTransCommand->WParam==8830 ) {
		//상점에서 위조 아이템 발견
		wsprintf( szBuff,msg8830, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

	}

	if ( lpTransCommand->WParam==8840 ) {
		//서버 돈 수치오류
		wsprintf( szBuff,msg8840, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->WxParam , lpTransCommand->LxParam , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}


	if ( lpTransCommand->WParam==8850 ) {
		//스킬 사용레벨 오류
		wsprintf( szBuff,msg8850, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	if ( lpTransCommand->WParam==8860 ) {
		//필드 지형 확인 오류
		wsprintf( szBuff,msg8860, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->WxParam , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam , lpTransCommand->LxParam );
	}

	if ( lpTransCommand->WParam==8870 ) {
		//클랜 코드 비교 오류
		wsprintf( szBuff,msg8870, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
	}


	if ( lpTransCommand->WParam==8880 ) {
		//모델 파일 오류 (스킨핵 방지)
		wsprintf( szBuff,msg8880, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		rsSendCloseClient( lpPlayInfo );
	}

	if ( lpTransCommand->WParam==8890 ) {
		//캐릭터 재로딩 시도경고 (한게임돈복사 조사중)
		wsprintf( szBuff,msg8890, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam, lpTransCommand->EParam );

		lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
	}

	if ( lpTransCommand->WParam==8900 ) {
		//NPC기능 필드오류 (치트사용유무로그)
		wsprintf( szBuff,msg8900, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}
	
#ifdef _CHECK_MESH
	if ( lpTransCommand->WParam==8910 ) {
		//아이템메쉬 첵크오류
		wsprintf( szBuff,msg8910, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}
#endif

	//Kyle // 필드서버 불법접근
	if ( lpTransCommand->WParam==8920 ) {
		//아이템메쉬 첵크오류
		wsprintf( szBuff,msg8920, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}


	if ( lpTransCommand->WParam==99000 ) {
		//믹스쳐 오류 첵크용

		wsprintf( szBuff, "%d:%d:%d - ID:( %s ) / Name:( %s ) / IP ( %s ) Item Mixing Error ( %d )( %d )\r\n", 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );

		//lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
	}



	if ( lpTransCommand->WParam==10000 ) {
		//저장 데이타 불일치
		wsprintf( szBuff,msg10000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==10001 ) {
		//저장 데이타 불일치
		wsprintf( szBuff,msg10001, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==10002 ) {
		//저장 데이타 불일치
		wsprintf( szBuff,msg10002, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==10003 ) {
		//저장 데이타 불일치
		wsprintf( szBuff,msg10003, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==10005 ) {
		//저장 데이타 불일치
		wsprintf( szBuff,msg10005, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==10006 ) {
		//저장 데이타 불일치
		wsprintf( szBuff,msg10006, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}
	if ( lpTransCommand->WParam==10007 ) {
		//데이타 버퍼 포인트 이상
		wsprintf( szBuff,msg10007, 
			st.wHour, st.wMinute , st.wSecond ,
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->SParam,lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==10010 ) {
		//캐릭터 마지막 저장계정과 로딩 계정이 틀림
		wsprintf( szBuff,msg10010, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam );
	}

	if ( lpTransCommand->WParam==10020 ) {
		//로그인시 계정 오류
		wsprintf( szBuff,msg10020, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}


	if ( lpTransCommand->WParam==11000 ) {
		//서버를 셧다운 시킴
		wsprintf( szBuff,msg11000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr );
	}

	//////////////////////////// 이벤트 기록 //////////////////////////////////////
	if ( lpTransCommand->WParam==21000 ) {
		//이벤트에서 고득점
		wsprintf( szBuff,msg21000, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->LParam , lpTransCommand->SParam );
	}

	///////////////////////////////////////////////////////////////////////////////


	if ( lpTransCommand->WParam<1000 ) {

		char	szTemp[256];
		wsprintf( szTemp , "logfile [ %d %d %d %d ]\r\n" ,
			lpTransCommand->WParam ,  lpTransCommand->LParam , lpTransCommand->SParam , lpTransCommand->EParam );
		Record_TempLogFile( szTemp );

		//디버그용 ( 임시 )
		if ( LoginServer ) {
			wsprintf( szTemp , "DebugLog - LastMsg( %d ) LastUserID( %s ) LastUserName( %s ) DebugCount( %d )\r\n" ,
				dwServer_DebugMessage ,  szServer_DebugLastUserID , szServer_DebugLastUserName , Server_DebugCount );
		}
		Record_TempLogFile( szTemp );


		//Record_TempLogFile( szBuff );

		if ( lpTransCommand->WParam!=100 ) {
			//해킹 경고
			wsprintf( szBuff,msgHack, 
				st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
				lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->WParam );

			if ( lpTransCommand->WParam==82 || lpTransCommand->WParam==83 || lpTransCommand->WParam==5 ) {
				lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//블럭
				lpPlayInfo->dwHopeDisconnectTime = 2000;
			}
			if ( lpTransCommand->WParam==55 || lpTransCommand->WParam==54 ) {
				if ( lpPlayInfo->AdminMode>=2 ) return FALSE;								//관리자모드 무시
				if ( lpPlayInfo->WarningCount>12 && !lpPlayInfo->dwHopeDisconnectTime )
					lpPlayInfo->dwHopeDisconnectTime = 2000;
			}
		}
		else {
			//해킹 경고
			wsprintf( szBuff,msgHack100, 
				st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
				lpPlayInfo->lpsmSock->szIPAddr , lpTransCommand->WParam , lpTransCommand->SParam , lpTransCommand->LParam , lpTransCommand->EParam );
/*
			if ( lpPlayInfo->smCharInfo.Level>=20 && lpPlayInfo->smCharInfo.Level<40 ) {
				if ( lpTransCommand->SParam>=50 || lpTransCommand->LParam>=90 || lpTransCommand->EParam>=800) 
					lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
			}
			if ( lpPlayInfo->smCharInfo.Level>=40 && lpPlayInfo->smCharInfo.Level<60 ) {
				if ( lpTransCommand->SParam>=80 || lpTransCommand->LParam>=120 || lpTransCommand->EParam>=1100 ) 
					lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
			}
			if ( lpPlayInfo->smCharInfo.Level>=60 ) {
				if ( lpTransCommand->SParam>=150 || lpTransCommand->LParam>=180 || lpTransCommand->EParam>=1500 ) 
					lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 0x7FFFFFFF );	//영구블럭
			}
*/
			if ( lpPlayInfo->BlockTime && lpTransCommand->LParam>=140 ) {
				lpPlayInfo->BadPlayer = 2;

				smTransCommand.code = smTRANSCODE_BAD_PLAYER;
				smTransCommand.size = sizeof( smTRANS_COMMAND );
				smTransCommand.WParam = 2;
				smTransCommand.LParam = 0;
				smTransCommand.SParam = 0;
				smTransCommand.EParam = 0;

				if ( lpPlayInfo->lpsmSock )
					rsSendGameServer( lpPlayInfo->lpsmSock , &smTransCommand );
			}
		}

//		Record_TempLogFile( szBuff );

		//나쁜자들 명단에 등록
		if ( !lpPlayInfo->BlockTime && lpTransCommand->WParam!=99 )
			lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*21 );		//21분 등록

		Record_TempLogFile( szBuff );
		Record_TempLogFile( szFileName );
		Record_TempLogFile( HackLogDirectory );

	}

LogSkip:

	if ( lpTransCommand->WParam==50000 ) {
		//시간 만료 ( TimeOverflow - 약 50일 주기 )
		wsprintf( szBuff, "%d:%d:%d >**** Timer Overflow **** - ( %d / %d )\r\n", 
			st.wHour, st.wMinute , st.wSecond , lpTransCommand->LParam , lpTransCommand->SParam );
	}
	if ( lpTransCommand->WParam==50010 ) {
		//서버 셧다운 실행
		wsprintf( szBuff, "%d:%d:%d >**** Shutdown Service **** - ( %d / %d )\r\n", 
			st.wHour, st.wMinute , st.wSecond , lpTransCommand->LParam , lpTransCommand->SParam );
	}
	if ( lpTransCommand->WParam==50020 ) {
		//서버 서비스 시작
		wsprintf( szBuff, "%d:%d:%d >**** Starting Service **** - ( %d / %d )\r\n", 
			st.wHour, st.wMinute , st.wSecond , lpTransCommand->LParam , lpTransCommand->SParam );
	}
	if ( lpTransCommand->WParam==50030 ) {
		//서버 서비스 종료
		wsprintf( szBuff, "%d:%d:%d >**** Closed Service **** - ( %d / %d )\r\n", 
			st.wHour, st.wMinute , st.wSecond , lpTransCommand->LParam , lpTransCommand->SParam );
	}


#endif

	CreateDirectory( HackLogDirectory , NULL );			//디렉토리 생성

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) {
		return FALSE;
	}

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	if ( lpPlayInfo ) lpPlayInfo->WarningCount++;

	return TRUE;
}

//디버그 접속 유저 기록 파일로 남김
int RecordDebugPlayLogFile( rsPLAYINFO *lpPlayInfo )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	GetLocalTime( &st );
	wsprintf( szFileName , filenameDebugLogin , DebugLogDirectory , st.wMonth , st.wDay );

	if ( lpPlayInfo->szID[0] ) {
		wsprintf( szBuff,msgDebugloginID, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpPlayInfo->AdminMode );
	}
	else {
		wsprintf( szBuff,msgDebugloginIP, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->smCharInfo.szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpPlayInfo->AdminMode );
	}

	CreateDirectory( DebugLogDirectory , NULL );			//디렉토리 생성

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}


//전업자 기록 파일로 남김
int RecordJobChanger( rsPLAYINFO *lpPlayInfo )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	GetLocalTime( &st );
	wsprintf( szFileName , "LogFile\\(전업)%d월%d일.log" , st.wMonth , st.wDay );

	wsprintf( szBuff, "ID( %s ) Name( %s ) IP( %s ) - 직업( %d )/전업( %d )/레벨( %d )\r\n", 
		lpPlayInfo->szID , lpPlayInfo->szName ,lpPlayInfo->lpsmSock->szIPAddr , 
		lpPlayInfo->smCharInfo.JOB_CODE , lpPlayInfo->smCharInfo.ChangeJob , lpPlayInfo->smCharInfo.Level );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}

//기타 임시 기록 파일로 남김
int Record_TempLogFile( char *szMessage )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	int len;
	char	szFileName[128];
	char	szBuff[256];

	GetLocalTime( &st );
	wsprintf( szFileName , "LogFile\\(Temp)%d-%d.log" , st.wMonth , st.wDay );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;


	wsprintf( szBuff , "%d:%d:%d - %s" , st.wHour, st.wMinute , st.wSecond , szMessage );
	len = lstrlen(szBuff);
	if ( szBuff[len-1]!='\n' ) {
		szBuff[len]='\r';
		szBuff[len+1]='\n';
		len +=2;
	}

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , len , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}

//빌링 접속 종료 기록 파일로 남김
int Record_BillingLogFile( rsPLAYINFO *lpPlayInfo , DWORD wParam , DWORD lParam , DWORD sParam , DWORD eParam )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if ( !lpPlayInfo || !lpPlayInfo->lpsmSock ) return FALSE;

	lpPlayInfo->szID[31]=0;lpPlayInfo->szName[31]=0;

	GetLocalTime( &st );
	wsprintf( szFileName , "LogFile\\(Billing)%d-%d.log" , st.wMonth , st.wDay );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	wsprintf( szBuff , "%d:%d:%d - ID( %s ) Name( %s ) IP( %s ) - DisuseDay(%d) dwPeriodTime(%d) tTime(%d) PcUse(%d)\r\n" , st.wHour, st.wMinute , st.wSecond , 
		lpPlayInfo->szID , lpPlayInfo->szName , lpPlayInfo->lpsmSock->szIPAddr , wParam , lParam , sParam , eParam );

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}

//캐릭터 사망 기록 파일로 남김
int Record_DeadUser( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if ( !lpPlayInfo->lpsmSock || lpPlayInfo->smCharInfo.Level<30 ) return FALSE;

	GetLocalTime( &st );
	wsprintf( szFileName , "LogFile\\(Death)%d월%d일.log" , st.wMonth , st.wDay );

	wsprintf( szBuff, "%d:%d:%d - ID( %s ) Name( %s ) IP( %s ) - Level( %d )/Area( %d )\r\n", 
		st.wHour, st.wMinute , st.wSecond , 
		lpPlayInfo->szID , lpPlayInfo->szName ,lpPlayInfo->lpsmSock->szIPAddr , 
		lpPlayInfo->smCharInfo.Level , lpPlayInfo->Position.Area );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}


//아이템 믹스 기록
int RecordMixItem( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpSrcItem , sITEMINFO *lpMixItem )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	GetLocalTime( &st );
	wsprintf( szFileName , filenameMixItem , HackLogDirectory , st.wMonth , st.wDay );

	wsprintf( szBuff,msgMixItem, 
			st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
			lpPlayInfo->lpsmSock->szIPAddr , lpSrcItem->ItemName , 
			lpSrcItem->ItemHeader.Head , lpSrcItem->ItemHeader.dwChkSum , lpSrcItem->ItemHeader.dwTime ,
			lpMixItem->ItemHeader.Head , lpMixItem->ItemHeader.dwChkSum , lpMixItem->ItemHeader.dwTime	);

	//CreateDirectory( DebugLogDirectory , NULL );			//디렉토리 생성

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}

//아이템 에이징 기록
int RecordAgingItem( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpSrcItem , sITEMINFO *lpMixItem , int Mode )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];
	char	*lpMsg;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	GetLocalTime( &st );
	wsprintf( szFileName , filenameAgingItem , HackLogDirectory , st.wMonth , st.wDay );

	if ( lpMixItem ) {
		if ( !Mode ) lpMsg=msgAgingItem;
		else lpMsg=msgAgingUpItem;

		wsprintf( szBuff,lpMsg, 
				st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
				lpPlayInfo->lpsmSock->szIPAddr , lpSrcItem->ItemName , lpMixItem->ItemAgingNum[0] ,
				lpSrcItem->ItemHeader.Head , lpSrcItem->ItemHeader.dwChkSum , lpSrcItem->ItemHeader.dwTime ,
				lpMixItem->ItemHeader.Head , lpMixItem->ItemHeader.dwChkSum , lpMixItem->ItemHeader.dwTime	);

	}
	else {
		wsprintf( szBuff,msgAgingFailItem, 
				st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
				lpPlayInfo->lpsmSock->szIPAddr , lpSrcItem->ItemName , lpSrcItem->ItemAgingNum[0] ,
				lpSrcItem->ItemHeader.Head , lpSrcItem->ItemHeader.dwChkSum , lpSrcItem->ItemHeader.dwTime );
	}

	//CreateDirectory( DebugLogDirectory , NULL );			//디렉토리 생성

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}


char *szRecordCollectDirectory = "CollMoney";

//기부금 파일로 기록
int RecordCollectMoney( rsPLAYINFO *lpPlayInfo , int Money )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];
	int		TotalMoney = 0;
	FILE	*fp;

	CreateDirectory( szRecordCollectDirectory , NULL );			//디렉토리 생성
	GetLocalTime( &st );

	wsprintf( szFileName ,filenameCollectMoney, szRecordCollectDirectory , st.wMonth , st.wDay );

	//토탈 금액 로딩
	fp = fopen( szFileName , "rb" );
	if ( fp ) {
		fread( szBuff , 256 , 1, fp );
		fclose(fp);
		TotalMoney = atoi(szBuff);
	}

	TotalMoney += Money;

	//토탈 금액 저장
	fp = fopen( szFileName , "wb" );
	if ( fp ) {
		wsprintf( szBuff, "%d" , TotalMoney );
		fwrite( szBuff , lstrlen(szBuff)+1 , 1, fp );
		fclose(fp);
	}

	wsprintf( szFileName ,filenameCollectMoney, szRecordCollectDirectory , st.wMonth , st.wDay );

	wsprintf( szBuff, msgKindPeople , 
		st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
		lpPlayInfo->lpsmSock->szIPAddr , Money , TotalMoney );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}


//돈 기록 파일로 남김
int RecordHackLogMoney( smCHAR_INFO *lpCharInfo )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];


	if ( !lpCharInfo ) return FALSE;

	GetLocalTime( &st );
	wsprintf( szFileName , filenameHackLogMoney , HackLogDirectory , st.wMonth , st.wDay );

	CreateDirectory( HackLogDirectory , NULL );			//디렉토리 생성

	wsprintf( szBuff, msgHackMoney , 
			st.wHour, st.wMinute , st.wSecond , 
			lpCharInfo->szName, lpCharInfo->Level , lpCharInfo->Money );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );


	return TRUE;


}

//고가의 아이템 입수 기록 파일로 남김
int RecordGetHighItem( rsPLAYINFO *lpPlayInfo , STG_ITEMS *lpStgItem )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if ( !lpPlayInfo || !lpStgItem ) return FALSE;
	if ( !lpStgItem->BeginMode ) return FALSE;

	GetLocalTime( &st );
	wsprintf( szFileName , filenameGetHighItem , HackLogDirectory , st.wMonth , st.wDay );

	CreateDirectory( HackLogDirectory , NULL );			//디렉토리 생성

	wsprintf( szBuff,msgHighItem, 
			st.wHour, st.wMinute , st.wSecond , 
			lpPlayInfo->smCharInfo.szName, lpPlayInfo->smCharInfo.Level ,
			lpStgItem->Item.ItemInfo.ItemName,
			lpStgItem->Item.ItemInfo.CODE,
			lpStgItem->Item.ItemInfo.ItemHeader.Head,
			lpStgItem->Item.ItemInfo.ItemHeader.dwChkSum,
			lpStgItem->Item.ItemInfo.JobCodeMask,
			lpStgItem->BeginMode );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}



//캐릭터 제거 기록 파일로 남김
int RecordDeleteCharacter( char *szID , char *szIP, smCHAR_INFO *lpCharInfo )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if ( !szID || !szIP || !lpCharInfo ) return FALSE;

	GetLocalTime( &st );
	wsprintf( szFileName , filenameDeleteCharacter , LogDirectory , st.wMonth , st.wDay );

	CreateDirectory( LogDirectory , NULL );			//디렉토리 생성

	wsprintf( szBuff,msgCharDelete1, 
			st.wHour, st.wMinute , st.wSecond , 
			szID , lpCharInfo->szName, szIP , lpCharInfo->Level, 
			lpCharInfo->Exp, lpCharInfo->Money );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}

//캐릭터 제거 기록 파일로 남김
int RecordDeleteCharacterError( char *szID , char *szName )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	GetLocalTime( &st );
	wsprintf( szFileName ,filenameDeleteCharactererror, LogDirectory , st.wMonth , st.wDay );

	CreateDirectory( LogDirectory , NULL );			//디렉토리 생성

	wsprintf( szBuff,msgCharDelete2, 
			st.wHour, st.wMinute , st.wSecond , 
			szID , szName );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}



//블랙 유저 기록 파일로 남김
int RecordBlackUser( char *szID , DWORD dwTime  )
{
#ifdef _W_SERVER

	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if ( !szID ) return FALSE;


	GetLocalTime( &st );
	wsprintf( szFileName , filenameBlackUser , LogDirectory , st.wMonth , st.wDay );

	CreateDirectory( LogDirectory , NULL );			//디렉토리 생성

	wsprintf( szBuff,msgBlackUser,
			st.wHour, st.wMinute , st.wSecond , 
			szID , dwTime/(1000*60) );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

#endif

	return TRUE;
}

// pluto 제련 아이템 기록
int RecordSmeltingItem( rsPLAYINFO *lpPlayInfo , sITEMINFO *lpSmeltingItem )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if( !lpPlayInfo->lpsmSock )
	{
		return FALSE;
	}

	GetLocalTime( &st );
	wsprintf( szFileName , filenameSmeltingItem , HackLogDirectory , st.wMonth , st.wDay );

	wsprintf( szBuff,msgSmeltingItem, 
		st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
		lpPlayInfo->lpsmSock->szIPAddr , lpSmeltingItem->ItemName , 
		lpSmeltingItem->ItemHeader.Head , lpSmeltingItem->ItemHeader.dwChkSum , lpSmeltingItem->ItemHeader.dwTime );


	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if( hFile==INVALID_HANDLE_VALUE )
	{
		return FALSE;
	}

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}
// pluto 제작 아이템 기록
int RecordManufactureItem( rsPLAYINFO *lpPlayInfo, sITEMINFO *lpManufactureItem )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];

	if( !lpPlayInfo->lpsmSock )
	{
		return FALSE;
	}

	GetLocalTime( &st );
	wsprintf( szFileName , filenameManufactureItem , HackLogDirectory , st.wMonth , st.wDay );

	wsprintf( szBuff,msgManufactureItem, 
		st.wHour, st.wMinute , st.wSecond , lpPlayInfo->szID , lpPlayInfo->szName , 
		lpPlayInfo->lpsmSock->szIPAddr , lpManufactureItem->ItemName , 
		lpManufactureItem->ItemHeader.Head , lpManufactureItem->ItemHeader.dwChkSum , lpManufactureItem->ItemHeader.dwTime );


	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if( hFile==INVALID_HANDLE_VALUE )
	{
		return FALSE;
	}

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , lstrlen(szBuff) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}

#ifdef _W_SERVER
char	*szBlackUserDir = "BlackUser";
char	*szEverBlockDir = "BlockUser";
#else
char	*szBlackUserDir = "WhiteBird";
char	*szEverBlockDir = "StoneBird";
#endif



//유저를 영구 블럭
int rsAddBlockUserFile( char *szID , char *szLog )
{
	char szBuff[256];
	FILE *fp;

	if ( !rsServerConfig.ForeverBlockMode )	return FALSE;

	CreateDirectory( szEverBlockDir , NULL );			//디렉토리 생성

	wsprintf( szBuff , "%s\\%s.fev" , szEverBlockDir , szID );

	//생성
	fp = fopen( szBuff , "wb" );
	if ( fp ) {
		fwrite( szLog, lstrlen( szLog ) , 1, fp );
		fclose(fp);
	}

	return TRUE;
}

//유저 영구블럭 확인
int	rsCheckBlockUserFile( char *szID )
{

	HANDLE hFindHandle;
	WIN32_FIND_DATA	fd;
	char szBuff[256];

	wsprintf( szBuff , "%s\\%s.fev" , szEverBlockDir , szID );

	//파일을 찾음( 확장자 변경 파일 )
	hFindHandle = FindFirstFile( szBuff , &fd );
	if ( hFindHandle==INVALID_HANDLE_VALUE ) {
		return FALSE;
	}
	FindClose( hFindHandle );
	return TRUE;
}



//블랙 유저 파일을 모두 초기화
int ResetBlackUserFiles()
{

	HANDLE hFindHandle;
	WIN32_FIND_DATA	fd;
	char szBuff[256];

	wsprintf( szBuff , "%s\\*.bur" ,szBlackUserDir  );
	CreateDirectory( szBlackUserDir , NULL );			//디렉토리 생성

	//파일을 찾음( 확장자 변경 파일 )
	hFindHandle = FindFirstFile( szBuff , &fd );
	if ( hFindHandle==INVALID_HANDLE_VALUE ) {
		FindClose( hFindHandle );
		return 0;
	}
	while(1) {
		wsprintf( szBuff , "%s\\%s" ,szBlackUserDir , fd.cFileName );
		DeleteFile( szBuff );
		if ( FindNextFile( hFindHandle , &fd )==FALSE ) break;
	}
	FindClose( hFindHandle );


	return TRUE;
}

//블랙 유저 등록 또는 삭제
int ResetBlackUserFiles( char *szID , DWORD dwTime )
{
	char szBuff[256];
	char szBuff2[256];
	FILE *fp;
	SYSTEMTIME	st;


	wsprintf( szBuff , "%s\\%s.bur" , szBlackUserDir , szID );

	if ( dwTime ) {
		//생성
		GetLocalTime( &st );
		wsprintf( szBuff2, msgBlackUser, st.wHour, st.wMinute , st.wSecond , szID , dwTime/(1000*60) );
		fp = fopen( szBuff , "wb" );
		if ( fp ) {
			fwrite( szBuff2, lstrlen( szBuff2 ) , 1, fp );
			fclose(fp);
		}
	}
	else {
		//지움
		DeleteFile( szBuff );
	}

	return TRUE;
}

//블랙 유저 파일을 찾는다
int FindBlackUserFile( char *szID )
{

	HANDLE hFindHandle;
	WIN32_FIND_DATA	fd;
	char szBuff[256];

	wsprintf( szBuff , "%s\\%s.bur" ,szBlackUserDir , szID  );

	//파일을 찾음( 확장자 변경 파일 )
	hFindHandle = FindFirstFile( szBuff , &fd );

	if ( hFindHandle==INVALID_HANDLE_VALUE ) {
		return FALSE;
	}

	FindClose( hFindHandle );
	return TRUE;
}

int rsCompareCharInfo( smCHAR_INFO *cSrc , smCHAR_INFO *cDest )
{








	return TRUE;
}

struct	srBLACK_LIST {
	char	szID[32];		//ID
	DWORD	dwFreeTime;		//설정 시간 (이 시간 이후에 풀림 )
};

#define	srBLACK_LIST_MAX	400

//블랙리스트 명단
srBLACK_LIST	srBlackList[srBLACK_LIST_MAX];
int	rsBlackListInit=0;

//나쁜자들 명단 등록
int rsAddBackListID( char *szID , DWORD dwTime )
{
	int cnt;
	DWORD	dwBloackTime;
	DWORD	dwFreeTime;

	if ( !szID[0] ) return FALSE;

	if ( !rsBlackListInit ) {
		//나쁜자들 명단 모두 초기화
		rsResetBackList();
	}

	dwBloackTime = dwTime;

	if ( rsServerConfig.BlockLevel>0 ) {
		dwBloackTime = dwTime / rsServerConfig.BlockLevel;
	}
	if ( rsServerConfig.BlockLevel<0 ) {
		dwBloackTime = dwTime * abs(rsServerConfig.BlockLevel);
	}

	if ( rsServerConfig.BlockLevel_LogOut ) 
		return dwBloackTime;


	dwFreeTime = dwPlayServTime+dwBloackTime;
	if ( dwFreeTime<dwPlayServTime ) dwFreeTime = 0xFFFFFFFF;

	RecordBlackUser( szID , dwBloackTime );			//등록

	for( cnt=0;cnt<srBLACK_LIST_MAX;cnt++ ) {
		if ( srBlackList[cnt].szID[0] && lstrcmpi( srBlackList[cnt].szID , szID )==0 ) {
			if ( srBlackList[cnt].dwFreeTime<dwFreeTime ) {
				srBlackList[cnt].dwFreeTime = dwFreeTime;

				//블랙 유저 파일 등록
				ResetBlackUserFiles( szID , dwBloackTime );
			}
			return dwBloackTime;
		}
	}


	for( cnt=0;cnt<srBLACK_LIST_MAX;cnt++ ) {
		if ( !srBlackList[cnt].szID[0] ) {
			lstrcpy( srBlackList[cnt].szID , szID );
			srBlackList[cnt].dwFreeTime = dwFreeTime;

			//블랙 유저 파일 등록
			ResetBlackUserFiles( szID , dwBloackTime );

			return dwBloackTime;
		}
	}


	return FALSE;
}

//나쁜자들 명단 확인
DWORD rsCheckBackListID( char *szID )
{
	int cnt;

	for( cnt=0;cnt<srBLACK_LIST_MAX;cnt++ ) {

		if ( srBlackList[cnt].szID[0] ) {
			if ( srBlackList[cnt].dwFreeTime<dwPlayServTime ) {
				//블랙 유저 파일 삭제
				ResetBlackUserFiles( srBlackList[cnt].szID , 0 );
				srBlackList[cnt].dwFreeTime = 0;
				srBlackList[cnt].szID[0] = 0;
			}
			else {
				if ( lstrcmpi( srBlackList[cnt].szID , szID )==0 ) {
					//명단에서 찾았다

					//블랙 유저 파일을 있는지 확인
					if ( FindBlackUserFile( szID )==TRUE ) {
						return srBlackList[cnt].dwFreeTime;
					}

					//블랙 유저 해제 ( 파일이 삭제 되었음 )
					srBlackList[cnt].dwFreeTime = 0;
					srBlackList[cnt].szID[0] = 0;
					break;
				}
			}
		}
	}


	return NULL;
}

//나쁜자들 명단에서 해제
int rsFreekBackListID( char *szID )
{
	int cnt;

	for( cnt=0;cnt<srBLACK_LIST_MAX;cnt++ ) {
		if ( srBlackList[cnt].szID[0] && lstrcmpi( srBlackList[cnt].szID , szID )==0 ) {
			//블랙 유저 파일 삭제
			ResetBlackUserFiles( srBlackList[cnt].szID , 0 );

			srBlackList[cnt].dwFreeTime = 0;
			srBlackList[cnt].szID[0] = 0;
			return TRUE;
		}
	}

	return FALSE;
}

//나쁜자들 명단 모두 초기화
int rsResetBackList()
{
	int cnt;

	for( cnt=0;cnt<srBLACK_LIST_MAX;cnt++ ) {
		srBlackList[cnt].dwFreeTime = 0;
		srBlackList[cnt].szID[0] = 0;
	}

	//블랙 유저 파일을 모두 초기화
	ResetBlackUserFiles();

	rsBlackListInit = TRUE;

	return TRUE;
}

//나쁜자들 명단을 보내준다
int rsShowBlackList( smWINSOCK *lpsmSock , char *szID )
{
	TRANS_CHATMESSAGE	TransChatMessage;
	int cnt;
	int dcnt;

	TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
	TransChatMessage.dwIP = 0;
	TransChatMessage.dwObjectSerial = 0;

	dcnt = 0;

	for( cnt=0;cnt<srBLACK_LIST_MAX;cnt++ ) {
		if ( srBlackList[cnt].szID[0] ) {
			if ( !szID[0] || lstrcmpi( szID , srBlackList[cnt].szID )==0 ) {
				wsprintf( TransChatMessage.szMessage , "> ID ( %s ) / ( %d )Min.", srBlackList[cnt].szID , (srBlackList[cnt].dwFreeTime-dwPlayServTime)/60000 );
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
				dcnt++;
			}
		}
	}

	wsprintf( TransChatMessage.szMessage , "> Total %d Users", dcnt);
	TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
	lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

	return TRUE;
}


//IP주소 뒤집기
DWORD SwapIPCode( DWORD dwIP )
{
	BYTE	bIP[4];

	bIP[0] = (BYTE )(dwIP&0xFF);
	bIP[1] = (BYTE )((dwIP>>8)&0xFF);
	bIP[2] = (BYTE )((dwIP>>16)&0xFF);
	bIP[3] = (BYTE )((dwIP>>24)&0xFF);

	return (bIP[0]<<24)|(bIP[1]<<16)|(bIP[2]<<8)|(bIP[3]);
}

//아이피 주소를 뒤집어서 변환
DWORD GetSwapIPCode( char *szIP )
{
	return SwapIPCode( inet_addr(szIP) );
}

//접근 금지 IP 확인
int	rsCheckDisableIP( DWORD dwUserIP )
{
	DWORD	dwIP;
	int		cnt;

	dwIP = SwapIPCode( dwUserIP );

	for( cnt=0;cnt<rsServerConfig.DisableIP_Count;cnt++) {
		if ( dwIP>=rsServerConfig.DisableIP[cnt][0] && dwIP<=rsServerConfig.DisableIP[cnt][1] ) {
			return TRUE;
		}
	}

	return FALSE;
}

//접근 허가 IP 확인
int	rsCheckEnableIP( DWORD dwUserIP )
{
	DWORD	dwIP;
	int		cnt;

	dwIP = SwapIPCode( dwUserIP );

	for( cnt=0;cnt<rsServerConfig.EnableIP_Count;cnt++) {
		if ( dwIP>=rsServerConfig.EnableIP[cnt][0] && dwIP<=rsServerConfig.EnableIP[cnt][1] ) {
			return TRUE;
		}
	}

	return FALSE;
}

//관리자 IP 확인
int	rsCheckAdminIP( DWORD dwUserIP )
{
	DWORD	dwIP;
	int		cnt;

	dwIP = SwapIPCode( dwUserIP );

	for( cnt=0;cnt<rsServerConfig.AdminIP_Count;cnt++) {
		if ( dwIP>=rsServerConfig.AdminIP[cnt][0] && dwIP<=rsServerConfig.AdminIP[cnt][1] ) {
			return TRUE;
		}
	}

	return FALSE;
}

//시스템 IP 확인
int	rsCheckSystemIP( DWORD dwUserIP )
{
	DWORD	dwIP;
	int		cnt;

	dwIP = SwapIPCode( dwUserIP );

	for( cnt=0;cnt<rsServerConfig.SystemIP_Count;cnt++) {
		if ( dwIP>=rsServerConfig.SystemIP[cnt][0] && dwIP<=rsServerConfig.SystemIP[cnt][1] ) {
			return TRUE;
		}
	}

	return FALSE;
}

//로긴서버 IP 확인
int	rsCheckLoginServerIP( DWORD dwUserIP )
{
	DWORD	dwIP;
	int		cnt;

	dwIP = SwapIPCode( dwUserIP );

	for( cnt=0;cnt<rsServerConfig.LoginServerIP_Count;cnt++) {
		if ( dwIP>=rsServerConfig.LoginServerIP[cnt][0] && dwIP<=rsServerConfig.LoginServerIP[cnt][1] ) {
			return TRUE;
		}
	}

	return FALSE;
}

//아이템 로그 일반 아이템 ( 출/입 기록 )
int	rsRecord_ItemLog( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , DWORD	dwHead , DWORD dwChkSum , int Flag )
{
	LogITEM	LogItem;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	ZeroMemory( &LogItem , sizeof(LogITEM) );

	if ( !rsServerConfig.TestSeverMode && (dwItemCode&sinITEM_MASK2)!=sinGP1 && 
		(dwItemCode&sinITEM_MASK2)!=sinQW1 && (dwItemCode&sinITEM_MASK2)!=sinOR2 && 
		(dwItemCode&sinITEM_MASK2)!=sinPZ1 && (dwItemCode&sinITEM_MASK2)!=sinPZ2 && 
		(dwItemCode&sinITEM_MASK2)!=sinSE1 && (dwItemCode&sinITEM_MASK2)!=sinBI1 &&
		(dwItemCode&sinITEM_MASK2)!=sinBI2 &&
		(dwItemCode&sinITEM_MASK2)!=sinGF1 && (dwItemCode&sinITEM_MASK2)!=sinBC1 &&
		// pluto 아이템 종류 추가 sinPR1 sinPR2 sinPR3 sinPR4 sinWR1 sinDR1
		(dwItemCode&sinITEM_MASK2)!=sinPR1 && (dwItemCode&sinITEM_MASK2)!=sinPR2 &&
		(dwItemCode&sinITEM_MASK2)!=sinPR3 && (dwItemCode&sinITEM_MASK2)!=sinPR4 &&
		(dwItemCode&sinITEM_MASK2)!=sinWR1 && (dwItemCode&sinITEM_MASK2)!=sinDR1 &&
		// pluto 선물상자 땜시
		(dwItemCode&sinITEM_MASK2)!=sinSP1 ) {

		if ( dwItemCode==(sinGG1|sin01) ) {
			//돈일 경우 10000 원 이상만 기록
			if ( dwHead<10000 ) return FALSE;
		}
		else {
			if ( dwItemCode>=sinPM1 ) return FALSE;
			if ( (dwItemCode&sinITEM_MASK2)==sinOS1 || (dwItemCode&sinITEM_MASK2)==sinFO1 ) {
				//쉘텀 ( 5번 부터 기록 )
				if ( (dwItemCode&sinITEM_MASK3)<sin05 ) return FALSE;
			}
			else {
				//그외 아이템 ( 7번 부터 기록 )
				if ( (dwItemCode&sinITEM_MASK3)<sin07 ) return FALSE;
			}
		}
	}

	LogItem.Flag = Flag;
	lstrcpy( LogItem.UserID , lpPlayInfo->szID );
	lstrcpy( LogItem.CharName , lpPlayInfo->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;
	LogItem.Item[0].dwCode	 = dwItemCode;
	LogItem.Item[0].dwINo[0] = dwHead;
	LogItem.Item[0].dwINo[1] = dwChkSum;
	LogItem.ItemCount = 1;
	LogItem.size = sizeof(LogITEM)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );	//구조체의 사용된 크기

	//아이템 로그 큐에 데이타 넣음
	return b_PushLogItemQue( 1, LogItem.size, &LogItem );
}

//아이템 로그 일반 아이템 ( 출/입 기록 )
int	rsRecord_ItemLog2( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , DWORD	dwHead , DWORD dwChkSum , int Flag )
{
	LogITEM	LogItem;

	ZeroMemory( &LogItem , sizeof(LogITEM) );

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	LogItem.Flag = Flag;
	lstrcpy( LogItem.UserID , lpPlayInfo->szID );
	lstrcpy( LogItem.CharName , lpPlayInfo->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;
	LogItem.Item[0].dwCode	 = dwItemCode;
	LogItem.Item[0].dwINo[0] = dwHead;
	LogItem.Item[0].dwINo[1] = dwChkSum;
	LogItem.ItemCount = 1;
	LogItem.size = sizeof(LogITEM)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );	//구조체의 사용된 크기

	//아이템 로그 큐에 데이타 넣음
	return b_PushLogItemQue( 1, LogItem.size, &LogItem );
}


//아이템 로그 믹스쳐 및 에이징으로 변경된 아이템 ( 출/입 기록 )
int	rsRecord_ItemLog_Change( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , DWORD	dwHead , DWORD dwChkSum , 
		DWORD dwItemCode2 , DWORD	dwHead2 , DWORD dwChkSum2 ,	int Flag )
{
	LogITEM	LogItem;

	ZeroMemory( &LogItem , sizeof(LogITEM) );

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	LogItem.Flag = Flag;
	lstrcpy( LogItem.UserID , lpPlayInfo->szID );
	lstrcpy( LogItem.CharName , lpPlayInfo->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;

	LogItem.Item[0].dwCode	 = dwItemCode;
	LogItem.Item[0].dwINo[0] = dwHead;
	LogItem.Item[0].dwINo[1] = dwChkSum;

	LogItem.Item[1].dwCode	 = dwItemCode2;
	LogItem.Item[1].dwINo[0] = dwHead2;
	LogItem.Item[1].dwINo[1] = dwChkSum2;

	LogItem.ItemCount = 2;
	LogItem.size = sizeof(LogITEM)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );	//구조체의 사용된 크기

	//아이템 로그 큐에 데이타 넣음
	return b_PushLogItemQue( 1, LogItem.size, &LogItem );
}

//아이템 로그 일반 믹스쳐,에이징에 사용된 쉘텀 
int	rsRecord_ItemLost( rsPLAYINFO *lpPlayInfo , DWORD *lpItemCode , DWORD *lpHead , DWORD *lpChkSum , int Flag )
{
	LogITEM	LogItem;
	int cnt;

	ZeroMemory( &LogItem , sizeof(LogITEM) );

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	LogItem.Flag = Flag;
	lstrcpy( LogItem.UserID , lpPlayInfo->szID );
	lstrcpy( LogItem.CharName , lpPlayInfo->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;

	LogItem.ItemCount = 0;
	for( cnt=0;cnt<12;cnt++) {
		if ( lpItemCode[cnt] ) {
			LogItem.Item[LogItem.ItemCount].dwCode	 = lpItemCode[cnt];
			LogItem.Item[LogItem.ItemCount].dwINo[0] = lpHead[cnt];
			LogItem.Item[LogItem.ItemCount].dwINo[1] = lpChkSum[cnt];
			LogItem.ItemCount++;
		}
	}

	if ( LogItem.ItemCount==0 ) return FALSE;

	LogItem.size = sizeof(LogITEM)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );	//구조체의 사용된 크기

	//아이템 로그 큐에 데이타 넣음
	return b_PushLogItemQue( 1, LogItem.size, &LogItem );
}


//아이템 로그 트레이드
int	rsRecord_ItemLog_Trade( rsPLAYINFO *lpPlayInfo , rsPLAYINFO *lpPlayInfo2, TRANS_TRADE_ITEMKEY *lpTransTradeItemKey )
{

	LogITEM_TRADE	LogItem;
	int cnt;

	ZeroMemory( &LogItem , sizeof(LogITEM_TRADE) );

	if ( !lpPlayInfo->lpsmSock ) return FALSE;
	if ( !lpPlayInfo2->lpsmSock ) return FALSE;

	LogItem.Flag = 8;
	lstrcpy( LogItem.UserID , lpPlayInfo->szID );
	lstrcpy( LogItem.CharName , lpPlayInfo->szName );
	lstrcpy( LogItem.TUserID  , lpPlayInfo2->szID );
	lstrcpy( LogItem.TCharName , lpPlayInfo2->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;
	LogItem.TIP = lpPlayInfo2->lpsmSock->acc_sin.sin_addr.S_un.S_addr;

	if ( lpTransTradeItemKey->Money>0 )
		LogItem.Money = lpTransTradeItemKey->Money-193;
	else
		LogItem.Money = 0;

	LogItem.ItemCount = 0;

	for( cnt=0;cnt<MAX_TRADE_ITEM;cnt++) {
		if ( lpTransTradeItemKey->dwItemCode[cnt] ) {
			LogItem.Item[LogItem.ItemCount].dwCode   = lpTransTradeItemKey->dwItemCode[cnt];
			LogItem.Item[LogItem.ItemCount].dwINo[0] = lpTransTradeItemKey->dwItemKey[cnt];
			LogItem.Item[LogItem.ItemCount].dwINo[1] = lpTransTradeItemKey->dwItemSum[cnt];
			LogItem.ItemCount ++;
		}
	}
	LogItem.size = sizeof(LogITEM_TRADE)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );	//구조체의 사용된 크기

	//아이템 로그 큐에 데이타 넣음
	return b_PushLogItemQue( 2, LogItem.size, &LogItem );
}

//아이템 로그 개인상점
int	rsRecord_ItemLog_MyShop( rsPLAYINFO *lpPlayInfo , rsPLAYINFO *lpPlayInfo2, DWORD dwItemCode , DWORD dwHead , DWORD dwChkSum , int Price )
{

	LogITEM_TRADE	LogItem;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;
	if ( !lpPlayInfo2->lpsmSock ) return FALSE;

	ZeroMemory( &LogItem , sizeof(LogITEM_TRADE) );
	LogItem.Flag = ITEMLOG_MYSHOP;
	lstrcpy( LogItem.UserID , lpPlayInfo->szID );
	lstrcpy( LogItem.CharName , lpPlayInfo->szName );
	lstrcpy( LogItem.TUserID  , lpPlayInfo2->szID );
	lstrcpy( LogItem.TCharName , lpPlayInfo2->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;
	LogItem.TIP = lpPlayInfo2->lpsmSock->acc_sin.sin_addr.S_un.S_addr;

	LogItem.Money = Price;

	LogItem.size = sizeof(LogITEM_TRADE)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );	//구조체의 사용된 크기

	//아이템 로그 큐에 데이타 넣음
	b_PushLogItemQue( 2, LogItem.size, &LogItem );


	ZeroMemory( &LogItem , sizeof(LogITEM_TRADE) );
	LogItem.Flag = ITEMLOG_MYSHOP;
	lstrcpy( LogItem.UserID , lpPlayInfo2->szID );
	lstrcpy( LogItem.CharName , lpPlayInfo2->szName );
	lstrcpy( LogItem.TUserID  , lpPlayInfo->szID );
	lstrcpy( LogItem.TCharName , lpPlayInfo->szName );
	LogItem.IP = lpPlayInfo2->lpsmSock->acc_sin.sin_addr.S_un.S_addr;
	LogItem.TIP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;

	LogItem.Item[0].dwCode   = dwItemCode;
	LogItem.Item[0].dwINo[0] = dwHead;
	LogItem.Item[0].dwINo[1] = dwChkSum;
	LogItem.ItemCount = 1;

	LogItem.size = sizeof(LogITEM_TRADE)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );	//구조체의 사용된 크기

	//아이템 로그 큐에 데이타 넣음
	b_PushLogItemQue( 2, LogItem.size, &LogItem );

	return TRUE;
}


//아이템 로그 증정 아이템
int	rsRecord_ItemLog_Post( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode , DWORD	dwHead , DWORD dwChkSum , DWORD dwGCode , char *szTelNum , int Flag )
{
	LogGiftITEM	LogItem;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	ZeroMemory( &LogItem , sizeof(LogGiftITEM) );

	LogItem.Flag = Flag;
	lstrcpy( LogItem.UserID , lpPlayInfo->szID );
	lstrcpy( LogItem.CharName , lpPlayInfo->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;
	LogItem.Gitem.dwCode	 = dwItemCode;
	LogItem.Gitem.dwINo[0] = dwHead;
	LogItem.Gitem.dwINo[1] = dwChkSum;
	LogItem.GNo = dwGCode;
	LogItem.size = sizeof(LogGiftITEM);	//구조체의 사용된 크기

	if ( szTelNum && szTelNum[0] ) {
		szTelNum[15]=0;
		lstrcpy( LogItem.TEL , szTelNum );
	}

	//아이템 로그 큐에 데이타 넣음
	return b_PushLogItemQue( 3, LogItem.size, &LogItem );
}

// pluto 제련 아이템 로그
int	rsRecord_SmeltingItemLog( rsPLAYINFO *lpPlayInfo, DWORD *lpItemCode, DWORD *lpHead, DWORD *lpChkSum, int Flag )
{
	LogITEM LogItem;
	int cnt;
	ZeroMemory( &LogItem, sizeof(LogITEM) );

	if( !lpPlayInfo->lpsmSock ) return FALSE;

	LogItem.Flag = Flag;
	lstrcpy( LogItem.UserID, lpPlayInfo->szID );
	lstrcpy( LogItem.CharName, lpPlayInfo->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;

	LogItem.ItemCount = 0;
	for( cnt=0;cnt<5;cnt++)
	{
		if ( lpItemCode[cnt] )
		{
			LogItem.Item[LogItem.ItemCount].dwCode	 = lpItemCode[cnt];
			LogItem.Item[LogItem.ItemCount].dwINo[0] = lpHead[cnt];
			LogItem.Item[LogItem.ItemCount].dwINo[1] = lpChkSum[cnt];
			LogItem.ItemCount++;
		}
	}

	if( LogItem.ItemCount == 0 ) return FALSE;
	LogItem.size = sizeof(LogITEM)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );

	//아이템 로그 큐에 데이타 넣음
	return b_PushLogItemQue( 1, LogItem.size, &LogItem );
}
// pluto 제작 아이템 로그
int	rsRecord_ManufactureItemLog(rsPLAYINFO *lpPlayInfo, DWORD *lpItemCode, DWORD *lpHead, DWORD *lpChkSum, int Flag )
{
	LogITEM LogItem;
	int cnt;
	ZeroMemory( &LogItem, sizeof(LogITEM) );

	if( !lpPlayInfo->lpsmSock ) return FALSE;

	LogItem.Flag = Flag;
	lstrcpy( LogItem.UserID, lpPlayInfo->szID );
	lstrcpy( LogItem.CharName, lpPlayInfo->szName );
	LogItem.IP = lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr;

	LogItem.ItemCount = 0;
	for( cnt=0;cnt<4;cnt++)
	{
		if ( lpItemCode[cnt] )
		{
			LogItem.Item[LogItem.ItemCount].dwCode	 = lpItemCode[cnt];
			LogItem.Item[LogItem.ItemCount].dwINo[0] = lpHead[cnt];
			LogItem.Item[LogItem.ItemCount].dwINo[1] = lpChkSum[cnt];
			LogItem.ItemCount++;
		}
	}

	if( LogItem.ItemCount == 0 ) return FALSE;
	LogItem.size = sizeof(LogITEM)-( sizeof(_LogITEM)*(32-LogItem.ItemCount) );

	//아이템 로그 큐에 데이타 넣음
	return b_PushLogItemQue( 1, LogItem.size, &LogItem );
}
//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
int	rsSaveAgingItemToHDD( sITEMINFO *lpItem )
{
	//DWORD	dwCode;
	char	szBuff[256];
	FILE	*fp;

/*
	dwCode = lpItem->CODE;
	if ( dwCode>=sinPM1 ) return FALSE;
	if ( (dwCode&sinITEM_MASK2)==sinOS1 ) {
		//쉘텀 ( 5번 부터 기록 )
		if ( (dwCode&sinITEM_MASK3)<sin05 ) return FALSE;
	}
	else {
		//그외 아이템 ( 8번 부터 기록 )
		if ( (dwCode&sinITEM_MASK3)<sin08 ) return FALSE;
	}
*/
	CreateDirectory( szLogItemDataDirectory , NULL );


	wsprintf( szBuff , "%s\\%d@%d.itm" , szLogItemDataDirectory , lpItem->ItemHeader.Head ,lpItem->ItemHeader.dwChkSum );
	fp = fopen( szBuff, "wb" );
	if ( fp ) {
		fwrite( lpItem , sizeof(sITEMINFO) , 1, fp );
		fclose( fp );
		return TRUE;
	}

	return FALSE;
}

//발생한 아이템 확인하여 값어치가 좀 나가면 하드에 정보를 저장
int	rsSaveCreateItemToHDD( psITEM	*lpItem )
{
	DWORD	dwCode;
	char	szBuff[256];
	FILE	*fp;


	dwCode = lpItem->ItemInfo.CODE;
	if ( dwCode>=sinPM1 ) return FALSE;
	if ( (dwCode&sinITEM_MASK2)==sinOS1 ) {
		//쉘텀 ( 5번 부터 기록 )
		if ( (dwCode&sinITEM_MASK3)<sin05 ) return FALSE;
	}
	else {
		//그외 아이템 ( 8번 부터 기록 )
		if ( (dwCode&sinITEM_MASK3)<sin08 ) return FALSE;
	}

	CreateDirectory( szLogItemDataDirectory , NULL );


	wsprintf( szBuff , "%s\\%d@%d.itm" , szLogItemDataDirectory , lpItem->ItemInfo.ItemHeader.Head ,lpItem->ItemInfo.ItemHeader.dwChkSum );
	fp = fopen( szBuff, "wb" );
	if ( fp ) {
		fwrite( &lpItem->ItemInfo , sizeof(sITEMINFO) , 1, fp );
		fclose( fp );
		return TRUE;
	}

	return FALSE;
}

//발생한 아이템 기록정보를 찾아서 설정
int	rsLoadCreateItemToHDD( psITEM	*lpItem , char *szFileCode )
{
	FILE *fp;
	HANDLE hFindHandle;
	WIN32_FIND_DATA	fd;
	char	szBuff[256];

	wsprintf( szBuff , "%s\\%s.itm" , szLogItemDataDirectory , szFileCode );

	hFindHandle = FindFirstFile( szBuff , &fd );
	if ( hFindHandle!=INVALID_HANDLE_VALUE ) {
		FindClose( hFindHandle );

		fp = fopen( szBuff , "rb" );
		if ( fp ) {
			fread( &lpItem->ItemInfo , sizeof( sITEMINFO ) , 1, fp );
			fclose(fp);
		}
		return TRUE;
	}

	return FALSE;
}



struct	sRECORD_COPIED_ITEM_HEAD {
	char	szHeader[16];
	int		TotalCount;
	int		A_ItemCount;
	int		D_ItemCount;
	int		S_ItemCount;
	int		E_ItemCount;

	int		Temp[7];
};

struct	sRECORD_COPIED_ITEM {
	DWORD	dwItemCode;
	DWORD	dwHead;
	DWORD	dwChkSum;
	DWORD	dwTemp;
};

struct sRECORD_COPIED_ITEM_FILE {
	sRECORD_COPIED_ITEM_HEAD	sHeader;
	sRECORD_COPIED_ITEM			sCopiedItem[4096];
};


sRECORD_COPIED_ITEM	*lpCopiedItem_List =0;
sRECORD_COPIED_ITEM	*lpCopiedItem_Sheltom_List =0;

int rsCopiedItem_Count =0;
int rsCopiedItem_Sheltom_Count =0;


//복사 아이템 목록 불러 오기
int rsLoadCopiedItemList()
{
	sRECORD_COPIED_ITEM_FILE	sCopiedItems;
	FILE *fp;
	int cnt;

	rsRemoveCopiedItemList();

	fp = fopen( "cpItem.dat" , "rb" );
	if ( !fp ) return FALSE;

	fread( &sCopiedItems , sizeof(sRECORD_COPIED_ITEM_FILE) , 1, fp );
	fclose(fp);

	if ( sCopiedItems.sHeader.TotalCount>=4096 || sCopiedItems.sHeader.TotalCount<0 ) return FALSE;

	rsCopiedItem_Sheltom_Count = 0;
	rsCopiedItem_Count = 0;

	for( cnt=0;cnt<sCopiedItems.sHeader.TotalCount;cnt++ ) {
		if ( (sCopiedItems.sCopiedItem[cnt].dwItemCode&sinITEM_MASK2)==sinOS1 ) {
			//쉘텀
			rsCopiedItem_Sheltom_Count++;
		}
		else {
			//일반 아이템
			rsCopiedItem_Count++;
		}
	}

	if ( rsCopiedItem_Count ) lpCopiedItem_List = new sRECORD_COPIED_ITEM[rsCopiedItem_Count];
	if ( rsCopiedItem_Sheltom_Count ) lpCopiedItem_Sheltom_List = new sRECORD_COPIED_ITEM[rsCopiedItem_Sheltom_Count];


	rsCopiedItem_Sheltom_Count = 0;
	rsCopiedItem_Count = 0;

	for( cnt=0;cnt<sCopiedItems.sHeader.TotalCount;cnt++ ) {
		if ( (sCopiedItems.sCopiedItem[cnt].dwItemCode&sinITEM_MASK2)==sinOS1 ) {
			//쉘텀
			lpCopiedItem_Sheltom_List[rsCopiedItem_Sheltom_Count].dwItemCode = sCopiedItems.sCopiedItem[cnt].dwItemCode;
			lpCopiedItem_Sheltom_List[rsCopiedItem_Sheltom_Count].dwHead = sCopiedItems.sCopiedItem[cnt].dwHead;
			lpCopiedItem_Sheltom_List[rsCopiedItem_Sheltom_Count].dwChkSum = sCopiedItems.sCopiedItem[cnt].dwChkSum;
			rsCopiedItem_Sheltom_Count++;
		}
		else {
			//일반 아이템
			lpCopiedItem_List[rsCopiedItem_Count].dwItemCode = sCopiedItems.sCopiedItem[cnt].dwItemCode;
			lpCopiedItem_List[rsCopiedItem_Count].dwHead = sCopiedItems.sCopiedItem[cnt].dwHead;
			lpCopiedItem_List[rsCopiedItem_Count].dwChkSum = sCopiedItems.sCopiedItem[cnt].dwChkSum;
			rsCopiedItem_Count++;
		}
	}

	return TRUE;
}

//복사 아이템 목록 제거
int rsRemoveCopiedItemList()
{
	if ( lpCopiedItem_List ) { delete lpCopiedItem_List; lpCopiedItem_List=0; }
	if ( lpCopiedItem_Sheltom_List ) { delete lpCopiedItem_Sheltom_List; lpCopiedItem_Sheltom_List=0; }

	rsCopiedItem_Sheltom_Count = 0;
	rsCopiedItem_Count = 0;

	return TRUE;
}



//아이템이 복사 아이템인지 확인
int rsCheckCopiedItem( DWORD dwCode , DWORD dwHead , DWORD dwChkSum )
{
	int cnt;

	if ( (dwCode&sinITEM_MASK2)==sinOS1 ) {
		//쉘텀
		if ( !lpCopiedItem_Sheltom_List || rsCopiedItem_Sheltom_Count<=0 ) return FALSE;

		for( cnt=0;cnt<rsCopiedItem_Sheltom_Count;cnt++ ) {
			if ( dwCode==lpCopiedItem_Sheltom_List[cnt].dwItemCode &&
				dwHead==lpCopiedItem_Sheltom_List[cnt].dwHead &&
				dwChkSum==lpCopiedItem_Sheltom_List[cnt].dwChkSum ) {

					return TRUE;
				}
		}
	}
	else {
		//일반
		if ( !lpCopiedItem_List || rsCopiedItem_Count<=0 ) return FALSE;

		for( cnt=0;cnt<rsCopiedItem_Count;cnt++ ) {
			if ( dwCode==lpCopiedItem_List[cnt].dwItemCode &&
				dwHead==lpCopiedItem_List[cnt].dwHead &&
				dwChkSum==lpCopiedItem_List[cnt].dwChkSum ) {

					return TRUE;
				}
		}
	}


	return FALSE;
}

//아이템이 복사 아이템인지 확인
int rsCheckCopiedItem( sITEMINFO *lpItem )
{
	DWORD dwHead , dwChkSum;

	if ( lpItem->BackUpKey && lpItem->BackUpChkSum ) {
		dwHead = lpItem->BackUpKey;
		dwChkSum = lpItem->BackUpChkSum;
	}
	else {
		dwHead = lpItem->ItemHeader.Head;
		dwChkSum = lpItem->ItemHeader.dwChkSum;
	}

	return rsCheckCopiedItem( lpItem->CODE , dwHead , dwChkSum );
}

/*
///////////////////////////////////////////////////////////
struct	sRECORD_COPIED_ITEM_HEAD {
	char	szHeader[16];
	int		TotalCount;
	int		A_ItemCount;
	int		D_ItemCount;
	int		S_ItemCount;
	int		E_ItemCount;

	int		Temp[7];
};

struct	sRECORD_COPIED_ITEM {
	DWORD	dwItemCode;
	DWORD	dwHead;
	DWORD	dwChkSum;
	DWORD	dwTemp;
};
///////////////////////////////////////////////////////////

int SaveRecordCopiedItem()
{
	sRECORD_COPIED_ITEM_HEAD	sRecord_Item_Head;
	sRECORD_COPIED_ITEM			sRecord_Copied_Item[4096];
	int	cnt;
	int ItemCount;


	if ( sRecordItemBuff && RecordItemCount>0 ) {
		FILE *fp;

		ZeroMemory( &sRecord_Item_Head , sizeof(sRECORD_ITEM_HEAD) );
		lstrcpy( sRecord_Item_Head.szHeader , "Pt_CpItem(1.0)" );

		ItemCount = 0;
		for( cnt=0;cnt<RecordItemCount;cnt++ ) {
			if ( sRecordItemBuff[cnt].CopyCount>0 && ItemCount<4096 ) {
	
				sRecord_Copied_Item[ItemCount].dwItemCode = sRecordItemBuff[cnt].dwItemCode;

				if ( sRecordItemBuff[cnt].dwBackup_Key ) {
					sRecord_Copied_Item[ItemCount].dwHead    = sRecordItemBuff[cnt].dwBackup_Key;
					sRecord_Copied_Item[ItemCount].dwChkSum  = sRecordItemBuff[cnt].dwBackup_ChkSum;
				}
				else {
					sRecord_Copied_Item[ItemCount].dwHead    = sRecordItemBuff[cnt].dwHead;
					sRecord_Copied_Item[ItemCount].dwChkSum  = sRecordItemBuff[cnt].dwChkSum;
				}

				ItemCount++;
			}
		}

		if ( ItemCount==0 ) return FALSE;

		sRecord_Item_Head.TotalCount = ItemCount;

		fp = fopen( "cpItem.dat" , "wb" );
		if ( fp ) {
			fwrite( &sRecord_Item_Head , sizeof(sRECORD_COPIED_ITEM_HEAD),1, fp );
			fwrite( sRecord_Copied_Item , sizeof( sRECORD_COPIED_ITEM ) * ItemCount , 1, fp );
			fclose(fp);
			return TRUE;
		}
	}

	return TRUE;
}
*/






/////////////////////////////////////////////////////////////////////////////////////////

//스킬 업데이트
int rsUpdateSkill( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	switch( lpTransCommand->WParam ) {

		case SKILL_PLAY_METAL_GOLEM:
		case SKILL_PLAY_RECALL_WOLVERIN:
		case SKILL_PLAY_FIRE_ELEMENTAL:

		case SKILL_METAL_GOLEM:
		case SKILL_RECALL_WOLVERIN:
		case SKILL_FIRE_ELEMENTAL:

			if ( lpPlayInfo->lpLinkChar && lpPlayInfo->lpLinkChar->dwObjectSerial==lpPlayInfo->dwLinkCharCode && lpPlayInfo->lpLinkChar->HoSkillCode ) {
				//소환몹 모드 변경
				lpPlayInfo->lpLinkChar->HoSkillMode = lpTransCommand->LParam;
				lpPlayInfo->lpLinkChar->lpTargetPlayInfo = 0;
				lpPlayInfo->lpLinkChar->lpTargetChar = 0;
			}
			break;
	}

	return TRUE;
}


//스킬취소
int rsCancelSkill( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	switch( lpTransCommand->WParam ) {
		case 0:	//모든 스킬 취소
			lpPlayInfo->dwSkill_PhysicalAbsorb_Time = 0;
			lpPlayInfo->dwSkill_PhysicalAbsorb_Param = 0;

			lpPlayInfo->dwSkill_ExtreamShield_Time = 0;
			lpPlayInfo->dwSkill_ExtreamShield_Param = 0;

			lpPlayInfo->dwSkill_AutoMation_Time = 0;
			lpPlayInfo->dwSkill_AutoMation_Param = 0;

			lpPlayInfo->dwSkill_Maximize_Time = 0;
			lpPlayInfo->dwSkill_Maximize_Param = 0;

			lpPlayInfo->dwSkill_HolyBody_Time = 0;
			lpPlayInfo->dwSkill_HolyBody_Param = 0;

			lpPlayInfo->dwSkill_HolyValor_Time = 0;
			lpPlayInfo->dwSkill_HolyValor_Param = 0;

			lpPlayInfo->dwSkill_HolyReflection_Time = 0;
			lpPlayInfo->dwSkill_HolyReflection_Param = 0;

			lpPlayInfo->dwSkill_EnchantWeapon_Time = 0;
			lpPlayInfo->dwSkill_EnchantWeapon_Param = 0;


			lpPlayInfo->dwSkill_MetalArmor_Time = 0;
			lpPlayInfo->dwSkill_MetalArmor_Param = 0;
			lpPlayInfo->dwSkill_SparkShield_Time = 0;
			lpPlayInfo->dwSkill_SparkShield_Param = 0;

			lpPlayInfo->dwSKill_Falcon_Time = 0;
			lpPlayInfo->dwSKill_Falcon_Damage[0] = 0;
			lpPlayInfo->dwSKill_Falcon_Damage[1] = 0;

			lpPlayInfo->dwSkill_DivineInhalation_Time = 0;
			lpPlayInfo->dwSkill_DivineInhalation_Param = 0;

			lpPlayInfo->dwSkill_TriumphOfValhalla_Time = 0;
			lpPlayInfo->dwSkill_TriumphOfValhalla_Param = 0;

			lpPlayInfo->dwSkill_VirtualLife_Time = 0;
			lpPlayInfo->dwSkill_VirtualLife_Param = 0;


			lpPlayInfo->dwSkill_EnergyShield_Time = 0;
			lpPlayInfo->dwSkill_EnergyShield_Param = 0;

			lpPlayInfo->dwSkill_SpiritElemental_Time = 0;
			lpPlayInfo->dwSkill_SpiritElemental_Param = 0;

			lpPlayInfo->dwSkill_DancingSword_Time = 0;
			lpPlayInfo->dwSkill_DancingSword_Param = 0;
			lpPlayInfo->dwSkill_DancingSword_DelayTime = 0;

			lpPlayInfo->dwSkill_Vanish_Time = 0;
			lpPlayInfo->dwSkill_Vanish_Param = 0;

			lpPlayInfo->dwSkill_MagneticSphere_Time = 0;
			lpPlayInfo->dwSkill_MagneticSphere_Param = 0;

			lpPlayInfo->dwSkill_Berserker_Time = 0;
			lpPlayInfo->dwSkill_Berserker_Param = 0;

			lpPlayInfo->dwSkill_AssassinEye_Time = 0;
			lpPlayInfo->dwSkill_AssassinEye_Param = 0;
			
			lpPlayInfo->dwSkill_Vague_Time = 0;
			lpPlayInfo->dwSkill_Vague_Param = 0;
			
			lpPlayInfo->dwSkill_ForceOfNature_Time = 0;
			lpPlayInfo->wSkill_ForceOfNature_Param[0] = 0;
			lpPlayInfo->wSkill_ForceOfNature_Param[1] = 0;

			lpPlayInfo->dwSkill_GodlyShied_Time = 0;
			lpPlayInfo->dwSkill_GodlyShied_Param = 0;
			
			lpPlayInfo->dwSkill_GodsBless_Time = 0;
			lpPlayInfo->dwSkill_GodsBless_Param = 0;
			
			lpPlayInfo->dwSkill_HallOfValhalla_Time = 0;
			
			lpPlayInfo->dwSkill_FrostJavelin_Time = 0;
			lpPlayInfo->dwSkill_FrostJavelin_Param = 0;
	
			lpPlayInfo->dwSkill_RegenerationField_Time = 0;

			lpPlayInfo->dwSkill_SummonMuspell_Time = 0;
			lpPlayInfo->dwSkill_SummonMuspell_Param = 0;

			//저주 취소
			lpPlayInfo->dwCurse_Attack_Time = 0;		//공격 저주
			lpPlayInfo->dwCurse_Defence_Time = 0;		//방어 저주
			break;

		case SKILL_PLAY_HOLY_VALOR:
			lpPlayInfo->dwSkill_HolyValor_Time = 0;
			lpPlayInfo->dwSkill_HolyValor_Param = 0;
			break;

		case SKILL_PLAY_AUTOMATION:
			lpPlayInfo->dwSkill_AutoMation_Time = 0;
			lpPlayInfo->dwSkill_AutoMation_Param = 0;
			break;

		case SKILL_PLAY_MAXIMIZE:
			lpPlayInfo->dwSkill_Maximize_Time = 0;
			lpPlayInfo->dwSkill_Maximize_Param = 0;
			break;

		case SKILL_PLAY_PHYSICAL_ABSORB:
			lpPlayInfo->dwSkill_PhysicalAbsorb_Time = 0;
			lpPlayInfo->dwSkill_PhysicalAbsorb_Param = 0;
			break;

		case SKILL_PLAY_EXTREME_SHIELD:
			lpPlayInfo->dwSkill_ExtreamShield_Time = 0;
			lpPlayInfo->dwSkill_ExtreamShield_Param = 0;
			break;

		case SKILL_PLAY_FROST_JAVELIN:
			lpPlayInfo->dwSkill_FrostJavelin_Time = 0;
			lpPlayInfo->dwSkill_FrostJavelin_Param = 0;
			break;


	}

	return TRUE;
}

int rsProcessSkillPartyUser( rsPLAYINFO *lpPlayInfo , TRANS_PARTY_SKILL *lpTransPartySkill )
{
	int point;

	point = lpTransPartySkill->Point-1;
	if ( point<0 || point>=10 ) return FALSE;

	switch( lpTransPartySkill->dwSkillCode ) {
		case SKILL_PLAY_HOLY_VALOR:
			//홀리 밸러
			lpPlayInfo->dwSkill_HolyValor_Time = dwPlayServTime + (Holy_Valor_Time[point]*1000);
			lpPlayInfo->dwSkill_HolyValor_Param = Holy_Valor_Damage[point];
			return TRUE;
/*
		case SKILL_PLAY_TRIUMPH_OF_VALHALLA:
			//트라이엄프 발할라
			lpPlayInfo->dwSkill_TriumphOfValhalla_Time = dwPlayServTime + (T_Of_Valhalla_Time[point]*1000);
			lpPlayInfo->dwSkill_TriumphOfValhalla_Param = T_Of_Valhalla_Damage[point];
			return TRUE;
*/
	}


	return FALSE;
}

//스킬 사용 정보를 파티원에게 보내기
int	rsRecvSkillPartyUser( TRANS_PARTY_SKILL *lpTransPartySkill )
{
	int cnt;
	rsPLAYINFO *lpPlayInfo;

	for( cnt=0;cnt<lpTransPartySkill->PartyCount;cnt++ ) {
		lpPlayInfo = srFindUserFromSerial(lpTransPartySkill->dwPartyUser[cnt]);
		if ( lpPlayInfo && lpPlayInfo->lpsmSock ) {
			if ( rsProcessSkillPartyUser( lpPlayInfo , lpTransPartySkill )==TRUE ) {
				lpPlayInfo->lpsmSock->Send2( (char *)lpTransPartySkill , lpTransPartySkill->size , TRUE );
			}
		}
	}

	return TRUE;
}

//스킬 실행
int rsRecvProcessSkill( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	DWORD dwSkillCode;
	int point;
	rsPLAYINFO *lpPlayInfo2;
	smTRANS_COMMAND_EX	TransCommandEx;
	int	lv;
	smCHAR	*lpChar;
	int cnt,x,y,z,dist,size;

	dwSkillCode = lpTransCommand->WParam&0xFF;
	point = (lpTransCommand->WParam>>8)&0xF;
	point -= 1;

	if ( point<0 ) point = lpTransCommand->LParam-1;

	if ( point<0 || point>=10 ) return FALSE;

	//레벨로 정상적인 스킬 코드인지 검사
	if ( rsCheckSkillLevel( lpPlayInfo , dwSkillCode )==FALSE ) {
		if ( lpPlayInfo->WarningCount<5 && dwSkillCode!=SKILL_PLAY_RESURRECTION ) {

				//오류 로그 남기기
				TransCommandEx.size = sizeof(smTRANS_COMMAND);
				TransCommandEx.code = smTRANSCODE_SET_BLACKLIST;
				TransCommandEx.WParam = 8850;
				TransCommandEx.LParam = lpPlayInfo->smCharInfo.Level;
				TransCommandEx.SParam = dwSkillCode;
				TransCommandEx.EParam = point;
				rsSendDataServer( lpPlayInfo->lpsmSock , &TransCommandEx );
				lpPlayInfo->WarningCount++;
			}
	}


	switch( dwSkillCode ) {
		case SKILL_PLAY_HOLY_REFLECTION:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==8 ) {
				//프리스티스 - 홀리 리플렉스
				lpPlayInfo->dwSkill_HolyReflection_Time = dwPlayServTime+Holy_Reflection_Time[point]*1000;
				lpPlayInfo->dwSkill_HolyReflection_Param = Holy_Reflection_Return_Damage[point]; 
			}
			break;

		case SKILL_PLAY_ENCHANT_WEAPON:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==7 ) {
				//메지션 - 인챈트 워폰
				lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->SParam );		//상대방 찾기
				if ( lpPlayInfo2 && lpPlayInfo2->lpsmSock ) {
					lpPlayInfo2->dwSkill_EnchantWeapon_Time = dwPlayServTime+Enchant_Weapon_Time[point]*1000;
					lpPlayInfo2->dwSkill_EnchantWeapon_Param = (point+1)|(lpTransCommand->EParam<<8);
					if ( lpPlayInfo2!=lpPlayInfo )
						lpPlayInfo2->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
				}
			}
			break;

		case SKILL_PLAY_AUTOMATION:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MECHANICIAN ) {
				//메카니션 - 오토매이션
				lpPlayInfo->dwSkill_AutoMation_Time = dwPlayServTime+Automation_Time[point]*1000;
				lpPlayInfo->dwSkill_AutoMation_Param = Automation_Damage[point];
			}
			break;

		case SKILL_PLAY_MAXIMIZE:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MECHANICIAN ) {
				//메카니션 - 맥시마이즈
				lpPlayInfo->dwSkill_Maximize_Time = dwPlayServTime+Maximize_Time[point]*1000;
				lpPlayInfo->dwSkill_Maximize_Param = Maximize_Damage[point];
			}
			break;

		case SKILL_PLAY_PHYSICAL_ABSORB:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MECHANICIAN ) {
				//메카니션 - 피지컬
				lpPlayInfo->dwSkill_PhysicalAbsorb_Time = dwPlayServTime+P_Absorb_UseTime[point]*1000;
				lpPlayInfo->dwSkill_PhysicalAbsorb_Param = GetRandomPos( P_Absorb[point][0] , P_Absorb[point][1] );
			}
			break;

		case SKILL_PLAY_EXTREME_SHIELD:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MECHANICIAN ) {
				//메카니션 - 피지컬
				lpPlayInfo->dwSkill_ExtreamShield_Time = dwPlayServTime+E_Shield_UseTime[point]*1000;
				lpPlayInfo->dwSkill_ExtreamShield_Param = E_Shield_BlockRate[point];
			}
			break;

		case SKILL_PLAY_HOLY_BODY:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_KNIGHT ) {
				//홀리 바디 - 나이트
				lpPlayInfo->dwSkill_HolyBody_Time = dwPlayServTime+HolyBody_Time[point]*1000;
				lpPlayInfo->dwSkill_HolyBody_Param = HolyBody_Absorb[point];
			}
			break;

		case SKILL_PLAY_METAL_ARMOR:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MECHANICIAN ) {
				//메탈 아머
				lpPlayInfo->dwSkill_MetalArmor_Time = dwPlayServTime+Metal_Armor_Time[point]*1000;
				if ( lpTransCommand->SParam>0 && lpTransCommand->SParam<=10 ) {
					lpPlayInfo->dwSkill_MetalArmor_Param = (P_Absorb[lpTransCommand->SParam-1][0]+P_Absorb[lpTransCommand->SParam-1][1])/2;
				}
				else
					lpPlayInfo->dwSkill_MetalArmor_Param = 0;
			}
			break;

		case SKILL_PLAY_SPARK_SHIELD:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MECHANICIAN ) {
				//스파크쉴드
				lpPlayInfo->dwSkill_SparkShield_Time = dwPlayServTime+Spark_Shield_Time[point]*1000;
				if ( lpTransCommand->SParam>0 && lpTransCommand->SParam<=10 ) {
					lpPlayInfo->dwSkill_SparkShield_Param = (Spark_Shield_Damage[point]*Spark_Damage[lpTransCommand->SParam-1][0])/100;
					lpPlayInfo->dwSkill_SparkShield_Param <<=16;
					lpPlayInfo->dwSkill_SparkShield_Param |= (Spark_Shield_Damage[point]*Spark_Damage[lpTransCommand->SParam-1][1])/100;
										}
				else
					lpPlayInfo->dwSkill_SparkShield_Param = 0;
			}
			break;


		case SKILL_PLAY_FALCON:		//팔콘
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ARCHER ) {
				lpPlayInfo->dwSKill_Falcon_Time = dwPlayServTime+Falcon_Time[point]*1000;
				lpPlayInfo->dwSKill_Falcon_Damage[0] = Falcon_Damage[point][0];
				lpPlayInfo->dwSKill_Falcon_Damage[1] = Falcon_Damage[point][1];
			}
			break;

		case SKILL_PLAY_GOLDEN_FALCON:		//골든팔콘
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ARCHER ) {
				if ( lpTransCommand->SParam>0 && lpTransCommand->SParam<=10 ) {
					lpPlayInfo->dwSKill_Falcon_Time = dwPlayServTime+Golden_Falcon_Time[point]*1000;
					lpPlayInfo->dwSKill_Falcon_Damage[0] = Falcon_Damage[lpTransCommand->SParam-1][0];
					lpPlayInfo->dwSKill_Falcon_Damage[1] = Falcon_Damage[lpTransCommand->SParam-1][1];
					lpPlayInfo->dwSKill_Falcon_Damage[0] = (lpPlayInfo->dwSKill_Falcon_Damage[0]*Golden_Falcon_Damage[point])/100;
					lpPlayInfo->dwSKill_Falcon_Damage[1] = (lpPlayInfo->dwSKill_Falcon_Damage[1]*Golden_Falcon_Damage[point])/100;
				}
			}
			break;


		case SKILL_PLAY_DIVINE_INHALATION:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_KNIGHT ) {
				lpPlayInfo->dwSkill_DivineInhalation_Time = dwPlayServTime+D_Inhalation_Time[point]*1000;
				lpPlayInfo->dwSkill_DivineInhalation_Param = point;//D_Inhalation_Life[point];
			}
			break;


		case SKILL_PLAY_RESURRECTION:			//죽은자 살리기
			if ( lpTransCommand->SParam ) {
				if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PRIESTESS ) {
					lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->SParam );
					if ( lpPlayInfo2 ) {
						if ( (rand()%100)<Resurrection_Percent[point] ) {
							if ( lpPlayInfo2!=lpPlayInfo )
								lpPlayInfo2->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
						}
					}
				}
			}
			else {
				//살아 났음
				ZeroMemory( &TransCommandEx , sizeof(smTRANS_COMMAND_EX) );
				TransCommandEx.WParam = smCOMMNAD_USER_RESURRECTION;
				TransCommandEx.LParam = lpPlayInfo->dwObjectSerial;
				TransCommandEx.SParam = 0;
				TransCommandEx.EParam = 0;
				rsSendCommandUser( lpPlayInfo , &TransCommandEx );			//이펙트 호출
			}
			break;

		case SKILL_PLAY_VIRTUAL_LIFE:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PRIESTESS ) {
				//버츄얼라이프
				if ( !lpTransCommand->SParam ) {
					lpPlayInfo->dwSkill_VirtualLife_Time = dwPlayServTime+Virtual_Life_Time[point]*1000;
					lpPlayInfo->dwSkill_VirtualLife_Param = Virtual_Life_Percent[point];
				}
				else {
					lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->SParam );
					if ( lpPlayInfo2 && lpPlayInfo2->dwSkill_VirtualLife_Time<dwPlayServTime ) {
						lpPlayInfo2->dwSkill_VirtualLife_Time = dwPlayServTime+Virtual_Life_Time[point]*1000;
						lpPlayInfo2->dwSkill_VirtualLife_Param = Virtual_Life_Percent[point];
						lpPlayInfo2->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
					}
				}
			}
			break;

		case SKILL_PLAY_ZENITH:
			//제니쓰
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MAGICIAN ) {

			}
			break;

		case SKILL_PLAY_ENERGY_SHIELD:
			//에너지쉴드
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MAGICIAN ) {
				lpPlayInfo->dwSkill_EnergyShield_Time = dwPlayServTime+Energy_Shield_Time[point]*1000;
				lpPlayInfo->dwSkill_EnergyShield_Param = Energy_Shield_DecDamage[point];
			}
			break;

		case SKILL_PLAY_SPIRIT_ELEMENTAL:
			//스피릿 엘리멘탈
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MAGICIAN ) {
				lpPlayInfo->dwSkill_SpiritElemental_Time = dwPlayServTime+Spirit_Elemental_Time[point]*1000;
				lpPlayInfo->dwSkill_SpiritElemental_Param = Spirit_Elemental_Damage[point];
			}
			break;

		case SKILL_PLAY_DANCING_SWORD:
			//댄싱소드
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MAGICIAN ) {
				lpPlayInfo->dwSkill_DancingSword_Time = dwPlayServTime+Dancing_Sword_Time[point]*1000;
				lpPlayInfo->dwSkill_DancingSword_Param = (lpTransCommand->SParam)|(point<<16);
				lpPlayInfo->dwSkill_DancingSword_DelayTime = 0;
			}
			break;

		case SKILL_PLAY_TRIUMPH_OF_VALHALLA:
			//트라이엄프 발할라
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ATALANTA ) {
				if ( lpPlayInfo->smCharInfo.Level>0 && lpPlayInfo->smCharInfo.Level<CHAR_LEVEL_MAX )
					lv = lpPlayInfo->smCharInfo.Level/9;
				else
					lv = 0;

				if ( !lpTransCommand->SParam ) {
					lpPlayInfo->dwSkill_TriumphOfValhalla_Time = dwPlayServTime + (T_Of_Valhalla_Time[point]*1000);
					lpPlayInfo->dwSkill_TriumphOfValhalla_Param = T_Of_Valhalla_Damage[point]+lv;

					lpPlayInfo->dwSkill_HallOfValhalla_Time = 0;		//홀오브 발할라 취소
				}
				else {
					lpPlayInfo2 = srFindUserFromSerial( lpTransCommand->SParam );
					if ( lpPlayInfo2 ) {
						if ( lpPlayInfo2->dwSkill_HallOfValhalla_Time<dwPlayServTime ) {		//홀오브 발할라 시전시 불가
							lpPlayInfo2->dwSkill_TriumphOfValhalla_Time = dwPlayServTime + (T_Of_Valhalla_Time[point]*1000);
							lpPlayInfo2->dwSkill_TriumphOfValhalla_Param = (T_Of_Valhalla_Damage[point]+lv)/2;		//타인시전시 절반만 적용
							lpTransCommand->EParam = lpPlayInfo->smCharInfo.Level;
							lpPlayInfo2->lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
						}
					}
				}
			}
			return TRUE;

		case SKILL_PLAY_VANISH:
			//배니쉬
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PIKEMAN ) {
				lpPlayInfo->dwSkill_Vanish_Time = dwPlayServTime+Vanish_Time[point]*1000;
				lpPlayInfo->dwSkill_Vanish_Param = point;
			}
			break;

		case SKILL_PLAY_MAGNETIC_SPHERE:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MECHANICIAN ) {
				lpPlayInfo->dwSkill_MagneticSphere_Time = dwPlayServTime+Magnetic_Sphere_Time[point]*1000;
				lpPlayInfo->dwSkill_MagneticSphere_Param = point;
			}
			break;

		case SKILL_PLAY_METAL_GOLEM:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MECHANICIAN ) {
				lpChar = OpenMonsterFromSkill( dwSkillCode , lpPlayInfo->Position.x,lpPlayInfo->Position.y,lpPlayInfo->Position.z, lpPlayInfo ,0 );
				if ( lpChar ) {
					lpChar->dwUpdateCharInfoTime = dwPlayServTime+355*1000;		//360초 유지
					lpChar->smCharInfo.Attack_Damage[0] = Metal_Golem_Damage[point][0];
					lpChar->smCharInfo.Attack_Damage[1] = Metal_Golem_Damage[point][1];
					lpChar->smCharInfo.Attack_Rating = Metal_Golem_Hit[point];
					lpChar->smCharInfo.Defence = Metal_Golem_Defense[point];

					//힘*2 추가
					lpChar->smCharInfo.Life[0] = Metal_Golem_Life[point]+lpPlayInfo->smCharInfo.Strength*2;
					lpChar->smCharInfo.Life[1] = lpChar->smCharInfo.Life[0];

					lpChar->sMoveStepCount[0] = 1;		//이동 속도 2x2
					lpChar->sMoveStepCount[1] = 2;

					lpChar->smCharInfo.wPlayClass[1] = fONE+point*15;		//크기 확대
				}
			}
			break;


		case SKILL_PLAY_BERSERKER:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_FIGHTER ) {
				lpPlayInfo->dwSkill_Berserker_Time = dwPlayServTime+Berserker_Time[point]*1000;
				lpPlayInfo->dwSkill_Berserker_Param = point;//Berserker_AddAttack[point];
			}
			break;

		case SKILL_PLAY_ASSASSIN_EYE:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PIKEMAN ) {
				lpPlayInfo->dwSkill_AssassinEye_Time = dwPlayServTime+Assassin_Eye_Time[point]*1000;
				lpPlayInfo->dwSkill_AssassinEye_Param = point;
			}
			break;

		case SKILL_PLAY_VAGUE:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PIKEMAN ) {
				lpPlayInfo->dwSkill_Vague_Time = dwPlayServTime+Vague_Time[point]*1000;
				lpPlayInfo->dwSkill_Vague_Param = point;
			}
			break;

		case SKILL_PLAY_RECALL_WOLVERIN:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ARCHER ) {
				lpChar = OpenMonsterFromSkill( dwSkillCode , lpPlayInfo->Position.x,lpPlayInfo->Position.y,lpPlayInfo->Position.z, lpPlayInfo ,0);
				if ( lpChar ) {
					lpChar->dwUpdateCharInfoTime = dwPlayServTime+355*1000;		//360초 유지
					lpChar->smCharInfo.Attack_Damage[0] = Recall_Wolverin_Damage[point][0];
					lpChar->smCharInfo.Attack_Damage[1] = Recall_Wolverin_Damage[point][1];
					lpChar->smCharInfo.Attack_Rating = Recall_Wolverin_Hit[point];
					lpChar->smCharInfo.Defence = Recall_Wolverin_Defense[point]+lpPlayInfo->smCharInfo.Dexterity*2;
					lpChar->smCharInfo.Life[0] = Recall_Wolverin_Life[point];
					lpChar->smCharInfo.Life[1] = Recall_Wolverin_Life[point];

					lpChar->sMoveStepCount[0] = 1;		//이동 속도 2x2
					lpChar->sMoveStepCount[1] = 2;

					lpChar->smCharInfo.wPlayClass[1] = (fONE/2)+point*12;		//크기 확대
				}
			}
			break;

		case SKILL_PLAY_FORCE_OF_NATURE:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ARCHER ) {
				lpPlayInfo->dwSkill_ForceOfNature_Time = dwPlayServTime+Force_Of_Nature_Time[point]*1000;
				lpPlayInfo->wSkill_ForceOfNature_Param[0] = Force_Of_Nature_AddDamage[point];
				lpPlayInfo->wSkill_ForceOfNature_Param[1] = Force_Of_Nature_FalconAddDamage[point];

				size = 300*300;
				for(cnt=0;cnt<CONNECTMAX;cnt++) {
					if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial && 
						lpPlayInfo!=&rsPlayInfo[cnt] &&
						rsPlayInfo[cnt].Position.Area==lpPlayInfo->Position.Area &&
						( rsPlayInfo[cnt].Position.Area!=rsCASTLE_FIELD || ( rsPlayInfo[cnt].dwClanCode && rsPlayInfo[cnt].dwClanCode==lpPlayInfo->dwClanCode ) ) )
					{
							x = (lpPlayInfo->Position.x-rsPlayInfo[cnt].Position.x)>>FLOATNS;
							y = (lpPlayInfo->Position.y-rsPlayInfo[cnt].Position.y)>>FLOATNS;
							z = (lpPlayInfo->Position.z-rsPlayInfo[cnt].Position.z)>>FLOATNS;

							dist = x*x+z*z;
							if ( dist<size && abs(y)<80 ) {
								rsPlayInfo[cnt].dwSkill_ForceOfNature_Time = dwPlayServTime+Force_Of_Nature_Time[point]*1000;
								rsPlayInfo[cnt].wSkill_ForceOfNature_Param[0] = Force_Of_Nature_AddDamage[point]/2;
								rsPlayInfo[cnt].wSkill_ForceOfNature_Param[1] = Force_Of_Nature_FalconAddDamage[point];
								rsPlayInfo[cnt].lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );

							}
					}
				}
			}
			break;

		case SKILL_PLAY_GODLY_SHIELD:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_KNIGHT) {
				lpPlayInfo->dwSkill_GodlyShied_Time = dwPlayServTime+Godly_Shield_Time[point]*1000;
				lpPlayInfo->dwSkill_GodlyShied_Param = point;
			}
			break;

		case SKILL_PLAY_GODS_BLESS:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_KNIGHT) {
				lpPlayInfo->dwSkill_GodsBless_Time = dwPlayServTime+God_Bless_Time[point]*1000;
				lpPlayInfo->dwSkill_GodsBless_Param = God_Bless_AddDamage[point];
			}
			break;

		case SKILL_PLAY_HALL_OF_VALHALLA:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ATALANTA) {

				if ( lpPlayInfo->smCharInfo.Level>0 && lpPlayInfo->smCharInfo.Level<CHAR_LEVEL_MAX ) {
					lv = lpPlayInfo->smCharInfo.Level/9;
					lpTransCommand->EParam = lpPlayInfo->smCharInfo.Level;
				}
				else {
					lv = 0;
					lpTransCommand->EParam = 1;
				}

				lpPlayInfo->dwSkill_HallOfValhalla_Time = dwPlayServTime+Hall_Of_Valhalla_Time[point]*1000;
				lpPlayInfo->wSkill_HallOfValhalla_Param[0] = Hall_Of_Valhalla_AddEvation[point];
				lpPlayInfo->wSkill_HallOfValhalla_Param[1] = T_Of_Valhalla_Damage[lpTransCommand->SParam-1]+lv;

				lpPlayInfo->dwSkill_TriumphOfValhalla_Time = 0;		//트라이엄프 초기화

				//int cnt,x,z,dist;


				size = 350*350;
				for(cnt=0;cnt<CONNECTMAX;cnt++) {
					if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial && 
						lpPlayInfo!=&rsPlayInfo[cnt] &&
						rsPlayInfo[cnt].Position.Area==lpPlayInfo->Position.Area &&
						( rsPlayInfo[cnt].Position.Area!=rsCASTLE_FIELD || ( rsPlayInfo[cnt].dwClanCode && rsPlayInfo[cnt].dwClanCode==lpPlayInfo->dwClanCode ) ) )
					{
						x = (lpPlayInfo->Position.x-rsPlayInfo[cnt].Position.x)>>FLOATNS;
						y = (lpPlayInfo->Position.y-rsPlayInfo[cnt].Position.y)>>FLOATNS;
						z = (lpPlayInfo->Position.z-rsPlayInfo[cnt].Position.z)>>FLOATNS;

						dist = x*x+z*z;
						if ( dist<size && abs(y)<80 ) {
							if ( rsPlayInfo[cnt].dwSkill_TriumphOfValhalla_Time<dwPlayServTime ) {		//트라이엄프 발할라 시전시 불가
								rsPlayInfo[cnt].dwSkill_HallOfValhalla_Time = dwPlayServTime+Hall_Of_Valhalla_Time[point]*1000;
								rsPlayInfo[cnt].wSkill_HallOfValhalla_Param[0] = Hall_Of_Valhalla_AddEvation[point]/2;
								rsPlayInfo[cnt].wSkill_HallOfValhalla_Param[1] = (T_Of_Valhalla_Damage[lpTransCommand->SParam-1]+lv)/2;
								rsPlayInfo[cnt].lpsmSock->Send2( (char *)lpTransCommand , lpTransCommand->size , TRUE );
							}
						}
					}
				}
			}
			break;

		case SKILL_PLAY_FROST_JAVELIN:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ATALANTA) {
				lpPlayInfo->dwSkill_FrostJavelin_Time = dwPlayServTime+Frost_Javelin_Time[point]*1000;
				lpPlayInfo->dwSkill_FrostJavelin_Param = point;
			}
			break;

		case SKILL_PLAY_REGENERATION_FIELD:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PRIESTESS) {
				lpPlayInfo->dwSkill_RegenerationField_Time = dwPlayServTime+Regeneration_Field_Time[point]*1000;
			}
			break;

		case SKILL_PLAY_SUMMON_MUSPELL:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PRIESTESS ) {
				lpPlayInfo->dwSkill_SummonMuspell_Time = dwPlayServTime+Summon_Muspell_Time[point]*1000;
				lpPlayInfo->dwSkill_SummonMuspell_Param = point;
			}
			break;

		case SKILL_PLAY_FIRE_ELEMENTAL:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MAGICIAN ) {
				lpChar = OpenMonsterFromSkill( dwSkillCode , lpPlayInfo->Position.x,lpPlayInfo->Position.y,lpPlayInfo->Position.z, lpPlayInfo ,0);
				if ( lpChar ) {
					lpChar->dwUpdateCharInfoTime = dwPlayServTime+355*1000;
					lpChar->smCharInfo.Attack_Damage[0] = Fire_Elemental_Damage[point][0];
					lpChar->smCharInfo.Attack_Damage[1] = Fire_Elemental_Damage[point][1];
					lpChar->smCharInfo.Attack_Rating = Fire_Elemental_Hit[point];
					lpChar->smCharInfo.Life[0] = Fire_Elemental_Life[point];
					lpChar->smCharInfo.Life[1] = Fire_Elemental_Life[point];

					lpChar->sMoveStepCount[0] = 1;		//이동 속도 2x2
					lpChar->sMoveStepCount[1] = 2;

				}
			}
			break;

	}

	return TRUE;
}


//서버 - 홀리 리플렉션 공격 처리
int rsProcessAttack_SkillHolyReflection( rsPLAYINFO *lpPlayInfo , smCHAR *lpChar )
{
	int pow;
	smTRANS_COMMAND	smTransCommand;
	int rs;

	if ( !lpPlayInfo->dwSkill_HolyReflection_Time ) return TRUE;

	if ( lpPlayInfo->dwSkill_HolyReflection_Time<dwPlayServTime ) {
		lpPlayInfo->dwSkill_HolyReflection_Time = 0;
		return TRUE;
	}

	if ( lpChar->smCharInfo.Brood!=smCHAR_MONSTER_UNDEAD ) return TRUE;


	pow = GetRandomPos( lpChar->smCharInfo.Attack_Damage[0] , lpChar->smCharInfo.Attack_Damage[1] );
	pow = (pow*lpPlayInfo->dwSkill_HolyReflection_Param) / 100;
	rs = lpChar->smCharInfo.Resistance[sITEMINFO_BIONIC];			//생속성 감쇄
	if ( rs ) {
		if ( rs>=100 ) rs=100;
		if ( rs<=-100 ) rs=-100;
		pow -= ((pow*rs)/100);
	}
	pow -= ( pow * lpChar->smCharInfo.Absorption )/100;

	if ( pow>0 ) {
		//명중 ( 공격 성공 )
		lpChar->smCharInfo.Life[0] -= pow;

		if ( lpChar->smCharInfo.Life[0]>0 ) {

			/*
			int ang,ang2;

			if ( lpChar->MotionInfo->State != CHRMOTION_STATE_DAMAGE && lpChar->MotionInfo->State!=CHRMOTION_STATE_EAT ) {
				ang2 = GetRadian2D( lpChar->pX , lpChar->pZ ,lpPlayInfo->Position.x, lpPlayInfo->Position.z );
				ang = (ang2+ANGLE_180) & ANGCLIP;
				lpChar->Angle.y = ang;
				lpChar->MoveAngle( 10 );
				lpChar->Angle.y = ang2;

				lpChar->SetMotionFromCode( CHRMOTION_STATE_DAMAGE );
			}
			*/
		}
		else {
			lpChar->SetMotionFromCode( CHRMOTION_STATE_DEAD );
			lpChar->lpExt2 = (void *)lpPlayInfo;
		}
	}

	if ( lpPlayInfo->lpsmSock ) {
		smTransCommand.code = smTRANSCODE_PROCESS_SKILL;
		smTransCommand.size = sizeof( smTRANS_COMMAND );
		smTransCommand.WParam  = SKILL_PLAY_HOLY_REFLECTION;
		smTransCommand.LParam  = pow;
		smTransCommand.SParam  = 0;
		smTransCommand.EParam  = 0;
		lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
	}

	//return FALSE;
	return TRUE;
}

/*
			//클랜 업데이트 하기
			rsClanUpdate( (TRANS_CLAN_COMMAND_USER *)SockInfo->Buff );
			break;
*/

//클랜 업데이트 하기
int rsClanUpdate( rsPLAYINFO *lpPlayInfo , TRANS_CLAN_COMMAND_USER *lpTransClanUser )
{
	rsCLAN_INFOMATION	ClanInfomation;
	smTRANS_COMMAND		smTransCommand;
	int	cnt;
	rsPLAYINFO	*lpPlayInfo2;

	//클랜원 정보 해독
	if ( RecvClanCommand( lpTransClanUser , ClanInfomation.ClanUserInfo )==TRUE ) {
		ZeroMemory( &smTransCommand , sizeof(smTRANS_COMMAND) );
		smTransCommand.code = smTRANSCODE_CLAN_UPDATE;
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.WParam = lpPlayInfo->dwObjectSerial;

		for( cnt=0;cnt<lpTransClanUser->UserCount;cnt++ ) {
			lpPlayInfo2 = FindUserFromCodeName( ClanInfomation.ClanUserInfo[cnt].szName  , ClanInfomation.ClanUserInfo[cnt].dwSpeedSum );
			if ( lpPlayInfo2 ) {
				//찾았다 .. 접속중
				lpPlayInfo2->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
			}
		}
	}

	return TRUE;
}

//야호 동작 실행
int rsRecvYahooMotion( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	int cnt;
	STG_AREA	*lpStgArea;
	smCHAR		*lpCharList[srCLAN_MONSTER_MAX];
	int			ClanMonCount = 0;
	int			ClanPoint;
	int			x,y,z,dist;


	if ( lpPlayInfo->dwClanCode && lpPlayInfo->Position.Area>=0 && lpPlayInfo->Position.Area<STAGE_AREA_MAX ) {

		lpStgArea = &StageArea[ lpPlayInfo->Position.Area ];

		for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]->smCharInfo.ClassClan==lpPlayInfo->smCharInfo.ClassClan ) {
				if ( ClanMonCount>=srCLAN_MONSTER_MAX ) break;

				x = ( lpPlayInfo->Position.x - lpStgArea->lpCharMonster[cnt]->pX )>>FLOATNS;
				y = ( lpPlayInfo->Position.y - lpStgArea->lpCharMonster[cnt]->pY )>>FLOATNS;
				z = ( lpPlayInfo->Position.z - lpStgArea->lpCharMonster[cnt]->pZ )>>FLOATNS;
				dist = x*x+y*y+z*z;

				if ( dist<DIST_TRANSLEVEL_LOW )	
					lpCharList[ClanMonCount++] = lpStgArea->lpCharMonster[cnt];
			}
		}

		if ( ClanMonCount ) {
			//클랜 몹 힐링
			ClanPoint = (lpPlayInfo->smCharInfo.Level>>2)/ClanMonCount;
			if ( ClanPoint==0 ) ClanPoint = 1;

			for(cnt=0;cnt<ClanMonCount;cnt++) {
				if ( lpCharList[cnt]->smCharInfo.Life[0]>0 ) {
					lpCharList[cnt]->smCharInfo.Life[0]+=ClanPoint;
					if ( lpCharList[cnt]->smCharInfo.Life[0]>lpCharList[cnt]->smCharInfo.Life[1] )
						lpCharList[cnt]->smCharInfo.Life[0] = lpCharList[cnt]->smCharInfo.Life[1];
				}
			}
		}
	}

	return TRUE;
}

//주변 몬스터를 찾는다
smCHAR *rsFindAroundMonster( smCHAR *lpChar , int RoundDist)
{
	STG_AREA	*lpStgArea;
	int cnt;
	int x,y,z,dist;
	int ddist2;

	ddist2 = RoundDist*RoundDist;

	lpStgArea = (STG_AREA *)lpChar->lpExt4;
	if ( lpStgArea ) {
		for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]!=lpChar && 
				!lpStgArea->lpCharMonster[cnt]->PlayHolyPower[1] && 
				lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0]>0 ) {

				x = (lpStgArea->lpCharMonster[cnt]->pX-lpChar->pX)>>FLOATNS;
				y = (lpStgArea->lpCharMonster[cnt]->pY-lpChar->pY)>>FLOATNS;
				z = (lpStgArea->lpCharMonster[cnt]->pZ-lpChar->pZ)>>FLOATNS;
				dist = x*x+z*z;

				if ( abs(y)<80 && dist<ddist2 ) {
					return lpStgArea->lpCharMonster[cnt];
				}
			}
		}
	}

	return NULL;
}



//주변 몬스터를 찾아 데미지 공격
smCHAR *rsSkillDamage_AroundMonster( smCHAR *lpChar )
{
	STG_AREA	*lpStgArea;
	int cnt;
	int x,y,z,dist;
	int ddist2;
	smCHAR *lpTargetChar;

	int RoundDist = lpChar->smMonsterInfo.SkillRange;
	int	pw,pow;

	ddist2 = RoundDist*RoundDist;
	pow = GetRandomPos( lpChar->smMonsterInfo.SkillDamage[0] , lpChar->smMonsterInfo.SkillDamage[1] );

	lpStgArea = (STG_AREA *)lpChar->lpExt4;
	if ( lpStgArea ) {
		for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]!=lpChar && lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0]>0 ) {

				x = (lpStgArea->lpCharMonster[cnt]->pX-lpChar->pX)>>FLOATNS;
				y = (lpStgArea->lpCharMonster[cnt]->pY-lpChar->pY)>>FLOATNS;
				z = (lpStgArea->lpCharMonster[cnt]->pZ-lpChar->pZ)>>FLOATNS;
				dist = x*x+z*z;

				if ( abs(y)<80 && dist<ddist2 ) {

					lpTargetChar = lpStgArea->lpCharMonster[cnt];

					if ( lpChar->smCharInfo.ClassClan!=0 && lpChar->smCharInfo.ClassClan==lpTargetChar->smCharInfo.ClassClan ) {
						pw = 0;
					}
					else {
						pw = pow;
						pw -= (pow*lpTargetChar->smCharInfo.Absorption)/100;
					}

					if ( pw>0 ) {
						lpTargetChar->smCharInfo.Life[0] -= pw;
						if ( lpTargetChar->smCharInfo.Life[0]<=0 ) {
							lpTargetChar->smCharInfo.Life[0]=0;
							lpTargetChar->SetMotionFromCode(CHRMOTION_STATE_DEAD);
							if ( lpChar->lpMasterPlayInfo && lpChar->lpMasterPlayInfo->lpsmSock && lpChar->lpMasterPlayInfo->dwObjectSerial && lpChar->lpMasterPlayInfo->dwObjectSerial==lpChar->smCharInfo.Next_Exp ) {
								lpTargetChar->lpExt2 = lpChar->lpMasterPlayInfo;
								lpTargetChar->smMonsterInfo.GetExp >>=1;				//경험치 절반
								lpTargetChar->lpExt3 = lpChar;
							}
							else {
								if ( lpChar->lpMasterPlayInfo ) {
									//플레이어 연결 종료 또는 위치가 바뀜
									lpChar->smCharInfo.Life[0] = 0;
									lpChar->SetMotionFromCode(CHRMOTION_STATE_DEAD);
								}
								else {
									lpChar->lpTargetChar = 0;
								}
							}
						}
						else {
							if ( lpTargetChar->MotionInfo->State!=CHRMOTION_STATE_DEAD ) {//<0x100 ) {
								lpTargetChar->SetMotionFromCode(CHRMOTION_STATE_DAMAGE);
							}
						}
					}
					//return lpStgArea->lpCharMonster[cnt];
				}
			}
		}
	}

	return NULL;
}

//주변 몬스터를 찾아 스킬 ( 라투 주변 몬스터 스턴제거 )
smCHAR *rsSkillMonster_AroundMonster( smCHAR *lpChar , int RoundDist )
{
	STG_AREA	*lpStgArea;
	int cnt;
	int x,y,z,dist;
	int ddist2;
	smCHAR *lpTargetChar;

	ddist2 = RoundDist*RoundDist;

	lpStgArea = (STG_AREA *)lpChar->lpExt4;
	if ( lpStgArea ) {
		for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]!=lpChar && lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0]>0 ) {

				x = (lpStgArea->lpCharMonster[cnt]->pX-lpChar->pX)>>FLOATNS;
				y = (lpStgArea->lpCharMonster[cnt]->pY-lpChar->pY)>>FLOATNS;
				z = (lpStgArea->lpCharMonster[cnt]->pZ-lpChar->pZ)>>FLOATNS;
				dist = x*x+z*z;

				if ( abs(y)<80 && dist<ddist2 ) {
					if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_RATOO ) {		//라투 주변 몬스터 스턴 제거
						lpTargetChar = lpStgArea->lpCharMonster[cnt];
						lpTargetChar->PlayStunCount = 0;
					}
				}
			}
		}
	}

	return NULL;
}



//돈을 유저에게 보낸다
int	rsSendMoneyToUser( rsPLAYINFO *lpPlayInfo , int Money )
{
	TRANS_ITEMINFO	TransItemInfo;

	//성공 점수를 돈으로 환산하여 준다
	ZeroMemory( &TransItemInfo , sizeof( TRANS_ITEMINFO ) );

	TransItemInfo.code = smTRANSCODE_PUTITEM;
	TransItemInfo.size = sizeof(TRANS_ITEMINFO);
	TransItemInfo.Item.CODE = ( sinGG1|sin01 );
	TransItemInfo.Item.Money = Money;
	wsprintf( TransItemInfo.Item.ItemName , sinGold , Money );
	ReformItem( &TransItemInfo.Item );

	lpPlayInfo->spMoney_Out += TransItemInfo.Item.Money;							//출금 기록
	TransItemInfo.x = dwPlayServTime;													//해독 키
	TransItemInfo.y = TransItemInfo.Item.ItemHeader.dwChkSum;							//해독 키2
	TransItemInfo.z = lpPlayInfo->spMoney_Out^(TransItemInfo.x+TransItemInfo.y);	//토탈 기록 전송

	rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )

	lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );

	return TRUE;
}




//메인서버로 돈을 보낸다
int	rsPutItemToSystemLine( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode )
{
	smTRANS_SYSTEM_COMMAND	TransSystemCommand;
	smWINSOCK	*lpsmSock;

	ZeroMemory( &TransSystemCommand , sizeof(smTRANS_SYSTEM_COMMAND) );
	TransSystemCommand.code = smTRANSCODE_SYSTEM;
	TransSystemCommand.size = sizeof(smTRANS_SYSTEM_COMMAND);
	TransSystemCommand.tCode = smTRANS_SYSCODE_GET_ITEM;
	TransSystemCommand.dwObjectSerial = rsServerConfig.ServerCode;
	TransSystemCommand.Param[0] = lpPlayInfo->dwObjectSerial;
	TransSystemCommand.Param[1] = dwItemCode;

	lpsmSock = rsFindNextSertoServerSock();

	if ( lpsmSock ) 
		return lpsmSock->Send( (char *)&TransSystemCommand , TransSystemCommand.size , TRUE );

	return FALSE;
}

//메인서버로 돈을 보낸다
int	rsSendMoneyToSystemLine( rsPLAYINFO *lpPlayInfo , int Money )
{
	smTRANS_SYSTEM_COMMAND	TransSystemCommand;
	smWINSOCK	*lpsmSock;

	ZeroMemory( &TransSystemCommand , sizeof(smTRANS_SYSTEM_COMMAND) );
	TransSystemCommand.code = smTRANSCODE_SYSTEM;
	TransSystemCommand.size = sizeof(smTRANS_SYSTEM_COMMAND);
	TransSystemCommand.tCode = smTRANS_SYSCODE_GET_MONEY;
	TransSystemCommand.dwObjectSerial = rsServerConfig.ServerCode;
	TransSystemCommand.Param[0] = lpPlayInfo->dwObjectSerial;
	TransSystemCommand.Param[1] = Money;

	lpsmSock = rsFindNextSertoServerSock();

	if ( lpsmSock ) 
		return lpsmSock->Send( (char *)&TransSystemCommand , TransSystemCommand.size , TRUE );

	return FALSE;
}


//군서버로 연결한 캐릭터 정보를 보낸다
int rsSendCharInfoToLoginServer( rsPLAYINFO *lpPlayInfo )
{

	smTRANS_CHAR_COMMAND	smTransCharCommand;

	if ( !dwSerToLogin_Count ) return FALSE;

	smTransCharCommand.code = smTRANSCODE_SYSTEM;
	smTransCharCommand.size = sizeof(smTRANS_CHAR_COMMAND);
	smTransCharCommand.LParam = smTRANS_SYSCODE_CONNECT_USER;
	smTransCharCommand.WParam = lpPlayInfo->dwObjectSerial;
	smTransCharCommand.SParam = lpPlayInfo->dwCode_Name;
	lstrcpy( smTransCharCommand.szName , lpPlayInfo->smCharInfo.szName );

	//로긴 서버로 데이타 보내기
	return rsSendPacketToLoginLine( (char *)&smTransCharCommand , smTransCharCommand.size );
}


//시스템 라인 연결 갯수 구하기
int	rsGetSystemLineCount()
{
	int cnt;
	int	LineCount = 0;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].SystemLine )
			LineCount++;
	}

	return LineCount;
}



//로긴서버 라인 구하여 설정
int	rsSetSerToLoginLine()
{
	int	cnt;

	dwSerToLogin_Count = 0;
	dwSerToLogin_Num = 0;

	for(cnt=0;cnt<CONNECTMAX;cnt++) {
		if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].SystemLine==2 ) {
			if ( dwSerToLogin_Count>=SER_TO_LOGIN_SOCKET_MAX ) break;
			lpPlayInfo_LoginServer[dwSerToLogin_Count++] = &rsPlayInfo[cnt];
		}
	}

	return dwSerToLogin_Count;
}

//로긴 서버로 데이타 보내기
int rsSendPacketToLoginLine( char *szBuff , int size )
{
	if ( dwSerToLogin_Count==0 ) return NULL;
	if ( dwSerToLogin_Num>=dwSerToLogin_Count ) dwSerToLogin_Num = 0;

	if ( lpPlayInfo_LoginServer[dwSerToLogin_Num]->lpsmSock && lpPlayInfo_LoginServer[dwSerToLogin_Num]->SystemLine==2 ) {
		return lpPlayInfo_LoginServer[dwSerToLogin_Num++]->lpsmSock->Send( szBuff , size , TRUE );
	}

	return FALSE;
}


//시스템 패킷 ( 다른 서버에서 들어옴 )
int rsRecvSystemInfo( rsPLAYINFO *lpPlayInfo , void *Buff )
{
	smTRANS_SYSTEM_COMMAND	*lpTransSystemCommand = (smTRANS_SYSTEM_COMMAND *)Buff;
	TRANS_KILL_MONSTER_INFO	*lpTransKillMonInfo = (TRANS_KILL_MONSTER_INFO *)Buff;
	rsKILL_MONSTER_INFO	*lpKillMonInfo = (rsKILL_MONSTER_INFO *)((char *)Buff+sizeof(TRANS_KILL_MONSTER_INFO));
	smTRANS_CHAR_COMMAND	*lpCharCommand;
	smTRANS_COMMAND			smTransCommand;


	int cnt;
	DWORD	dwTime;
	rsPLAYINFO	*lprsPlayInfo;


	if ( !lpPlayInfo->SystemLine ) {
		//시스템 모드 설정
		if ( lpTransSystemCommand->tCode==smTRANS_SYSCODE_CONNECT ) {

			//로긴서버 IP 확인
			if ( rsCheckLoginServerIP( lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr )==TRUE ) {
				lpPlayInfo->SystemLine = 2;			//로그인(군) 서버 연결
				rsSetSerToLoginLine();				//로긴 라인 버퍼에 설정
			}
			else {
				if ( !rsServerConfig.SystemIP_Count || rsCheckSystemIP( lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr )==TRUE ) {
					lpPlayInfo->SystemLine = 1;		//지역서버 연결
				}

				if ( rsCheckSystemIP( lpPlayInfo->lpsmSock->acc_sin.sin_addr.S_un.S_addr )==TRUE ) {
					lpPlayInfo->SystemLine = 1;		//지역서버 연결
					rsSystemLineConnCount++;
				}
				else
				{
					if(lpPlayInfo->WarningCount < 10 )
					{	//kyle
						smTransCommand.WParam = 8920;
						smTransCommand.LParam = (DWORD)lpPlayInfo->lpsmSock->szIPAddr;
//						smTransCommand.SParam = lpTransCommand->WParam;
						RecordHackLogFile( lpPlayInfo , &smTransCommand );

						lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+60*1000*5;	//5분
					}
				}
			}

			
		}
		else {
			DisconnectUser( lpPlayInfo->lpsmSock );
		}
		return TRUE;
	}

	switch( lpTransSystemCommand->tCode ) {

		case smTRANS_SYSCODE_KILL_MONSTER:
			//몬스터 사냥
			for(cnt=0;cnt<lpTransKillMonInfo->KillInfo_Count;cnt++) {
				rsOpen_MonsterItemExp( lpKillMonInfo );			//몬스터로부터 아이템 경험치 생성
				lpKillMonInfo++;
			}
			rsSystemLinePlayCount += lpTransKillMonInfo->KillInfo_Count;	//처리 횟수 기록
			break;

		case smTRANS_SYSCODE_GET_MONEY:
			//돈 획득
			//돈을 유저에게 보낸다
			lprsPlayInfo = srFindUserFromSerial( lpTransSystemCommand->Param[0] );
			if ( lprsPlayInfo )
				rsSendMoneyToUser( lprsPlayInfo , lpTransSystemCommand->Param[1] );
			break;

		case smTRANS_SYSCODE_GET_ITEM:
			//아이템을 유저에게 보낸다
			lprsPlayInfo = srFindUserFromSerial( lpTransSystemCommand->Param[0] );
			if ( lprsPlayInfo )
				rsPutItem( lprsPlayInfo , lpTransSystemCommand->Param[1] );
			break;

		case smTRANS_SYSCODE_DMG_USER_LIST:
			//데미지 유저리스트 받음
			memcpy( &rsUserListDamageTop10 , Buff , sizeof(rsUSER_LIST_TOP10) );
			rsUserListDamageTop10.dwUpdateTime = dwPlayServTime;
			break;

		case smTRANS_SYSCODE_CONNECT_USER:
			//메인서버에서 군서버로 정보 보냄
			lpCharCommand = (smTRANS_CHAR_COMMAND *)Buff;
			lprsPlayInfo = srFindUserFromSerial( lpCharCommand->WParam );
			if ( lprsPlayInfo ) {
				if ( lprsPlayInfo->dwCode_Name==lpCharCommand->SParam &&
					lstrcmpi( lprsPlayInfo->szName , lpCharCommand->szName )==0 ) {
						return TRUE;		//확인 성공 (해당 캐릭 존재)
					}
			}

			lpCharCommand->LParam = smTRANS_SYSCODE_USER_FAILED;
			lpPlayInfo->lpsmSock->Send( (char *)Buff , lpCharCommand->size , TRUE ); 
			break;

		case smTRANS_SYSCODE_USER_FAILED:
			//군서버에서 정보 오류로 연결 해제 선언
			lpCharCommand = (smTRANS_CHAR_COMMAND *)Buff;
			lprsPlayInfo = srFindUserFromSerial( lpCharCommand->WParam );
			if ( lprsPlayInfo ) {
				if ( lprsPlayInfo->dwCode_Name==lpCharCommand->SParam ) {
					//이곳에다 오류 코드 설정
					smTransCommand.WParam = 0;

					DisconnectUser( lprsPlayInfo->lpsmSock );
				}
			}
			break;


		case smTRANS_SYSCODE_NETSTATE:
			//데드락 첵크 ( 바로 재전송 )
			lpTransSystemCommand->tCode = smTRANS_SYSCODE_NETSUCCESS;
			lpTransSystemCommand->Param[0] = dwPlayServTime;
			lpPlayInfo->lpsmSock->Send( (char *)lpTransSystemCommand , lpTransSystemCommand->size , TRUE );

			rsSystemNetCount++;
			break;

		case smTRANS_SYSCODE_NETSUCCESS:
			//네트웤 성공
			lpPlayInfo->lpsmSock->dwDeadLockTime = GetCurrentTime();

			if ( !dwOffsetTime ) 
				dwOffsetTime = dwPlayServTime - lpTransSystemCommand->Param[0];		//시계 조정
			else {
				dwTime = dwPlayServTime - lpTransSystemCommand->Param[0];
				if ( abs( dwTime-dwOffsetTime )>1000*30 ) {							//시간 오차 30초 이상 생기면 보정
					dwOffsetTime = dwTime;
				}
			}
			rsSystemNetCount++;

			break;

	}


	return TRUE;
}


//몬스터 사냥정보 보관
int	rsPushKillMonster( smCHAR *lpChar , rsPLAYINFO *lpPlayInfo , STG_AREA *lpStgArea )
{
	int cnt;

	if ( !dwSerToSerIP ) return FALSE;

	if ( (rsKillMonster_Push-rsKillMonster_Pop)>=srMONSTER_KILL_QUE_MASK ) {


		return TRUE;
	}

	cnt = rsKillMonster_Push&srMONSTER_KILL_QUE_MASK;

	rsKillMonster_Que[cnt].dwAutoCharCode = lpChar->smMonsterInfo.dwAutoCharCode;
	rsKillMonster_Que[cnt].dwCharSoundCode = lpChar->smCharInfo.dwCharSoundCode;
	rsKillMonster_Que[cnt].dwMonObjectSerial = lpChar->dwObjectSerial;

	rsKillMonster_Que[cnt].x = lpChar->pX;
	rsKillMonster_Que[cnt].y = lpChar->pY;
	rsKillMonster_Que[cnt].z = lpChar->pZ;

	rsKillMonster_Que[cnt].PartyFlag = lpChar->PartyFlag;

	if ( lpPlayInfo )
		rsKillMonster_Que[cnt].dwUserObjectSerial = lpPlayInfo->dwObjectSerial;
	else
		rsKillMonster_Que[cnt].dwUserObjectSerial = 0;

	if ( lpStgArea && lpStgArea->lpField )
		rsKillMonster_Que[cnt].Area = lpStgArea->lpField->FieldCode;
	else 
		rsKillMonster_Que[cnt].Area = -1;


	rsKillMonster_Que[cnt].dwParam[0] = 0;
	rsKillMonster_Que[cnt].dwParam[1] = 0;
	rsKillMonster_Que[cnt].dwParam[2] = 0;
	rsKillMonster_Que[cnt].dwParam[3] = 0;

	if ( rsKillMonster_Que[cnt].PartyFlag==rsHARDCORE_EVENT_FLAG ) {
		rsKillMonster_Que[cnt].dwParam[0] = lpChar->PartyParam;
	}

	rsKillMonster_Push++;

	return TRUE;
}

int	rsSendKillMonsterInfo( smWINSOCK *lpsmSock )
{
	char	szBuff[4096];
	TRANS_KILL_MONSTER_INFO	*lpTransKillMonInfo = (TRANS_KILL_MONSTER_INFO *)szBuff;
	rsKILL_MONSTER_INFO	*lpKillMonInfo = (rsKILL_MONSTER_INFO *)(szBuff+sizeof(TRANS_KILL_MONSTER_INFO));

	int	cnt,mCnt;


	mCnt = 0;

	while(1) {
		if ( rsKillMonster_Pop==rsKillMonster_Push ) break;
		if ( mCnt>48 ) break;

		cnt = rsKillMonster_Pop&srMONSTER_KILL_QUE_MASK;

		memcpy( lpKillMonInfo , &rsKillMonster_Que[cnt] , sizeof(rsKILL_MONSTER_INFO) );

		lpKillMonInfo++;
		rsKillMonster_Pop++;
		mCnt++;
	}

	if ( !mCnt ) return FALSE;

	lpTransKillMonInfo->size = sizeof(TRANS_KILL_MONSTER_INFO)+sizeof(rsKILL_MONSTER_INFO)*mCnt;
	lpTransKillMonInfo->code = smTRANSCODE_SYSTEM;
	lpTransKillMonInfo->tCode = smTRANS_SYSCODE_KILL_MONSTER;
	lpTransKillMonInfo->KillInfo_Count = mCnt;
	lpTransKillMonInfo->Temp[0] = 0;
	lpTransKillMonInfo->Temp[1] = 0;
	lpTransKillMonInfo->Temp[2] = 0;
	lpTransKillMonInfo->Temp[3] = 0;

	if ( lpsmSock ) lpsmSock->Send( (char *)lpTransKillMonInfo , lpTransKillMonInfo->size , TRUE );

	return mCnt;
}


smWINSOCK	*rsFindNextSertoServerSock()
{
	int cnt;
	smWINSOCK	*lpsmSock;

	for(cnt=0;cnt<SER_TO_SERVER_SOCKET_MAX;cnt++) {
		lpsmSock = lpsmSock_SerToServer[(cnt+dwSerToSer_Count)&SER_TO_SERVER_SOCKET_MASK];
		if ( lpsmSock ) return lpsmSock;
	}

	return NULL;
}



DWORD WINAPI rsTransServerMain_Thread( void *pInfo )
{
	HANDLE	hThread;
	DWORD	dwTime;
	int		cnt;
	int		Count;
	smWINSOCK	*lpsmSock;
	smTRANS_SYSTEM_COMMAND	TransSystemCommand;
	rsPLAYINFO	*lpPlayInfo;

	hThread = GetCurrentThread();
	dwTime = GetCurrentTime();
	Count = 0;

	while(1) {
		Sleep(200);
		if ( quit ) break;
		if ( !dwSerToSerIP ) continue;

		EnterCriticalSection( &cSerSection );	//크리티칼 섹션 선언

		////////////////// 서버 연결 ///////////////////////////////////////
		for(cnt=0;cnt<SER_TO_SERVER_SOCKET_MAX;cnt++) {
			if ( !lpsmSock_SerToServer[cnt] || lpsmSock_SerToServer[cnt]->acc_sin.sin_addr.S_un.S_addr!=dwSerToSerIP ) {

				LeaveCriticalSection( &cSerSection );	//크리티칼 섹션 해제
				lpsmSock = smConnectSock3( szSerToSerIP , TCP_SERVPORT );
				if ( quit ) goto quit_thread;

				if ( lpsmSock ) Serv_ConnectPlayer( lpsmSock );

				EnterCriticalSection( &cSerSection );	//크리티칼 섹션 선언

				if ( lpsmSock ) {

					rsSystemLineConnCount++;				//연결 성공

					if ( lpsmSock_SerToServer[cnt] ) {
						DisconnectUser( lpsmSock_SerToServer[cnt] );
					}
					lpsmSock_SerToServer[cnt] = lpsmSock;

					lpPlayInfo = (rsPLAYINFO *)lpsmSock->ExtData1;
					if ( lpPlayInfo ) lpPlayInfo->SystemLine = TRUE;

					ZeroMemory( &TransSystemCommand , sizeof(smTRANS_SYSTEM_COMMAND) );
					TransSystemCommand.code = smTRANSCODE_SYSTEM;
					TransSystemCommand.size = sizeof(smTRANS_SYSTEM_COMMAND);
					TransSystemCommand.tCode = smTRANS_SYSCODE_CONNECT;
					TransSystemCommand.dwObjectSerial = rsServerConfig.ServerCode;
					lpsmSock->Send( (char *)&TransSystemCommand , TransSystemCommand.size , TRUE );
				}
			}
		}

		////////////////// 데드락 패킷 송신 //////////////////////////////////
		dwTime = GetCurrentTime();

		if ( (Count&0x1F)==0 ) {
			ZeroMemory( &TransSystemCommand , sizeof(smTRANS_SYSTEM_COMMAND) );
			TransSystemCommand.code = smTRANSCODE_SYSTEM;
			TransSystemCommand.size = sizeof(smTRANS_SYSTEM_COMMAND);
			TransSystemCommand.tCode = smTRANS_SYSCODE_NETSTATE;

			for(cnt=0;cnt<SER_TO_SERVER_SOCKET_MAX;cnt++) {
				if ( lpsmSock_SerToServer[cnt] ) {
					if ( (lpsmSock_SerToServer[cnt]->dwDeadLockTime+(1000*45))<dwTime ) {
						//시간 초과 연결 종료
						DisconnectUser( lpsmSock_SerToServer[cnt] );
						lpsmSock_SerToServer[cnt] = 0;
						rsSystemLineFailedCount ++;
					}
					else {
						lpsmSock_SerToServer[cnt]->Send( (char *)&TransSystemCommand , TransSystemCommand.size , TRUE );
					}
				}
			}
		}


		//////////////// 몬스터 죽인 정보 메인서버로 보냄 //////////////////////
		for(cnt=0;cnt<32;cnt++) {
			lpsmSock = rsFindNextSertoServerSock();								//다음 속켓 찾기
			if ( !lpsmSock || rsSendKillMonsterInfo( lpsmSock )==FALSE ) break;	//정보 보내기
			dwSerToSer_Count++;
		}

		LeaveCriticalSection( &cSerSection );	//크리티칼 섹션 해제

		Count++;
	}

quit_thread:

	ExitThread( TRUE );
	return TRUE;
}


//다른 서버와 연결 초기화
int rsInit_SerToServer()
{

	if ( !dwPlayServTime ) return FALSE;
	if ( rsServerConfig.szLinkServerIP[0] ) {

		if ( !hSerToServer_Thread ) {
			hSerToServer_Thread = CreateThread( NULL , 0, rsTransServerMain_Thread , 0 , 0, &dwSerToServer_ID );
		}

		lstrcpy( szSerToSerIP , rsServerConfig.szLinkServerIP );
		dwSerToSerIP = inet_addr(szSerToSerIP);
	}
	else {
		dwSerToSerIP = 0;
		szSerToSerIP[0] = 0;
	}

	return TRUE;
}

//시스템 회선 연결 종료
int	rsDisconnectSystemLine( smWINSOCK *lpsmSock )
{
	int cnt;

	for( cnt=0;cnt<SER_TO_SERVER_SOCKET_MAX;cnt++ ) {
		if ( lpsmSock_SerToServer[ cnt ]==lpsmSock ) {
			lpsmSock_SerToServer[ cnt ] = 0;
			return TRUE;
		}
	}

	return FALSE;
}


//운영자 명령 사용기록
int	rsSaveAdminCommand( rsPLAYINFO *lpPlayInfo , char *szChatCommand , int Level )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];
	int		len;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	CreateDirectory( AdminLogDirectory , NULL );			//디렉토리 생성

	GetLocalTime( &st );


	wsprintf( szBuff, "%d:%d:%d - ID( %s ) Name( %s ) IP( %s ) AdminLv( %d )> %s\r\n", 
		st.wHour, st.wMinute , st.wSecond,
		lpPlayInfo->szID , lpPlayInfo->szName ,lpPlayInfo->lpsmSock->szIPAddr , Level , szChatCommand );

	len = lstrlen(szBuff);

#ifdef _LANGUAGE_KOREAN				//한국판 암호화
	wsprintf( szFileName , "%s\\(Admin)%d-%d.xog" , AdminLogDirectory , st.wMonth , st.wDay );
	for(int cnt=0;cnt<len;cnt++) {
		szBuff[cnt] = szBuff[cnt]^0x55;
	}
#else
	wsprintf( szFileName , "%s\\(Admin)%d-%d.log" , AdminLogDirectory , st.wMonth , st.wDay );
#endif

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , len , &dwAcess , NULL );
	CloseHandle( hFile );


	return TRUE;
}

//운영자 명령 사용기록
int	rsRecordAdminCommand( rsPLAYINFO *lpPlayInfo , char *szChatCommand , int Level )
{
	TRANS_CHATMESSAGE	TransChatMessage;

	if ( !rsServerConfig.RecordAdminCommand ) return FALSE;
	if ( Level>rsServerConfig.RecordAdminCommand ) return FALSE;

	if ( LoginServer ) {
		rsSaveAdminCommand( lpPlayInfo , szChatCommand , lpPlayInfo->AdminMode );
		return TRUE;
	}

	lstrcpy( TransChatMessage.szMessage , szChatCommand );
	TransChatMessage.dwIP = lpPlayInfo->AdminMode;
	TransChatMessage.dwObjectSerial = lpPlayInfo->dwObjectSerial;
	TransChatMessage.size = lstrlen(TransChatMessage.szMessage)+32;
	TransChatMessage.code = smTRANSCODE_REC_ADMIN_COMMAND;

	return rsSendDataServer( lpPlayInfo->lpsmSock , &TransChatMessage );
}

//관리자 인지 조사
int	rsCheckAdminPlayer( rsPLAYINFO *lpPlayInfo )
{
	int cnt;
	smWINSOCK *lpsmSock = lpPlayInfo->lpsmSock;

	//디버그로 외부 IP접속자 기록 
	if ( !lpPlayInfo->AdminIP ) {

		//디버그 접속 유저 기록 파일로 남김
		RecordDebugPlayLogFile( lpPlayInfo );

		if ( rsServerConfig.DebugIP_Count>0 ) {
			//디버그 IP가 등록되어 있다
			for(cnt=0;cnt<rsServerConfig.DebugIP_Count;cnt++) {
				//등록 IP검사
				if ( strstr( lpsmSock->szIPAddr , rsServerConfig.szDebugIP[cnt] )!=0 ) {
					break;
				}
			}

			if ( cnt<rsServerConfig.DebugIP_Count ) {
				//등록된 IP확인
				return TRUE;
			}
			else {
				//나쁜자들 명단에 등록
				if ( !lpPlayInfo->BlockTime )
					lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );		//24시간 등록

				//등록되지 않은 IP 연결 종료
				DisconnectUser( lpsmSock );
				return FALSE;
			}
		}


		if ( rsServerConfig.DebugID_Count>0 ) {
			//디버그 ID가 등록되어 있다
			for(cnt=0;cnt<rsServerConfig.DebugID_Count;cnt++) {
				//등록 ID검사
				if ( lstrcmpi( lpPlayInfo->szID , rsServerConfig.szDebugID[cnt] )==0 ) {
					break;
				}
			}

			if ( cnt<rsServerConfig.DebugID_Count ) {
				//등록된 ID확인
				return TRUE;;
			}
			else {
				//나쁜자들 명단에 등록
				if ( !lpPlayInfo->BlockTime )
					lpPlayInfo->BlockTime = rsAddBackListID( lpPlayInfo->szID , 1000*60*60*24 );		//24시간 등록
				//등록되지 않은 ID 연결 종료
				DisconnectUser( lpsmSock );
				return FALSE;
			}
		}
	}

	return TRUE;
}

//클랜 머니 기록
int	rsClanMoneyLog( rsPLAYINFO *lpPlayInfo , int Money , int RestMoney )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];
	int		len;

	if ( !lpPlayInfo->lpsmSock ) return FALSE;

	CreateDirectory( HackLogDirectory , NULL );			//디렉토리 생성

	GetLocalTime( &st );


	wsprintf( szBuff, "%d:%d:%d - ID( %s ) Name( %s ) IP( %s ) Money( %d ) RestMoney( %d )\r\n", 
		st.wHour, st.wMinute , st.wSecond,
		lpPlayInfo->szID , lpPlayInfo->szName ,lpPlayInfo->lpsmSock->szIPAddr , Money , RestMoney );

	len = lstrlen(szBuff);

	wsprintf( szFileName , "%s\\(ClanMoney)%d-%d.log" , HackLogDirectory , st.wMonth , st.wDay );

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff , len , &dwAcess , NULL );
	CloseHandle( hFile );


	return TRUE;
}


static int	TestStarPoint=0;
#define	STAR_POINT_PRICE	100000

//별 포인트 관련 처리
int rsRecvStarPoint( rsPLAYINFO *lpPlayInfo ,  smTRANS_COMMAND *lpTransCommand )
{

	int cnt;
	int InvFlag;
	int	StarPoint = 0;
	TRANS_CHATMESSAGE	TransChatMessage;

	//임시 테스트용 처리
	if ( lpTransCommand->WParam>0 ) {

		StarPoint = lpTransCommand->WParam/STAR_POINT_PRICE;

		if ( lpTransCommand->LParam ) {
			//현금
			if ( lpPlayInfo->ServerMoney<lpTransCommand->WParam ) {
				return FALSE;
			}

			lpPlayInfo->SubServerMoney( lpTransCommand->WParam , WHERE_STAR_POINT );


			//돈 분실 아이템 로그
			rsRecord_ItemLog2( lpPlayInfo , sinGG1|sin01 , lpTransCommand->WParam , 0 , ITEMLOG_BUYSTAR );	//아이템 로그 돈

		}
		else {
			//상품권
			InvFlag = 0;

			//상품권 제거
			for( cnt=0;cnt<INVEN_ITEM_INFO_MAX;cnt++ ) {
				if ( lpPlayInfo->InvenItemInfo[cnt].dwCode==(sinGF1|sin01) ) {

					//아이템 분실 아이템 로그
					rsRecord_ItemLog2( lpPlayInfo , lpPlayInfo->InvenItemInfo[cnt].dwCode , 
						lpPlayInfo->InvenItemInfo[cnt].dwKey , lpPlayInfo->InvenItemInfo[cnt].dwSum , ITEMLOG_BUYSTAR );	//아이템 로그 돈

					lpPlayInfo->InvenItemInfo[cnt].dwCode = 0;
					InvFlag++;
				}
			}
			if ( InvFlag==0 ) return FALSE;
		}

		if ( bSql_StarPoint( lpPlayInfo , StarPoint , lpTransCommand->LParam )==FALSE ) {

			//실패한 경우 테스트모드
			TestStarPoint+=lpTransCommand->WParam/STAR_POINT_PRICE;
			lpTransCommand->WParam = TestStarPoint;

			if ( lpPlayInfo->lpsmSock )			
				lpPlayInfo->lpsmSock->Send2( (char *)lpTransCommand , sizeof(smTRANS_COMMAND) , TRUE );
		}

		if ( StarPoint>0 ) {
			TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			wsprintf( TransChatMessage.szMessage , srMsg_400 , StarPoint );
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
	}
	else {
		if ( bSql_StarPoint( lpPlayInfo , StarPoint , lpTransCommand->LParam )==FALSE ) {
			lpTransCommand->WParam = TestStarPoint;
			if ( lpPlayInfo->lpsmSock )			
				lpPlayInfo->lpsmSock->Send2( (char *)lpTransCommand , sizeof(smTRANS_COMMAND) , TRUE );
		}
	}

	return TRUE;
}


static int	TestSodClanCash=0;		//이건 테스트용

//SOD 클랜 상금 관련 처리
int rsRecvSodClanCash( rsPLAYINFO *lpPlayInfo ,  smTRANS_COMMAND *lpTransCommand )
{

	//int cnt;
	//TRANS_CHATMESSAGE	TransChatMessage;
	int cash,kind;

	cash = lpTransCommand->WParam;
	kind = lpTransCommand->SParam;

	//임시 테스트용 처리
	if ( cash>0 ) {
		if ( bSql_ClanMoney( lpPlayInfo , cash , 1 , kind )==FALSE ) {
			if ( lpPlayInfo->AdminMode ) {
				//테스트용
				if ( TestSodClanCash<cash ) {
					/*
					//찾을 돈이 모자랍니다
					TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
					TransChatMessage.dwIP = 0;
					TransChatMessage.dwObjectSerial = 0;
					wsprintf( TransChatMessage.szMessage , srMsg_400 , StarPoint );
					TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
					lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
					*/
					return FALSE;
				}

				lpPlayInfo->AddServerMoney( cash , WHERE_CLAN_MONEY );
				TestSodClanCash -= cash;

				lpTransCommand->WParam = TestSodClanCash;		//잔액
				lpTransCommand->LParam = cash;					//추가된 금액

				//클랜 머니 기록 (텍스트)
				rsClanMoneyLog( lpPlayInfo , cash , TestSodClanCash );

				if ( lpPlayInfo->lpsmSock )			
					lpPlayInfo->lpsmSock->Send2( (char *)lpTransCommand , sizeof(smTRANS_COMMAND) , TRUE );
			}
		}
	}
	else {
		//조회용
		if ( bSql_ClanMoney( lpPlayInfo , 0 , 0 , kind )==FALSE ) {
			lpTransCommand->WParam = TestSodClanCash;		//잔액
			lpTransCommand->LParam = 0;						//추가금액 없음
			if ( lpPlayInfo->lpsmSock )			
				lpPlayInfo->lpsmSock->Send2( (char *)lpTransCommand , sizeof(smTRANS_COMMAND) , TRUE );
		}
	}

	return TRUE;
}



//돈 기부 관련 처리
int rsRecvGiveMoney( rsPLAYINFO *lpPlayInfo ,  smTRANS_COMMAND *lpTransCommand )
{

	TRANS_CHATMESSAGE	TransChatMessage;

	//임시 테스트용 처리
	if ( lpTransCommand->WParam>0 ) {

		if ( lpPlayInfo->ServerMoney<lpTransCommand->WParam ) {
			return FALSE;
		}
		lpPlayInfo->SubServerMoney( lpTransCommand->WParam , WHERE_GIVE_MONEY );

		//GiveMoney 기록
		bSql_GiveMoney( lpPlayInfo , lpTransCommand->WParam );

		TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		wsprintf( TransChatMessage.szMessage , srMsg_401 , lpTransCommand->WParam );
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

	}

	return TRUE;
}

//사용 요금 돈 관련 처리
int rsRecvPaymentMoney( rsPLAYINFO *lpPlayInfo ,  smTRANS_COMMAND *lpTransCommand )
{
	if ( lpTransCommand->LParam<0 || lpTransCommand->LParam>1000000 ) return FALSE;

	switch( lpTransCommand->WParam ) {
		case 1:		//스킬배우기 요금
			CurrencyLog.int64_LearnSkillMoney+=lpTransCommand->LParam;
			lpPlayInfo->SubServerMoney ( lpTransCommand->LParam , WHERE_LEARNSKILL );
			break;
		case 2:		//워프게이트 요금
			CurrencyLog.int64_WarpgateMoney+=lpTransCommand->LParam;
			lpPlayInfo->SubServerMoney ( lpTransCommand->LParam , WHERE_WARPGATE );
			break;
	}

	return TRUE;
}


//이벤트 로그온 성공처리
int rsEventLogOn_Sucess( rsPLAYINFO *lpPlayInfo )
{

	smTRANS_COMMAND	smTransCommand;


	if ( (lpPlayInfo->Bl_Meter&BIMASK_BIRTHDAY_USER)!=0 ) {
		//생일 유저
		if ( rsServerConfig.Event_ComicBirthDay==1 ) {
			smTransCommand.size = sizeof( smTRANS_COMMAND );
			smTransCommand.code = smTRANSCODE_COMIC_SKIN;
			smTransCommand.WParam = (rand()%2)+1;
			smTransCommand.LParam = 60*24*6;
			smTransCommand.SParam = 0;
			smTransCommand.EParam = 0;
			lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
		}
	}

	if ( (lpPlayInfo->Bl_Meter&BIMASK_VIP_USER)!=0 ) {
		//이벤트 정보 설정
		smTransCommand.size = sizeof( smTRANS_COMMAND );
		smTransCommand.code = smTRANSCODE_CHANGE_EVENT;
		smTransCommand.WParam = lpPlayInfo->Bl_Meter;
		smTransCommand.LParam = lpPlayInfo->Bl_RNo;
		smTransCommand.SParam = 0;
		smTransCommand.EParam = 1;
		lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
	}


	return TRUE;
}


/*
//퍼즐 조각이 떨어질 확률
*아이템		5000	pz101 pz102 pz103 pz104 pz201 pz202 pz203 pz204
*아이템		3000	pz104 pz105 pz204 pz205
*아이템		1300	pz105 pz106 pz205 pz206
*아이템		500	pz106 pz107 pz206 pz207
*아이템		200	pz107 pz108 pz207 pz208
*/
struct	sPUZZLE_ITEM {
	DWORD	dwItemCode;
	int		Percent;
};

sPUZZLE_ITEM	sPuzzleItem[] = {
	{	(sinPZ1|sin01)	,	        833	},
	{	(sinPZ1|sin02)	,	       1666	},
	{	(sinPZ1|sin03)	,	       2500	},

	{	(sinPZ2|sin01)	,	       3333	},
	{	(sinPZ2|sin02)	,	       4166	},
	{	(sinPZ2|sin03)	,	       5000	},

	{	(sinPZ1|sin04)	,	       5750	},
	{	(sinPZ1|sin05)	,	       6500	},
	{	(sinPZ2|sin04)	,	       7250	},
	{	(sinPZ2|sin05)	,	       8000	},

	{	(sinPZ1|sin05)	,	       8325	},
	{	(sinPZ1|sin06)	,	       8650	},
	{	(sinPZ2|sin05)	,	       8975	},
	{	(sinPZ2|sin06)	,	       9300	},

	{	(sinPZ1|sin06)	,	       9425	},
	{	(sinPZ1|sin07)	,	       9550	},
	{	(sinPZ2|sin06)	,	       9675	},
	{	(sinPZ2|sin07)	,	       9800	},

	{	(sinPZ1|sin08)	,	       9900	},
	{	(sinPZ2|sin08)	,	       10000},
	{	0,0	}
/*
	{	(sinPZ1|sin01)	,	        625	},
	{	(sinPZ1|sin02)	,	       1250	},
	{	(sinPZ1|sin03)	,	       1875	},
	{	(sinPZ1|sin04)	,	       2500	},

	{	(sinPZ2|sin01)	,	       3125	},
	{	(sinPZ2|sin02)	,	       3750	},
	{	(sinPZ2|sin03)	,	       4375	},
	{	(sinPZ2|sin04)	,	       5000	},

	{	(sinPZ1|sin04)	,	       5750	},
	{	(sinPZ1|sin05)	,	       6500	},
	{	(sinPZ2|sin04)	,	       7250	},
	{	(sinPZ2|sin05)	,	       8000	},

	{	(sinPZ1|sin05)	,	       8325	},
	{	(sinPZ1|sin06)	,	       8650	},
	{	(sinPZ2|sin05)	,	       8975	},
	{	(sinPZ2|sin06)	,	       9300	},

	{	(sinPZ1|sin06)	,	       9425	},
	{	(sinPZ1|sin07)	,	       9550	},
	{	(sinPZ2|sin06)	,	       9675	},
	{	(sinPZ2|sin07)	,	       9800	},

	{	(sinPZ1|sin07)	,	       9850	},
	{	(sinPZ1|sin08)	,	       9900	},
	{	(sinPZ2|sin07)	,	       9950	},
	{	(sinPZ2|sin08)	,	       10000},
	{	0,0	}
*/
};


//퍼즐 아이템 생성 유무
DWORD rsOpenEventPuzzleItem( rsPLAYINFO *lpPlayInfo , smCHAR *lpChar )
{
	int	cnt;
	int	rnd;

	if ( abs(lpPlayInfo->smCharInfo.Level-lpChar->smCharInfo.Level)>15 ) 
		return NULL;		//레벨차가 많이 나서 실패

	if ( lpChar->smCharInfo.Level<20 && abs(lpPlayInfo->smCharInfo.Level-lpChar->smCharInfo.Level)>8 )
		return NULL;		//레벨 20 미만 몬스터는 레벨차 5 이하 일때만 적용

	//SoD에서는 퍼즐 아이템 안나온다
	if ( lpChar->PartyFlag==rsHARDCORE_EVENT_FLAG ) return NULL;

	rnd = rand()%10000;

	cnt = 0;
	while(1) {
		if ( !sPuzzleItem[cnt].dwItemCode ) break;

		if ( rnd<sPuzzleItem[cnt].Percent )
			return sPuzzleItem[cnt].dwItemCode;

		cnt++;
	}

	return NULL;
}

//디버그 메세지 출력
int rsDebugMessageToClient( rsPLAYINFO *lpPlayInfo , char *szDmgMsg )
{
	TRANS_CHATMESSAGE	TransChatMessage;

	if ( lpPlayInfo->AdminMode<=2 ) return FALSE;

	lstrcpy( TransChatMessage.szMessage , szDmgMsg );
	TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
	TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
	TransChatMessage.dwIP = 0;
	TransChatMessage.dwObjectSerial = 0;
	lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

	return TRUE;
}


//개인 상점 거래 처리
int	rsTrade_PersonalShop( rsPLAYINFO *lpPlayInfo , rsPLAYINFO *lpPlayInfo2 , smTRANS_COMMAND_BUFF *lpTransCommandBuff )
{
	sMYSHOP_ITEM_SERVER	*lpMyShopItem = (sMYSHOP_ITEM_SERVER *)lpTransCommandBuff->Buff;
	int	cnt,mCnt;
	int PotionFlag;

#ifdef _TEST_SERVER
	char szBuff[256];
#endif

	switch( lpMyShopItem->SendFlag ) {

		case 1:		//구매 요청
			if ( lpMyShopItem->Price>100000000 ) return FALSE;
			if ( lpPlayInfo->dwMyShopTradeTime>dwPlayServTime ) {
#ifdef _TEST_SERVER
				///////////////////////// 디버그용 출력 //////////////////////
				rsDebugMessageToClient( lpPlayInfo , "> 개인상점 구입 대기 오류" );
#endif
				return FALSE;
			}

			PotionFlag = TRUE;

			//서버포션 확인
			if ( (lpMyShopItem->CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
				if ( rsGetServerPotion( lpPlayInfo2 , lpMyShopItem->CODE )<(int)lpMyShopItem->sTime ) {
					//서버물약 갯수 오류
					//rsServerPotionErrorLog( lpPlayInfo2 ,  lpMyShopItem->CODE , -(int)lpMyShopItem->sTime , 300 );
					PotionFlag = FALSE;
				}
			}
#ifdef _TEST_SERVER
				///////////////////////// 디버그용 출력 //////////////////////
				rsDebugMessageToClient( lpPlayInfo , "> 개인상점 구입 신청" );

				wsprintf( szBuff , "> 개인상점 구입 신청 ( %d %d )" , lpPlayInfo->dwMyShopTradeTime/1000 , dwPlayServTime/1000 );
				rsDebugMessageToClient( lpPlayInfo , szBuff );

#endif

			if ( rsFindInvenItem( lpPlayInfo2 ,  lpMyShopItem->CODE , lpMyShopItem->Head , lpMyShopItem->CkSum )>=0 && 
				lpPlayInfo->ServerMoney>=(int)lpMyShopItem->Price && PotionFlag==TRUE ) 
			{

				lpPlayInfo->dwMyShopTradeTime = dwPlayServTime + 500;			//0.5초 구입 제한 대기
#ifdef _TEST_SERVER
				///////////////////////// 디버그용 출력 //////////////////////
				wsprintf( szBuff , "> 개인상점 구입 대기 ( %d %d )" , lpPlayInfo->dwMyShopTradeTime/1000 , dwPlayServTime/1000 );
				rsDebugMessageToClient( lpPlayInfo , szBuff );
#endif

				if ( lpPlayInfo->MyShopListCount==0 ) {
					ZeroMemory( lpPlayInfo->sMyShopList , sizeof(sMYSHOP_SELL_INFO)*MYSHOP_LIST_MAX );
				}
				else {
					for( cnt=0;cnt<MYSHOP_LIST_MAX;cnt++ ) {
						if ( lpPlayInfo->sMyShopList[cnt].dwCode && 
							lpMyShopItem->CODE==lpPlayInfo->sMyShopList[cnt].dwCode &&
							lpMyShopItem->Head==lpPlayInfo->sMyShopList[cnt].dwHead &&
							lpMyShopItem->CkSum==lpPlayInfo->sMyShopList[cnt].dwChkSum &&
							lpMyShopItem->Price==lpPlayInfo->sMyShopList[cnt].Price ) {
								return TRUE;
							}
					}
				}

				mCnt = lpPlayInfo->MyShopListCount&MYSHOP_LIST_MASK;
				lpPlayInfo->sMyShopList[mCnt].dwCode	= lpMyShopItem->CODE;
				lpPlayInfo->sMyShopList[mCnt].dwHead	= lpMyShopItem->Head;
				lpPlayInfo->sMyShopList[mCnt].dwChkSum	= lpMyShopItem->CkSum;
				lpPlayInfo->sMyShopList[mCnt].Price		= lpMyShopItem->Price;
				lpPlayInfo->MyShopListCount ++;
				return TRUE;
			}

			if ( lpPlayInfo->ServerMoney>=(int)lpMyShopItem->Price ) {
				lpTransCommandBuff->smTransCommand.LParam = lpPlayInfo2->dwObjectSerial;
				lpTransCommandBuff->smTransCommand.SParam = lpPlayInfo->dwObjectSerial;
				lpMyShopItem->SendFlag = 3;		//이미 물건 팔렸음
				if ( lpPlayInfo->lpsmSock )
					lpPlayInfo->lpsmSock->Send2( (char *)lpTransCommandBuff , lpTransCommandBuff->smTransCommand.size , TRUE );
			}
			return FALSE;

		case 2:		//구매 실행
			if ( lpMyShopItem->Price>100000000 ) return FALSE;

			for( cnt=0;cnt<MYSHOP_LIST_MAX;cnt++ ) {
				if ( lpPlayInfo2->sMyShopList[cnt].dwCode && 
					lpMyShopItem->CODE==lpPlayInfo2->sMyShopList[cnt].dwCode &&
					lpMyShopItem->Head==lpPlayInfo2->sMyShopList[cnt].dwHead &&
					lpMyShopItem->CkSum==lpPlayInfo2->sMyShopList[cnt].dwChkSum &&
					lpMyShopItem->Price==lpPlayInfo2->sMyShopList[cnt].Price ) 
				{
					if ( lpPlayInfo2->ServerMoney>=(int)lpMyShopItem->Price ) {

						//서버포션 저장
						if ( (lpMyShopItem->CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
							if ( rsAddServerPotion( lpPlayInfo , lpMyShopItem->CODE , -(int)(lpMyShopItem->sTime) )<0 ) {
								//서버물약 갯수 오류
								rsServerPotionErrorLog( lpPlayInfo ,  lpMyShopItem->CODE , -(int)lpMyShopItem->sTime , 310 );
								return FALSE;
							}
							rsAddServerPotion( lpPlayInfo2 , lpMyShopItem->CODE , lpMyShopItem->sTime );
						}

						if ( rsDeleteInvenItem( lpPlayInfo , lpMyShopItem->CODE , lpMyShopItem->Head , lpMyShopItem->CkSum )>=0 ) {

							lpPlayInfo2->SubServerMoney( lpMyShopItem->Price , WHERE_PERSONAL_SHOP );
							lpPlayInfo->AddServerMoney( lpMyShopItem->Price , WHERE_PERSONAL_SHOP );

							rsAddInvenItem( lpPlayInfo2 , lpMyShopItem->CODE , lpMyShopItem->Head , lpMyShopItem->CkSum );

							//아이템 로그 개인상점
							if ( (lpMyShopItem->CODE&sinITEM_MASK1)==(sinPM1&sinITEM_MASK1) ) {
								rsRecord_ItemLog_MyShop( lpPlayInfo, lpPlayInfo2, 
									lpMyShopItem->CODE , lpMyShopItem->sTime , 0 , 
									lpMyShopItem->Price );
							}
							else {
								rsRecord_ItemLog_MyShop( lpPlayInfo, lpPlayInfo2, 
									lpMyShopItem->CODE , lpMyShopItem->Head , lpMyShopItem->CkSum , 
									lpMyShopItem->Price );
							}

							return TRUE;
						}
					}
					break;
				}
			}
			return FALSE;

	}

#ifdef _TEST_SERVER
	///////////////////////// 디버그용 출력 //////////////////////
	wsprintf( szBuff , "> 개인상점 메세지 ( %d )" , lpMyShopItem->SendFlag );
	rsDebugMessageToClient( lpPlayInfo2 , szBuff );
#endif


	return TRUE;
}

//사랑의 아이템을 사용
int	rsUseLovelyItem( rsPLAYINFO *lpPlayInfo , DWORD	dwItemCode )
{

	int	JobCode;
	int Level = 0;
	smTRANS_COMMAND	smTransCommand;

	JobCode = lpPlayInfo->smCharInfo.JOB_CODE;

	switch( dwItemCode ) {
		case (sinCH1|sin01):		//초꼬렛
			if ( JobCode==JOBCODE_ATALANTA || JobCode==JOBCODE_ARCHER || JobCode==JOBCODE_PRIESTESS ) return FALSE;
			Level = 4;
			break;

		case (sinCH1|sin02):		//쪼꼬렛
			if ( JobCode==JOBCODE_ATALANTA || JobCode==JOBCODE_ARCHER || JobCode==JOBCODE_PRIESTESS ) return FALSE;
			Level = 8;
			break;

		case (sinCH1|sin03):		//사탕
			if ( JobCode!=JOBCODE_ATALANTA && JobCode!=JOBCODE_ARCHER && JobCode!=JOBCODE_PRIESTESS ) return FALSE;
			Level = 4;
			break;

		case (sinCH1|sin04):		//사탕
			if ( JobCode!=JOBCODE_ATALANTA && JobCode!=JOBCODE_ARCHER && JobCode!=JOBCODE_PRIESTESS ) return FALSE;
			Level = 8;
			break;

	}

	if ( Level==0 ) return FALSE;

	smTransCommand.code = smTRANSCODE_PROCESS_SKILL2;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam = SKILL_PLAY_LOVELY_LIFE;
	smTransCommand.LParam = lpPlayInfo->dwObjectSerial;
	smTransCommand.SParam = 0;
	smTransCommand.EParam = 0;

	lpPlayInfo->dwSkill_VirtualLife_Time = dwPlayServTime+Virtual_Life_Time[Level-1]*1000;
	lpPlayInfo->dwSkill_VirtualLife_Param = Virtual_Life_Percent[Level-1];
	smTransCommand.WParam |= (Level<<8);
	rsSendCommandUser2( lpPlayInfo , &smTransCommand );
	//lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

	return TRUE;
}


//바벨 생명력 재생 테이블
static int	Babel_LifeRegenTable[10][2] = {
	{	1800	,	2300	},
	{	1900	,	2400	},
	{	2000	,	2550	},
	{	2150	,	2650	},
	{	2300	,	2800	},
	{	2400	,	2900	},
	{	2500	,	3000	},
	{	2600	,	3100	},
	{	2700	,	3200	},
	{	2800	,	3300	}
};

//몬스터 생명력 재생치 구하는 함수
int rsGetMonsterLifeRegen( smCHAR *lpChar )
{
	int cnt;
	rsPLAYINFO *lpPlayInfo;
	STG_AREA	*lpStgArea = (STG_AREA *)lpChar->lpExt1;
	int x,y,z,dist;
	int NearUserCnt;
	int dRange;
	rsPLAYINFO	*lpDebugPlayInfo = 0;
	int	RegenLife;

	if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_BABEL ) {
		//바벨 생명력 재생
		dRange = 260*260;		//접근 제한 거리
		NearUserCnt = 0;

		for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
			lpPlayInfo = &rsPlayInfo[cnt];
			if ( lpPlayInfo->lpsmSock && lpPlayInfo->dwObjectSerial && lpPlayInfo->Position.Area==lpStgArea->lpField->FieldCode ) {

				x = ( lpChar->pX-lpPlayInfo->Position.x )>>FLOATNS;
				y = ( lpChar->pY-lpPlayInfo->Position.y )>>FLOATNS;
				z = ( lpChar->pZ-lpPlayInfo->Position.z )>>FLOATNS;
				dist = x*x+z*z;

				if ( abs(y)<60 && dist<dRange && abs(x)<TRANS_VIEW_LIMIT && abs(z)<TRANS_VIEW_LIMIT ) {
					NearUserCnt++;

					if ( lpPlayInfo->AdminMode>=3 )
						lpDebugPlayInfo = lpPlayInfo;
				}
			}
		}

		cnt = 0;
		if ( NearUserCnt>6 ) {
			if ( NearUserCnt>15 )
				cnt = 9;
			else
				cnt = NearUserCnt-6;
		}

		if ( lpChar->smCharInfo.Life[0]<(lpChar->smCharInfo.Life[1]/5) )
			RegenLife = Babel_LifeRegenTable[cnt][1];
		else
			RegenLife = Babel_LifeRegenTable[cnt][0];

#ifdef _LANGUAGE_KOREAN
		if ( lpDebugPlayInfo ) {		//재생 디버깅 코드
			TRANS_CHATMESSAGE	TransChatMessage;

			wsprintf( TransChatMessage.szMessage , "바벨 생명 재생 ( 주변:%d명 ) ( 재생력:%d )",NearUserCnt,RegenLife );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = 0;
			lpDebugPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
#endif
		return RegenLife;
	}

	return 0;
}

//바벨 일반공격시 스킬도 같이 적용 (범위지정)
int rsSendRangeDamage( smCHAR *lpChar , rsPLAYINFO *lpMainPlayInfo , int Range , int SubDamgePers )
{
	int cnt;
	rsPLAYINFO *lpPlayInfo;
	STG_AREA	*lpStgArea = (STG_AREA *)lpChar->lpExt1;
	int x,y,z,dist;
	int dRange = Range*Range;
	int BackDamge[2];

	int		UserCount = 0;
	rsPLAYINFO	*lpUserList[16];

	int		sndUserCount = 0;
	rsPLAYINFO	*lpSndUserList[128];


	if ( !lpStgArea || !lpStgArea->lpField ) return FALSE;


	lpUserList[UserCount++] = lpMainPlayInfo;
	lpSndUserList[sndUserCount++] = lpMainPlayInfo;

	for( cnt=0;cnt<CONNECTMAX;cnt++ ) {
		lpPlayInfo = &rsPlayInfo[cnt];
		if ( lpPlayInfo->lpsmSock && lpPlayInfo->dwObjectSerial && lpPlayInfo->Position.Area==lpStgArea->lpField->FieldCode && lpPlayInfo!=lpMainPlayInfo ) {

			x = ( lpMainPlayInfo->Position.x-lpPlayInfo->Position.x )>>FLOATNS;
			y = ( lpMainPlayInfo->Position.y-lpPlayInfo->Position.y )>>FLOATNS;
			z = ( lpMainPlayInfo->Position.z-lpPlayInfo->Position.z )>>FLOATNS;
			dist = x*x+z*z;

			if ( abs(y)<60 && dist<dRange && abs(x)<TRANS_VIEW_LIMIT && abs(z)<TRANS_VIEW_LIMIT ) {
				if ( UserCount<16 )
					lpUserList[UserCount++] = lpPlayInfo;
			}

			if ( dist<DIST_TRANSLEVEL_HIGH && abs(x)<TRANS_VIEW_LIMIT && abs(z)<TRANS_VIEW_LIMIT ) {
				if ( sndUserCount<128 )
					lpSndUserList[sndUserCount++] = lpPlayInfo;
			}

		}
	}

	BackDamge[0] = lpChar->smCharInfo.Attack_Damage[0];
	BackDamge[1] = lpChar->smCharInfo.Attack_Damage[1];

	lpChar->smCharInfo.Attack_Damage[0] = (lpChar->smCharInfo.Attack_Damage[0]*SubDamgePers)/fONE;
	lpChar->smCharInfo.Attack_Damage[1] = (lpChar->smCharInfo.Attack_Damage[1]*SubDamgePers)/fONE;


	for( cnt=0;cnt<UserCount;cnt++ ) {
		if ( lpUserList[cnt]!=lpMainPlayInfo )
			lpChar->SendTransAttack( 0 , lpUserList[cnt]->lpsmSock , 0);
	}


	lpChar->smCharInfo.Attack_Damage[0] = BackDamge[0];
	lpChar->smCharInfo.Attack_Damage[1] = BackDamge[1];

	TRANS_SKIL_ATTACKDATA	TransSkillAttackData;
	ZeroMemory(&TransSkillAttackData,sizeof(TRANS_SKIL_ATTACKDATA));

	TransSkillAttackData.size = sizeof(TRANS_SKIL_ATTACKDATA)-(sizeof(DWORD)*(SKIL_ATTACK_CHAR_MAX-UserCount));
	if ( UserCount>0 && TransSkillAttackData.size>32 ) {
		TransSkillAttackData.code = smTRANSCODE_ATTACK_SLASH_LIST;
		TransSkillAttackData.dwDestObjectSerial = lpChar->dwObjectSerial;
		TransSkillAttackData.TargetCount = UserCount;
		for(cnt=0;cnt<UserCount;cnt++) {
			TransSkillAttackData.dwTarObjectSerial[cnt] = lpUserList[cnt]->dwObjectSerial;
		}
		for(cnt=0;cnt<sndUserCount;cnt++) {
			if ( lpSndUserList[cnt]->lpsmSock )
				lpSndUserList[cnt]->lpsmSock->Send2( (char *)&TransSkillAttackData , TransSkillAttackData.size , TRUE );
		}
	}

	return TRUE;
}
/*
#define MORIF_CHAT_MAX		4
char *szMorifChatMsg[MORIF_CHAT_MAX] = {
#define MORIF_CHAT_DROP_MAX		3
char *szMorifChatDropMsg[MORIF_CHAT_DROP_MAX] = {
*/

//이벤트용 모리프 대시
int	rsMorifEventMessage( smCHAR *lpChar )
{
#ifdef _W_SERVER
	TRANS_CHATMESSAGE	TransChatMessage;
	char	*lpChatMsg = 0;

	if ( lpChar->dwChatMessageTimer>dwPlayServTime ) return FALSE;

	if ( lpChar->MotionInfo->State==CHRMOTION_STATE_DEAD && lpChar->FrameCounter>40 ) {
		lpChatMsg = szMorifChatDropMsg[ rand()%MORIF_CHAT_DROP_MAX ];
		lpChar->dwChatMessageTimer = dwPlayServTime+60*1000;		//60초후에
	}
	else {
		if ( (rand()%100)<15 ) {
			lpChatMsg = szMorifChatMsg[ rand()%MORIF_CHAT_MAX ];
		}
		lpChar->dwChatMessageTimer = dwPlayServTime+4*1000;		//5초후에
	}

	if ( lpChar->lpTargetPlayInfo && lpChatMsg ) {

		wsprintf( TransChatMessage.szMessage , "%s: %s " , lpChar->smCharInfo.szName , lpChatMsg );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = lpChar->dwObjectSerial;

		rsSendCommandUser2( lpChar->lpTargetPlayInfo , (smTRANS_COMMAND *)&TransChatMessage );

		return TRUE;
	}
#endif
	return FALSE;
}

//이벤트용 늑대 대사
int	rsMollyWolfEventMessage( smCHAR *lpChar )
{
#ifdef _W_SERVER
	TRANS_CHATMESSAGE	TransChatMessage;
	char	*lpChatMsg = 0;

	if ( lpChar->dwChatMessageTimer>dwPlayServTime ) return FALSE;

	if ( lpChar->MotionInfo->State==CHRMOTION_STATE_DEAD && lpChar->FrameCounter>40 ) {
		lpChatMsg = szMollyWolfChatDropMsg[ rand()%MOLLYWOLF_CHAT_DROP_MAX ];
		lpChar->dwChatMessageTimer = dwPlayServTime+60*1000;		//60초후에
	}
	else {
		if ( (rand()%100)<15 ) {
			lpChatMsg = szMollyWolfChatMsg[ rand()%MOLLYWOLF_CHAT_MAX ];
		}
		lpChar->dwChatMessageTimer = dwPlayServTime+4*1000;		//5초후에
	}

	if ( lpChar->lpTargetPlayInfo && lpChatMsg ) {

		wsprintf( TransChatMessage.szMessage , "%s: %s " , lpChar->smCharInfo.szName , lpChatMsg );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = lpChar->dwObjectSerial;

		rsSendCommandUser2( lpChar->lpTargetPlayInfo , (smTRANS_COMMAND *)&TransChatMessage );

		return TRUE;
	}
#endif
	return FALSE;
}


//퀘스트용 마스터 대사
int	rsQuestMasterMessage( smCHAR *lpChar , rsPLAYINFO *lpPlayInfo )
{
#ifdef _W_SERVER
	TRANS_CHATMESSAGE	TransChatMessage;
	char	*lpChatMsg = 0;
	int x,z,dist;

	if ( lpChar->dwChatMessageTimer>dwPlayServTime ) return FALSE;
	if ( lpChar->ActionPattern==12 ) return FALSE;		//전투 종료 중립모드

	if ( (rand()%100)<30 ) {
		switch( lpChar->smCharInfo.dwCharSoundCode ) {
		case snCHAR_SOUND_NPC_SKILLMASTER:
			lpChatMsg = szSkillMasterChatMsg[ rand()%SKILLMASTER_CHAT_MAX ];
			break;
		case snCHAR_SOUND_NPC_MAGICMASTER:
			lpChatMsg = szMagicMasterChatMsg[ rand()%MAGICMASTER_CHAT_MAX ];
			break;
		}
	}

	lpChar->dwChatMessageTimer = dwPlayServTime+4*1000;		//5초후에

	if ( lpChar && lpChatMsg && lpPlayInfo->lpsmSock ) {

		x = ( lpChar->pX-lpPlayInfo->Position.x )>>FLOATNS;
		z = ( lpChar->pZ-lpPlayInfo->Position.z )>>FLOATNS;
		dist = x*x+z*z;
		//거리 계산
		if ( dist<DIST_TRANSLEVEL_LOW && abs(x)<TRANS_VIEW_LIMIT && abs(z)<TRANS_VIEW_LIMIT ) {
			wsprintf( TransChatMessage.szMessage , "%s: %s " , lpChar->smCharInfo.szName , lpChatMsg );
			TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
			TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
			TransChatMessage.dwIP = 0;
			TransChatMessage.dwObjectSerial = lpChar->dwObjectSerial;

			lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
		}
		return TRUE;
	}
#endif
	return FALSE;
}

//산타고블린 대사
int	rsSantaGoblinEventMessage( smCHAR *lpChar )
{
#ifdef _W_SERVER
	TRANS_CHATMESSAGE	TransChatMessage;
	char	*lpChatMsg = 0;

	if ( lpChar->dwChatMessageTimer>dwPlayServTime ) return FALSE;


	if ( lpChar->MotionInfo->State==CHRMOTION_STATE_DEAD && lpChar->FrameCounter>40 ) {
		lpChar->dwChatMessageTimer = dwPlayServTime+60*1000;		//60초후에
		return FALSE;
	}
	else {
		if ( (rand()%100)<15 ) {
			lpChatMsg = szSantaGoblinChatMsg[ rand()%SANTAGOBLIN_CHAT_MAX ];
		}
		lpChar->dwChatMessageTimer = dwPlayServTime+4*1000;		//5초후에
	}

	if ( lpChar->lpTargetPlayInfo && lpChatMsg ) {

		wsprintf( TransChatMessage.szMessage , "%s: %s " , lpChar->smCharInfo.szName , lpChatMsg );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = lpChar->dwObjectSerial;

		rsSendCommandUser2( lpChar->lpTargetPlayInfo , (smTRANS_COMMAND *)&TransChatMessage );

		return TRUE;
	}
#endif
	return FALSE;
}


/*
//이벤트용 월드컵 대사
int	rsWorldCupEventMessage( smCHAR *lpChar )
{
#ifdef _W_SERVER
	TRANS_CHATMESSAGE	TransChatMessage;
	char	*lpChatMsg = 0;

	if ( lpChar->dwChatMessageTimer>dwPlayServTime ) return FALSE;

	if ( lpChar->MotionInfo->State==CHRMOTION_STATE_DEAD && lpChar->FrameCounter>40 ) {
		lpChatMsg = szWorldCupChatDropMsg[ rand()%WORLDCUP_CHAT_DROP_MAX ];
		lpChar->dwChatMessageTimer = dwPlayServTime+60*1000;		//60초후에
	}
	else {
		if ( (rand()%100)<15 ) {
			lpChatMsg = szWorldCupChatMsg[ rand()%WORLDCUP_CHAT_MAX ];
		}
		lpChar->dwChatMessageTimer = dwPlayServTime+4*1000;		//5초후에
	}

	if ( lpChar->lpTargetPlayInfo && lpChatMsg ) {

		wsprintf( TransChatMessage.szMessage , "%s: %s " , lpChar->smCharInfo.szName , lpChatMsg );
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = lpChar->dwObjectSerial;

		rsSendCommandUser2( lpChar->lpTargetPlayInfo , (smTRANS_COMMAND *)&TransChatMessage );

		return TRUE;
	}
#endif
	return FALSE;
}
*/


//특정위치에 몬스터또는 물체 강제 출현 시킴
smCHAR *rsOpenCastleFieldObject( STG_AREA *lpStgArea , smCHAR_INFO *lpCharInfo , int x, int y, int z )
{
	smCHAR	*lpChar;
	STG_CHAR_INFO StgCharInfo;

	if ( lpStgArea ) {
		StgCharInfo.PosiState = smCHAR_STATE_ENEMY;
		StgCharInfo.smCharInfo.Life[0] = 100;
		StgCharInfo.smCharInfo.Mana[0] = 100;
		StgCharInfo.smCharInfo.Life[1] = 100;
		StgCharInfo.smCharInfo.State = TRUE;

		memcpy( &StgCharInfo.smCharInfo , lpCharInfo , sizeof(smCHAR_INFO) );

		lpStgArea->EvnMonster = TRUE;
		lpChar = lpStgArea->OpenMonster( &StgCharInfo , 0 );
		if ( lpChar ) {
			lpChar->pX = x;
			lpChar->pY = y;
			lpChar->pZ = z;
			lpChar->Angle.x = 0;
			lpChar->Angle.y = 0;
			lpChar->Angle.z = 0;
			lpChar->DistAroundDbl = 0;
			lpChar->SetMotionFromCode( CHRMOTION_STATE_STAND );
			lpChar->TargetMoveCount = 0;
			if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_TOWER_B ||
				lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_R ||
				lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_G ||
				lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_B ||
				lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_N ||
				lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_DOOR ||
				lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_DEATHKNIGHT ) 
			{			
				lpChar->DontMoveFlag = 2;

				if ( StgCharInfo.smCharInfo.lpMonInfo && StgCharInfo.smCharInfo.lpMonInfo->PotionCount ) {
					//물약카운터가 상위값 처리
					lpChar->smMonsterInfo.PotionCount = 0;
					//물체 가상의 생명력
					lpChar->UseObject_VirtualLife = StgCharInfo.smCharInfo.lpMonInfo->PotionCount;
					lpChar->sObject_VirtualLife[0] = lpChar->UseObject_VirtualLife;	
					lpChar->sObject_VirtualLife[1] = lpChar->UseObject_VirtualLife;	
					lpChar->sObject_DisplayLife[0] = lpChar->UseObject_VirtualLife;
					lpChar->sObject_DisplayLife[1] = lpChar->UseObject_VirtualLife;
				}
			}
			else {
				//용병 (물약 최대치)
				lpChar->smMonsterInfo.PotionCount = StgCharInfo.smCharInfo.lpMonInfo->PotionCount;
				lpChar->PosiAround.x = x;
				lpChar->PosiAround.y = y;
				lpChar->PosiAround.z = z;
				lpChar->DistAroundDbl =  DIST_AROUND_MIDDLE;
			}

			lpChar->dwClanCode = rsBlessCastle.dwMasterClan;

			return lpChar;
		}
	}

	return FALSE;
}

#include	"BlessCastle.h"

static	DWORD	dwBlessCastle_TowerRegenTime;

struct BLESS_CASTLE_OPEN_LEAUGE {
	int		GameMode;			//리그 설정 모드
	DWORD	dwStartTime;		//처임 시작 시간
	DWORD	dwEndTime;			//종료시간
	DWORD	dwRestartTime;		//재시작 시간
};

static BLESS_CASTLE_OPEN_LEAUGE	rsBlessCastleOpenLeauge;		//오픈 리그전


//성 초기화
int rsInit_Castle()
{
	ZeroMemory( &rsBlessCastle , sizeof( rsBLESS_CASTLE ) );
	ZeroMemory( &rsBlessCastleOpenLeauge , sizeof( BLESS_CASTLE_OPEN_LEAUGE ) );

	rsLoadCastleInfo();		//블레스 캐슬 로딩

	rsBlessCastle.dwSoulFountainTime = 0;
	rsBlessCastle.dwSoulFountainTime2 = 0;
	rsBlessCastle.lpAttackDamageList = 0;
	rsBlessCastle.lpChar_ValhallaTower = 0;

	ZeroMemory( &rsBlessCastle.ClanTop10 , sizeof(rsUSER_LIST_TOP10) );

	dwBlessCastle_TowerRegenTime = 0;

	return TRUE;
}

//공성 처리메인
int rsMain_CombatCastle()
{
	int cnt;
	int DoorCount = 0;
	int	ValhallaTowerCount = 0;
	int	CrystalTowerCount = 0;
	smCHAR *lpChar;
	smCHAR *lpChar_ValhallaTower = 0;
	STG_AREA	*lpStgArea=&StageArea[rsCASTLE_FIELD];
	int	UpdateFlag = 0;

	rsBlessCastle.Counter++;

	rsBlessCastle_SoulFountainMain();		//영혼의샘터

	if ( rsBlessCastleOpenLeauge.GameMode ) { //리그전
		if ( rsBlessCastleOpenLeauge.dwEndTime && rsBlessCastleOpenLeauge.dwEndTime<dwPlayServTime ) {
			//리그 종료 (시간초과)
			rsBlessCastleOpenLeauge.GameMode = 0;
		}
		else {
			if ( !rsBlessCastle.CastleMode ) {
				if ( rsBlessCastleOpenLeauge.dwRestartTime && rsBlessCastleOpenLeauge.dwRestartTime<dwPlayServTime ) {
					//리그전 재시작
					rsStart_CombatCastle();
				}
			}
		}
	}

	if ( !rsBlessCastle.CastleMode ) {
		rsBlessCastle.TimeSec[0] = 0;
		rsBlessCastle.TimeSec[1] = 0;
		return FALSE;
	}

	if ( rsBlessCastle.CastleMode==3 ) {
		//종료후 대기시간
		if ( rsBlessCastle.dwBattleOverTime<dwPlayServTime ) {
			rsEnd_CombatCastle();
		}
		return TRUE;
	}

	if ( (rsBlessCastle.Counter&0x1F)==0 ) {

		//시간 초로 환산하여 기록
		rsBlessCastle.TimeSec[0] = (short)((dwPlayServTime - rsBlessCastle.dwStartTime)/1000);					//진행초
		rsBlessCastle.TimeSec[1] = (short)((rsBlessCastle.dwBattleOverTime - rsBlessCastle.dwStartTime)/1000);	//종료초

		((DWORD *)rsBlessCastle.bCrystalSolderCount)[0] = 0;
		((DWORD *)rsBlessCastle.bCrystalTowerCount)[0] = 0;


		for( cnt=0;cnt<STG_MONSTER_MAX;cnt++ ) {
			if ( lpStgArea->lpCharMonster[cnt] && lpStgArea->lpCharMonster[cnt]->smCharInfo.Life[0]>0 ) {
				lpChar = lpStgArea->lpCharMonster[cnt];
				if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_DOOR ) {
					DoorCount++;
				}
				else if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_TOWER_B ) 
				{
					ValhallaTowerCount++;
					lpChar_ValhallaTower = lpChar;
				}
				else if ( lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_R ||
					lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_G ||
					lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_B ||
					lpChar->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_N ) 
				{

					switch( lpChar->smCharInfo.dwCharSoundCode ) {
						case snCHAR_SOUND_CASTLE_CRYSTAL_R:
							if ( rsBlessCastle.bCrystalTowerCount[0]<100 ) rsBlessCastle.bCrystalTowerCount[0] ++;
							break;
						case snCHAR_SOUND_CASTLE_CRYSTAL_G:
							if ( rsBlessCastle.bCrystalTowerCount[1]<100 ) rsBlessCastle.bCrystalTowerCount[1] ++;
							break;
						case snCHAR_SOUND_CASTLE_CRYSTAL_B:
							if ( rsBlessCastle.bCrystalTowerCount[2]<100 ) rsBlessCastle.bCrystalTowerCount[2] ++;
							break;
						case snCHAR_SOUND_CASTLE_CRYSTAL_N:
							if ( rsBlessCastle.bCrystalTowerCount[3]<100 ) rsBlessCastle.bCrystalTowerCount[3] ++;
							break;
					}


					CrystalTowerCount++;

					//데미지 공격 순위 설정 ( 성문파괴 , 공격순위버퍼 준비됨 )
					if ( rsBlessCastle.DefenceLevel==0 &&
						rsBlessCastle.lpAttackDamageList &&
						!lpChar->lpAttackDamageList_BlessCastle ) 
					{
						lpChar->lpAttackDamageList_BlessCastle = rsBlessCastle.lpAttackDamageList;
					}

				}
				else if ( lpChar->smCharInfo.Next_Exp ) {
					//클리스탈 용병 갯수
					switch( lpChar->smCharInfo.dwCharSoundCode ) {
						case snCHAR_SOUND_CASTLE_SOLDER_A:
							if ( rsBlessCastle.bCrystalSolderCount[0]<100 ) rsBlessCastle.bCrystalSolderCount[0]++;
							break;
						case snCHAR_SOUND_CASTLE_SOLDER_B:
							if ( rsBlessCastle.bCrystalSolderCount[1]<100 ) rsBlessCastle.bCrystalSolderCount[1]++;
							break;
						case snCHAR_SOUND_CASTLE_SOLDER_C:
							if ( rsBlessCastle.bCrystalSolderCount[2]<100 ) rsBlessCastle.bCrystalSolderCount[2]++;
							break;
					}
				}

				lpChar->dwLastTransTime = dwPlayServTime;		//시간이 지나도 사라지지 않도록 조치
				lpChar->ReopenCount	= REOPEN_COUNT_NUM;			//슬립모드시 재시작 시간 카운터
			}
		}

		if ( rsBlessCastle.DefenceLevel==0 && DoorCount==0 ) {
			rsBlessCastle.DefenceLevel++;
		}
/*
		if ( lpChar_ValhallaTower && dwBlessCastle_TowerRegenTime<dwPlayServTime ) {
			dwBlessCastle_TowerRegenTime = dwPlayServTime+=5000;		//5초 단위로 리젠

			if ( lpChar_ValhallaTower->smCharInfo.Life[0]>0 ) {
				//크리스탈 타워 남은수를 감안하여 발할라타워 생명령업
				lpChar_ValhallaTower->smCharInfo.Life[0] += (ValhallaTowerCount*20)+40;

				if ( lpChar_ValhallaTower->smCharInfo.Life[0]>lpChar_ValhallaTower->smCharInfo.Life[1] ) 
					lpChar_ValhallaTower->smCharInfo.Life[0] = lpChar_ValhallaTower->smCharInfo.Life[1];	//최대치
			}
		}
*/
		if ( ValhallaTowerCount==0 ) {
			rsEnd_CombatCastle( 0 );							//게임종료 발할라탑 파괴됐음
			if ( rsBlessCastle.ClanTop10.dwUserCode[0] ) {
				rsBlessCastle.dwMasterClan = GetClanCode(rsBlessCastle.ClanTop10.dwUserCode[0]);	//점령한 클랜설정
				UpdateFlag = 2;
				rsSaveCastleInfo();		//저장
			}
		}
		else if ( rsBlessCastle.dwBattleOverTime<dwPlayServTime ) 
		{
			//시간 종료 수성 성공
			rsEnd_CombatCastle( 1 );								//수성 성공
			UpdateFlag = 2;
			rsSaveCastleInfo();		//저장
		}

		rsBlessCastle.lpChar_ValhallaTower = lpChar_ValhallaTower;

		//발할라 타워  
		if ( lpChar_ValhallaTower ) {
			if ( CrystalTowerCount>0 ) {	//복구 (크리스탈이 남아 있는경우)
				lpChar_ValhallaTower->smCharInfo.Life[0] = lpChar_ValhallaTower->smCharInfo.Life[1];
			}
			else {
				//클랜순위 설정용 (버퍼 생성)
				if ( !lpChar_ValhallaTower->lpAttackDamageList ) {
					if ( rsBlessCastle.lpAttackDamageList ) {
						lpChar_ValhallaTower->lpAttackDamageList = rsBlessCastle.lpAttackDamageList;
						rsBlessCastle.lpAttackDamageList = 0;
					}
					else {
						lpChar_ValhallaTower->lpAttackDamageList = new ATTACK_DAMAGE_LIST[ ATTACK_DAMAGE_LIST_MAX ];
						if ( lpChar_ValhallaTower->lpAttackDamageList )
							ZeroMemory( lpChar_ValhallaTower->lpAttackDamageList , sizeof(ATTACK_DAMAGE_LIST)*ATTACK_DAMAGE_LIST_MAX );
					}
				}
			}
			//데미지준 클랜 10명 선별
			if ( rsBlessCastle.DefenceLevel ) {
				rsSelectDamageClanTop10( lpChar_ValhallaTower ,  &rsBlessCastle.ClanTop10 );
			}
		}
	}

	if ( rsBlessCastle.ClanTop10.code ) {
		for(cnt=(rsBlessCastle.Counter&0x1F);cnt<CONNECTMAX;cnt+=0x20) {
			if ( rsPlayInfo[cnt].lpsmSock && rsPlayInfo[cnt].dwObjectSerial && rsPlayInfo[cnt].Position.Area==rsCASTLE_FIELD ) {
				//블레스 캐슬 순위 정보 보내기
				rsPlayInfo[cnt].lpsmSock->Send( (char *)&rsBlessCastle.ClanTop10 , rsBlessCastle.ClanTop10.size , TRUE );
				if ( UpdateFlag>0 ) {
					rsSendBlessCastleInfoToDataServer( &rsPlayInfo[cnt] );			//데이타 서버에 내용 통보
					UpdateFlag--;
				}
			}
		}
	}

	return TRUE;
}


//공성모드 시작
int	rsStart_CombatCastle()
{
	int cnt;
	STG_AREA	*lpStgArea=&StageArea[rsCASTLE_FIELD];
	smCHAR	*lpChar;

	if ( rsServerConfig.BlessCastleMode==2 ) {
		//공성 오픈 리그전
		rsBlessCastleOpenLeauge.GameMode = 1;
		rsBlessCastleOpenLeauge.dwStartTime = dwPlayServTime;
		rsBlessCastleOpenLeauge.dwEndTime = dwPlayServTime+120*60*1000;	//120분 설정
		rsServerConfig.BlessCastleMode = 1;
	}

	rsBlessCastle.CastleMode = 1;
	rsBlessCastle.Counter = 0;
	rsBlessCastle.DefenceLevel = 0;
	rsBlessCastle.dwBattleOverTime = dwPlayServTime+120*60*1000;	//120분 설정
	rsBlessCastle.dwStartTime = dwPlayServTime;
	rsBlessCastle.TimeSec[0] = 0;
	rsBlessCastle.TimeSec[1] = 0;

	rsBlessCastle.dwScoreLogTime = dwPlayServTime+5*60*1000;		//로그 저장 시간

	if ( rsBlessCastleOpenLeauge.GameMode ) { //리그전
		rsBlessCastle.dwBattleOverTime = rsBlessCastleOpenLeauge.dwEndTime;	//남은 시간 설정
		rsBlessCastleOpenLeauge.dwRestartTime = 0;
	}


	//데미지 취합 장소
	if ( !rsBlessCastle.lpAttackDamageList )
		rsBlessCastle.lpAttackDamageList = new ATTACK_DAMAGE_LIST[ ATTACK_DAMAGE_LIST_MAX ];
	if ( rsBlessCastle.lpAttackDamageList )
		ZeroMemory( rsBlessCastle.lpAttackDamageList , sizeof(ATTACK_DAMAGE_LIST)*ATTACK_DAMAGE_LIST_MAX );


	if ( rsBlessCastle.dwMasterClan==0 ) {
		//성주 없음
		//용병설정 (최대)
		rsBlessCastle.BlessCastleSetup.MercenaryNum[0] = 20;
		rsBlessCastle.BlessCastleSetup.MercenaryNum[1] = 20;
		rsBlessCastle.BlessCastleSetup.MercenaryNum[2] = 20;
		rsBlessCastle.BlessCastleSetup.MercenaryNum[3] = 0;

		//타워 랜덤
		for(cnt=0;cnt<6;cnt++) {
			rsBlessCastle.BlessCastleSetup.Tower[cnt] = (rand()%3)+1;
		}
	}


	ZeroMemory( &rsBlessCastle.ClanTop10 , sizeof(rsUSER_LIST_TOP10) );

	//rsCASTLE_FIELD
	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag && chrAutoPlayer[cnt].lpExt1==lpStgArea ) {//&&
				//chrAutoPlayer[cnt].smCharInfo.State==smCHAR_STATE_ENEMY ) {

			//공성종료 몬스터 전멸
			chrAutoPlayer[cnt].Close();
			if ( lpStgArea->DeleteMonTable( &chrAutoPlayer[cnt] )==TRUE ) 
				lpStgArea->MonsterCount--;
		}
	}

	smCHAR_INFO	*lpChar_CastleDoor = 0;
	smCHAR_INFO	*lpChar_CastleTower_B = 0;
	smCHAR_INFO	*lpChar_CastleCrystal_R = 0;
	smCHAR_INFO	*lpChar_CastleCrystal_G = 0;
	smCHAR_INFO	*lpChar_CastleCrystal_B = 0;
	smCHAR_INFO	*lpChar_CastleCrystal_N = 0;
	smCHAR_INFO	*lpChar_CastleSolder_A = 0;
	smCHAR_INFO	*lpChar_CastleSolder_B = 0;
	smCHAR_INFO	*lpChar_CastleSolder_C = 0;
	smCHAR_INFO	*lpChar_SetTower = 0;

	for(cnt=0;cnt<chrMonsterCnt;cnt++) {
		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_DOOR ) {
			lpChar_CastleDoor = &chrMonsterList[cnt];		//성문
		}
		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_TOWER_B ) {
			lpChar_CastleTower_B = &chrMonsterList[cnt];		//발할라타워
		}
		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_R ) {
			lpChar_CastleCrystal_R = &chrMonsterList[cnt];		//크리스탈(레드)
		}
		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_G ) {
			lpChar_CastleCrystal_G = &chrMonsterList[cnt];		//크리스탈(그린)
		}
		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_B ) {
			lpChar_CastleCrystal_B = &chrMonsterList[cnt];		//크리스탈(불루)
		}
		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_CRYSTAL_N ) {
			lpChar_CastleCrystal_N = &chrMonsterList[cnt];		//크리스탈(노말)
		}

		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_SOLDER_A ) {
			lpChar_CastleSolder_A = &chrMonsterList[cnt];		//용병 A
		}
		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_SOLDER_B ) {
			lpChar_CastleSolder_B = &chrMonsterList[cnt];		//용병 B
		}
		if (chrMonsterList[cnt].dwCharSoundCode==snCHAR_SOUND_CASTLE_SOLDER_C ) {
			lpChar_CastleSolder_C = &chrMonsterList[cnt];		//용병 C
		}

	}


	if ( lpChar_CastleDoor ) {
		//성문설치
		rsOpenCastleFieldObject( lpStgArea , lpChar_CastleDoor , pCastle_Door.x*fONE, pCastle_Door.z*fONE, pCastle_Door.y*fONE );
	}
	if ( lpChar_CastleTower_B ) {
		//발할라탑 설치
		lpChar = rsOpenCastleFieldObject( lpStgArea , lpChar_CastleTower_B , pCastle_ValhallaTower.x*fONE, pCastle_ValhallaTower.z*fONE, pCastle_ValhallaTower.y*fONE );
/*
		if ( lpChar ) {		//클랜순위 설정용
			lpChar->lpAttackDamageList = new ATTACK_DAMAGE_LIST[ ATTACK_DAMAGE_LIST_MAX ];
			if ( lpChar->lpAttackDamageList )
				ZeroMemory( lpChar->lpAttackDamageList , sizeof(ATTACK_DAMAGE_LIST)*ATTACK_DAMAGE_LIST_MAX );
		}
*/
	}

	//크리스탈_레드 설치
	cnt = 0;
	while(1) 
	{ 
		if ( pCastle_CrystalTower[cnt].x==0 ) break;

		lpChar_SetTower = lpChar_CastleCrystal_N;

		switch( rsBlessCastle.BlessCastleSetup.Tower[cnt] ) {
			case SIN_GURAD_CRISTAL_ICE:
				lpChar_SetTower = lpChar_CastleCrystal_B;
				break;
			case SIN_GURAD_CRISTAL_LIGHTNING:
				lpChar_SetTower = lpChar_CastleCrystal_G;
				break;
			case SIN_GURAD_CRISTAL_FIRE:
				lpChar_SetTower = lpChar_CastleCrystal_R;
				break;
		}

		if ( lpChar_SetTower ) {
			lpChar = rsOpenCastleFieldObject( lpStgArea , lpChar_SetTower , pCastle_CrystalTower[cnt].x*fONE, pCastle_CrystalTower[cnt].z*fONE, pCastle_CrystalTower[cnt].y*fONE );
/*
			if ( lpChar && rsBlessCastle.lpAttackDamageList ) {
				lpChar->lpAttackDamageList_BlessCastle = rsBlessCastle.lpAttackDamageList;
			}
*/
		}
		cnt++;
	}

	for(cnt=0;cnt<3;cnt++) {
		if ( rsBlessCastle.BlessCastleSetup.MercenaryNum[cnt]>MERCENARY_SOLDER_MAX )	
			rsBlessCastle.BlessCastleSetup.MercenaryNum[cnt] = MERCENARY_SOLDER_MAX;
	}

	//용병 설치
	if ( lpChar_CastleSolder_A ) {
		for(cnt=0;cnt<rsBlessCastle.BlessCastleSetup.MercenaryNum[0];cnt++) {
			rsOpenCastleFieldObject( lpStgArea , lpChar_CastleSolder_A , PosMercenarySolder_A[cnt].x*fONE, PosMercenarySolder_A[cnt].z*fONE, PosMercenarySolder_A[cnt].y*fONE );
		}
	}
	//용병 설치
	if ( lpChar_CastleSolder_B ) {
		for(cnt=0;cnt<rsBlessCastle.BlessCastleSetup.MercenaryNum[1];cnt++) {
			rsOpenCastleFieldObject( lpStgArea , lpChar_CastleSolder_B , PosMercenarySolder_B[cnt].x*fONE, PosMercenarySolder_B[cnt].z*fONE, PosMercenarySolder_B[cnt].y*fONE );
		}
	}
	//용병 설치
	if ( lpChar_CastleSolder_C ) {
		for(cnt=0;cnt<rsBlessCastle.BlessCastleSetup.MercenaryNum[2];cnt++) {
			rsOpenCastleFieldObject( lpStgArea , lpChar_CastleSolder_C , PosMercenarySolder_C[cnt].x*fONE, PosMercenarySolder_C[cnt].z*fONE, PosMercenarySolder_C[cnt].y*fONE );
		}
	}

	//공지사항을 설정한다
	rsSetNoticeMessage( srBlessCastle_LeagueMsg_02 );		//공성전 시작 메세지

	return TRUE;
}

//공성모드 종료
int	rsEnd_CombatCastle( int DefenceFlag )
{
	int cnt;
	STG_AREA	*lpStgArea=&StageArea[rsCASTLE_FIELD];

	rsBlessCastle.CastleMode = 3;
	rsBlessCastle.dwBattleOverTime = dwPlayServTime+5000;		//5초후에 종료

	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag && chrAutoPlayer[cnt].lpExt1==lpStgArea && chrAutoPlayer[cnt].smCharInfo.State==smCHAR_STATE_ENEMY )
		{
			if ( DefenceFlag && chrAutoPlayer[cnt].smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_TOWER_B ) {
				//방어 성공
				chrAutoPlayer[cnt].smCharInfo.Life[0] = chrAutoPlayer[cnt].smCharInfo.Life[1];
				chrAutoPlayer[cnt].SetMotionFromCode(CHRMOTION_STATE_STAND);
			}
			else {
				//공성시작 몬스터 초기화
				chrAutoPlayer[cnt].smCharInfo.Life[0] = 0;
				chrAutoPlayer[cnt].SetMotionFromCode(CHRMOTION_STATE_DEAD);
			}
		}
	}

	//다시 재배치
	//NPC 재 설정
	for( cnt=0;cnt<FIX_CHAR_MAX;cnt++) {
		if ( lpStgArea->TransCharFixed[cnt].code )	
			lpStgArea->OpenNpc( &lpStgArea->TransCharFixed[cnt] );
	}


	return TRUE;
}

//공성모드 종료
int	rsEnd_CombatCastle()
{
	int cnt;
	STG_AREA	*lpStgArea=&StageArea[rsCASTLE_FIELD];

	rsBlessCastle.CastleMode = 0;
	rsBlessCastle.TimeSec[0] = 0;
	rsBlessCastle.TimeSec[1] = 0;

	//용병설정 초기화
	rsBlessCastle.BlessCastleSetup.MercenaryNum[0] = 0;
	rsBlessCastle.BlessCastleSetup.MercenaryNum[1] = 0;
	rsBlessCastle.BlessCastleSetup.MercenaryNum[2] = 0;
	rsBlessCastle.BlessCastleSetup.MercenaryNum[3] = 0;

	//short			Tower[12];		//타워설정	
	ZeroMemory( rsBlessCastle.BlessCastleSetup.Tower , sizeof(short)*12 );	//타워설정 초기화

	if ( rsBlessCastle.lpAttackDamageList ) {
		delete rsBlessCastle.lpAttackDamageList;
		rsBlessCastle.lpAttackDamageList = 0;
	}


	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag && chrAutoPlayer[cnt].lpExt1==lpStgArea ) {
			chrAutoPlayer[cnt].Close();
			if ( lpStgArea->DeleteMonTable( &chrAutoPlayer[cnt] )==TRUE ) {
				lpStgArea->MonsterCount--;
			}
		}
	}

	//NPC 재 설정
	for( cnt=0;cnt<FIX_CHAR_MAX;cnt++) {
		if ( lpStgArea->TransCharFixed[cnt].code )	
			lpStgArea->OpenNpc( &lpStgArea->TransCharFixed[cnt] );
	}

	rsSetNoticeMessage( srBlessCastle_LeagueMsg_03 ); //"공지> 공성전이 종료되었습니다. 참가해주신 모든 분들께 감사드립니다"; 

	if ( rsBlessCastleOpenLeauge.GameMode ) { //리그전
		rsBlessCastleOpenLeauge.dwRestartTime = dwPlayServTime + 1000*60*3;		//3분 여유
		if ( rsBlessCastleOpenLeauge.dwRestartTime>=rsBlessCastleOpenLeauge.dwEndTime ) {
			//게임 완전 종료
			rsBlessCastleOpenLeauge.GameMode = 0;
			rsBlessCastleOpenLeauge.dwEndTime = 0;
			rsBlessCastleOpenLeauge.dwRestartTime = 0;
		}
		else {
			rsSetNoticeMessage( srBlessCastle_LeagueMsg_01 );		//3분후 재시작 메세지
		}
	}

	return TRUE;
}


//공성모드 종료
int	rsEasy_CastleMode()
{
	int cnt;
	STG_AREA	*lpStgArea=&StageArea[rsCASTLE_FIELD];

	for(cnt=0;cnt<AUTOPLAYER_MAX;cnt++) {
		if ( chrAutoPlayer[cnt].Flag && chrAutoPlayer[cnt].lpExt1==lpStgArea && chrAutoPlayer[cnt].smCharInfo.State==smCHAR_STATE_ENEMY ) {
			//몬스터 피 1만 남도록
			chrAutoPlayer[cnt].sObject_VirtualLife[0] = 0;
			chrAutoPlayer[cnt].smCharInfo.Life[0] = 1;
		}
	}

	return TRUE;
}

//블레스 캐슬 정보 암호화 코드 생성
int rsCheck_BlessCastleClanSkill( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	DWORD Code;

#ifdef _W_SERVER
	Code = 0x0c3c5645;

	Code ^= lpTransCommand->WParam<<2;
	Code ^= lpTransCommand->LParam<<6;
	Code ^= lpTransCommand->SParam<<1;

	Code ^= lpPlayInfo->dwObjectSerial<<16;

#else
	Code = 0x3ea832ff;
#endif

	return Code&0x7FFFFFFF;
}



//블레스 캐슬 정보 암호화 코드 생성
int rsCheck_BlessCastleTax( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommandEx )
{
	DWORD Code;

#ifdef _W_SERVER
	Code = 0x056c3c45;

	Code ^= lpTransCommandEx->WParam<<1;
	Code ^= lpTransCommandEx->LParam<<2;
	Code ^= lpTransCommandEx->SParam<<3;
	Code ^= lpTransCommandEx->EParam<<4;

	Code ^= lpTransCommandEx->WxParam<<16;
	Code ^= lpTransCommandEx->LxParam<<17;
	Code ^= lpTransCommandEx->SxParam<<18;

	Code ^= lpPlayInfo->dwObjectSerial<<16;

#else
	Code = 0x3ea832ff;
#endif

	return Code&0x7FFFFFFF;
}

//블레스캐슬 정보 데이타 서버로 보내기
int	rsSendBlessCastleInfoToDataServer( rsPLAYINFO *lpPlayInfo )
{
#ifdef _W_SERVER

	smTRANS_COMMAND_EX	smTransCommand;

	smTransCommand.code = smTRANSCODE_BLESSCASTLE_TAX;
	smTransCommand.size = sizeof(smTRANS_COMMAND_EX);
	smTransCommand.WParam = (DWORD)rsBlessCastle.dwMasterClan^lpPlayInfo->dwObjectSerial^smTRANSCODE_BLESSCASTLE_TAX;
	smTransCommand.LParam = rsBlessCastle.Tax^smTransCommand.WParam;
	smTransCommand.SParam = rsBlessCastle.NextTax^smTransCommand.LParam;
	smTransCommand.EParam = ((rsBlessCastle.SelectedSkill<<16)|(rsBlessCastle.BlessCastleSetup.ClanSkill&0xFFFF))^smTransCommand.SParam;
	smTransCommand.WxParam = 0;
	smTransCommand.LxParam = 0;
	smTransCommand.SxParam = 0;
	smTransCommand.ExParam = rsCheck_BlessCastleTax( lpPlayInfo , &smTransCommand );

	if ( lpPlayInfo->lpsmSock )
		rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
#endif
	return TRUE;
}

/*
		rsBlessCastle.SelectedSkill = rsBlessCastle.BlessCastleSetup.ClanSkill;	//선택된 스킬 적용
#define SKILL_PLAY_BLESS_ABSORB			0xA0
#define SKILL_PLAY_BLESS_DAMAGE			0xA1
#define SKILL_PLAY_BLESS_EVADE			0xA2

#define SIN_CLANSKILL_HP				1
#define SIN_CLANSKILL_DAMAGE			2
#define SIN_CLANSKILL_DEFENCE			4
*/

//블레스캐슬 정보 게임서버로부터 받기
int	rsRecvBlessCastleInfoFromGameServer( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND_EX *lpTransCommand )
{
#ifdef _W_SERVER

	if ( rsCheck_BlessCastleTax( lpPlayInfo , lpTransCommand )==lpTransCommand->ExParam ) {
		lpTransCommand->EParam ^=lpTransCommand->SParam;
		lpTransCommand->SParam ^=lpTransCommand->LParam;
		lpTransCommand->LParam ^=lpTransCommand->WParam;
		lpTransCommand->WParam ^=lpPlayInfo->dwObjectSerial^smTRANSCODE_BLESSCASTLE_TAX;

		rsBlessCastle.BlessCastleSetup.ClanSkill = lpTransCommand->EParam&0xFFFF;
		//rsBlessCastle.SelectedSkill = lpTransCommand->EParam>>16;
		rsBlessCastle.SelectedSkill = rsBlessCastle.BlessCastleSetup.ClanSkill;
		rsBlessCastle.NextTax = lpTransCommand->SParam;
		rsBlessCastle.Tax = lpTransCommand->LParam;
		rsBlessCastle.dwMasterClan = (DWORD)lpTransCommand->WParam;
		//rsBlessCastle.CastleMode = 0;

		rsSaveCastleInfo();		//저장

		return TRUE;
	}
#endif

	return FALSE;
}



//블래스캐슬 설정정보 수신
int rsRecvBlessCastInfo( rsPLAYINFO *lpPlayInfo , void *lpPacket )
{
	smTRANS_BLESSCASTLE *lpBlessCastleSetup=(smTRANS_BLESSCASTLE *)lpPacket;
	smTRANS_COMMAND		smTransCommand;

	switch( lpBlessCastleSetup->smTransCommand.WParam ) {
		case 0:
			if ( lpBlessCastleSetup->smTransCommand.SParam!=rsBlessCastle.Tax ) {
				//블레스 캐슬 세율 받아오기
				smTransCommand.code = smTRANSCODE_BLESSCASTLE_TAX;
				smTransCommand.size = sizeof(smTRANS_COMMAND);
				smTransCommand.WParam = 0;
				smTransCommand.LParam = rsBlessCastle.dwMasterClan;
				smTransCommand.SParam = rsBlessCastle.Tax;
				smTransCommand.EParam = 0;

				lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand, smTransCommand.size , TRUE );
			}
			break;


		case 1:
			if ( lpPlayInfo->dwClanCode==rsBlessCastle.dwMasterClan || lpPlayInfo->AdminMode>3 ) {
				//if ( lpPlayInfo->Position.Area==rsCASTLE_FIELD )
				if ( StageArea[rsCASTLE_FIELD].dwActiveMode ) {
					memcpy( &rsBlessCastle.BlessCastleSetup , lpBlessCastleSetup , sizeof(smTRANS_BLESSCASTLE) );

					rsBlessCastle.NextTax = rsBlessCastle.BlessCastleSetup.TaxRate;		//다음 적용 세율
					rsSendBlessCastleInfoToDataServer( lpPlayInfo );
					rsSaveCastleInfo();		//저장

					//공성전 설정 변경 로그
					RecordBlessCastleSetup( lpPlayInfo , lpBlessCastleSetup );
				}

			}
			break;
	}

	return TRUE;
}



//블래스캐슬 설정정보 송신
int rsSendBlessCastInfo( rsPLAYINFO *lpPlayInfo , int Mode )
{
	smTRANS_BLESSCASTLE	smTransBlessCastle;

	memcpy( &smTransBlessCastle , &rsBlessCastle.BlessCastleSetup , sizeof(smTRANS_BLESSCASTLE) );

	smTransBlessCastle.smTransCommand.size = sizeof(smTRANS_BLESSCASTLE);
	smTransBlessCastle.smTransCommand.code = smTRANSCODE_BLESSCASTLE_INFO;
	smTransBlessCastle.smTransCommand.WParam = Mode;
	smTransBlessCastle.smTransCommand.LParam = 0;
	smTransBlessCastle.smTransCommand.SParam = 0;
	smTransBlessCastle.smTransCommand.EParam = 0;

	smTransBlessCastle.dwMasterClan = rsBlessCastle.dwMasterClan;
	smTransBlessCastle.Price = 0;

	switch( Mode ) {
		case 1:
			if ( lpPlayInfo->dwClanCode==rsBlessCastle.dwMasterClan || lpPlayInfo->AdminMode ) {
				if ( lpPlayInfo->lpsmSock )
					lpPlayInfo->lpsmSock->Send2( (char *)&smTransBlessCastle , smTransBlessCastle.smTransCommand.size , TRUE );
			}
			break;

	}

	return TRUE;
}



//데미지준 클랜 10명 선별
int	rsSelectDamageClanTop10( smCHAR *lpChar ,  rsUSER_LIST_TOP10 *lpUserListDamageTop10 )
{
	int cnt,cnt2;
	int ChkCnt;
	int	TotalDamage = 0;
	ATTACK_DAMAGE_LIST	AttackDamageList[ATTACK_DAMAGE_LIST_MAX];

	if ( !lpUserListDamageTop10 ) return FALSE;

	ZeroMemory( lpUserListDamageTop10 , sizeof(rsUSER_LIST_TOP10) );

	if ( lpChar->lpAttackDamageList ) {
		memcpy( AttackDamageList , lpChar->lpAttackDamageList , sizeof(ATTACK_DAMAGE_LIST)*ATTACK_DAMAGE_LIST_MAX );
	}
	else if ( rsBlessCastle.lpAttackDamageList ) {
		memcpy( AttackDamageList , rsBlessCastle.lpAttackDamageList , sizeof(ATTACK_DAMAGE_LIST)*ATTACK_DAMAGE_LIST_MAX );
	}
	else
		return FALSE;

	for(cnt2=0;cnt2<ATTACK_DAMAGE_LIST_MAX;cnt2++ ) {
		TotalDamage+=AttackDamageList[cnt2].DamageCount;
	}

	for( cnt=0;cnt<10;cnt++ ) {
		ChkCnt = -1;
		for(cnt2=0;cnt2<ATTACK_DAMAGE_LIST_MAX;cnt2++ ) {
			if ( AttackDamageList[cnt2].dwUserCode && GetClanCode(AttackDamageList[cnt2].dwUserCode)!=rsBlessCastle.dwMasterClan &&
				AttackDamageList[cnt2].DamageCount>lpUserListDamageTop10->Damage[cnt] ) {

					lpUserListDamageTop10->dwUserCode[cnt]	= AttackDamageList[cnt2].dwUserCode;
					lpUserListDamageTop10->Damage[cnt]		= AttackDamageList[cnt2].DamageCount;
					lpUserListDamageTop10->Counter[cnt]		= AttackDamageList[cnt2].Count;

					ChkCnt = cnt2;
				}
		}

		if ( ChkCnt>=0 )
			AttackDamageList[ChkCnt].dwUserCode = 0;
	}

	//크리스탈 타워 남은수
	((DWORD *)lpUserListDamageTop10->bCrystalTowerCount)[0] = ((DWORD *)rsBlessCastle.bCrystalTowerCount)[0];

	lpUserListDamageTop10->dwUpdateTime = dwPlayServTime;
	lpUserListDamageTop10->dwCharCode = lpChar->dwObjectSerial;

	lpUserListDamageTop10->code = smTRANSCODE_BLESSCASTLE_INFO;
	lpUserListDamageTop10->size = sizeof(rsUSER_LIST_TOP10);
	lpUserListDamageTop10->tCode = rsServerConfig.ServerCode;											//순위
	lpUserListDamageTop10->dwObjectSerial = 2	;//rsServerConfig.ServerCode;
	lpUserListDamageTop10->dwTotalDamage = TotalDamage;


	//공성전 점수 로그 남기기
	if ( rsBlessCastle.dwScoreLogTime && rsBlessCastle.dwScoreLogTime<dwPlayServTime ) {
		rsBlessCastle.dwScoreLogTime = dwPlayServTime+5*60*1000;		//5분후에 다시

		RecordBlessCastleLog( lpUserListDamageTop10 );
	}

	return TRUE;
}

//영혼의 샘터
int	rsBlessCastle_SoulFountainMain()
{
	int cnt,mcnt,last;
	rsPLAYINFO *lpPlayInfo;
	TRANS_CHATMESSAGE	TransChatMessage;

	if ( !rsBlessCastle.dwMasterClan || rsBlessCastle.CastleMode )
		return FALSE;

	if ( rsBlessCastle.dwSoulFountainTime<dwPlayServTime ) {		//물약 생성
		rsBlessCastle.dwSoulFountainTime = dwPlayServTime+60*1000;
		if ( rsBlessCastle.SoulFountain_PotionCount<1440 )
			rsBlessCastle.SoulFountain_PotionCount++;
	}

	if ( !rsBlessCastle.SoulFountain_PotionCount || rsBlessCastle.dwSoulFountainTime2>dwPlayServTime ) return FALSE;

	rsBlessCastle.dwSoulFountainTime2 = dwPlayServTime+1000;

	last = rsBlessCastle.SoulFountain_LastUserCount+CONNECTMAX;

	for(cnt=rsBlessCastle.SoulFountain_LastUserCount+1;cnt<=last;cnt++) {
		mcnt = cnt & CONNECTMAX_MASK;
		lpPlayInfo = &rsPlayInfo[mcnt];
		if ( lpPlayInfo->lpsmSock && lpPlayInfo->dwObjectSerial && lpPlayInfo->Position.Area==rsCASTLE_FIELD ) {
			if ( rsBlessCastle.SoulFountain_PotionCount>0 && lpPlayInfo->dwClanCode &&
				lpPlayInfo->dwClanCode==rsBlessCastle.dwMasterClan &&
				lpPlayInfo->Position.x>CastleSoulFountain_Area[0] &&
				lpPlayInfo->Position.x<CastleSoulFountain_Area[1] &&
				lpPlayInfo->Position.z>CastleSoulFountain_Area[2] &&
				lpPlayInfo->Position.z<CastleSoulFountain_Area[3] )
			{

				//지역서버 경우
				if ( dwSerToSerIP )
					rsPutItemToSystemLine( lpPlayInfo , (sinPM1|sin04) );
				else	//돈을 유저에게 직접 보낸다
					rsPutItem( lpPlayInfo , (sinPM1|sin04) );

				rsBlessCastle.SoulFountain_PotionCount--;

				wsprintf( TransChatMessage.szMessage , srMsg_038 , lpPlayInfo->smCharInfo.szName , rsBlessCastle.SoulFountain_PotionCount );
				TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;//lpPlayInfo->dwObjectSerial;

				rsSendCommandUser2( lpPlayInfo , (smTRANS_COMMAND *)&TransChatMessage );

				rsBlessCastle.SoulFountain_LastUserCount = mcnt;
				break;
			}

		}
	}


	return TRUE;
}

//블레스캐슬 스킬 적용
int rsSendBlessCastleClanSkill( rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND smTransCommand;

	if ( lpPlayInfo->dwClanCode && lpPlayInfo->dwClanCode==rsBlessCastle.dwMasterClan ) {

		if ( !lpPlayInfo->SucessCheck_ClanCode ) {
			bClan_GetClanMarkCode( lpPlayInfo );			//클랜서버에 클랜 코드 확인 작업
		}

		if ( !lpPlayInfo->CastleMaster.Flag ) {
			lpPlayInfo->CastleMaster.dwCheckTime = 0;
			lpPlayInfo->CastleMaster.SelectSkill = rsBlessCastle.SelectedSkill;
			lpPlayInfo->CastleMaster.Flag = TRUE;
		}

		if ( lpPlayInfo->CastleMaster.dwCheckTime<dwPlayServTime ) {
			//블레스 캐슬 마스터
			smTransCommand.code = smTRANSCODE_PROCESS_CLAN_SKILL;
			smTransCommand.size = sizeof(smTRANS_COMMAND);
			smTransCommand.WParam = rsBlessCastle.SelectedSkill;
			smTransCommand.LParam = lpPlayInfo->dwClanCode;
			smTransCommand.SParam = 0;
			smTransCommand.EParam = rsCheck_BlessCastleClanSkill( lpPlayInfo , &smTransCommand );
			lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

			lpPlayInfo->CastleMaster.dwCheckTime = dwPlayServTime+1000*60;		//다음 적용 대기 시간
		}
		return TRUE;
	}
	return FALSE;
}


//클랜 코드 구하기
DWORD GetClanCode( int ClassClanCode )
{
	DWORD	dwCode,dwCode1,dwCode2;

	dwCode = ClassClanCode%1000000;
	dwCode1 = ClassClanCode/100000000;
	dwCode2 = dwCode1*100000000;

	return dwCode+dwCode2;
}

//블레스캐슬 저장
int	rsSaveCastleInfo()
{
#ifdef _W_SERVER
	FILE *fp;

	if ( !StageArea[rsCASTLE_FIELD].dwActiveMode && !UseDLL_Code ) 
		return FALSE;

	fp = fopen( "BlessCastle.dat" , "wb" );
	if ( fp ) {
		fwrite( &rsBlessCastle , sizeof(rsBLESS_CASTLE) , 1 , fp );
		fclose( fp );
		return TRUE;
	}
#endif
	return FALSE;
}

//블레스 캐슬 로딩
int rsLoadCastleInfo()
{
#ifdef _W_SERVER
	if ( !StageArea[rsCASTLE_FIELD].dwActiveMode && !UseDLL_Code ) 
		return FALSE;

	FILE *fp;
	fp = fopen( "BlessCastle.dat" , "rb" );
	if ( fp ) {
		fread( &rsBlessCastle , sizeof(rsBLESS_CASTLE) , 1 , fp );
		fclose( fp );
		return TRUE;
	}
#endif
	return FALSE;
}

/*
		//공성전 발생 아이템(스크롤)
		{sinBC1|sin01 ,"무적스크롤"     ,"BC101",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC101",0,SIN_SOUND_Armlet},
		{sinBC1|sin02 ,"크리티컬 스크롤","BC102",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC101",0,SIN_SOUND_Armlet},
		{sinBC1|sin03 ,"추가회피 스크롤","BC103",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC101",0,SIN_SOUND_Armlet},
		{sinBC1|sin04 ,"파티원 전원회복 스크롤","BC104",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC101",0,SIN_SOUND_Armlet},
		{sinBC1|sin05 ,"부활 스크롤","BC105",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC101",0,SIN_SOUND_Armlet},
		
		{sinBC1|sin06 ,"파이어 크리스탈 저항석"  ,"BC106",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin07 ,"아이스 크리스탈 저항석 " ,"BC107",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin08 ,"라이트닝 크리스탈 저항석","BC108",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin09 ,"대파이터   공격력 강화석","BC109",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin10 ,"대메카니션 공격력 강화석","BC110",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin11 ,"대파이크맨 공격력 강화석","BC111",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin12 ,"대 이쳐 공격력 강화석"   ,"BC112",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin13 ,"대 나이트 공격력 강화석" ,"BC113",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin14 ,"대아틀란타 공격력 강화석","BC114",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin15 ,"대 메지션 공격력 강화석" ,"BC115",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
		{sinBC1|sin16 ,"대프리스티스 공격력 강화석" ,"BC116",ITEMSIZE*2,ITEMSIZE*2,"Event",ITEM_CLASS_ECORE,"BC102",0,SIN_SOUND_SHELTOM},
*/

//공성 아이템 사용 결과 통보
int rsSiegeItemSucess( rsPLAYINFO *lpPlayInfo , DWORD dwItemCode )
{

	smTRANS_COMMAND	smTransCommand;

	smTransCommand.code = smTRANSCODE_PROCESS_SKILL2;
	smTransCommand.size = sizeof(smTRANS_COMMAND);
	smTransCommand.WParam = SKILL_PLAY_BLESS_SIEGE_ITEM;
	smTransCommand.LParam = lpPlayInfo->dwObjectSerial;
	smTransCommand.SParam = dwItemCode;
	smTransCommand.EParam = 0;
	lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );

	return TRUE;
}

//공성 아이템 사용
int	rsOpenSiegeCastleItem( DWORD dwItemCode , int x, int y, int z , rsPLAYINFO *lpPlayInfo )
{
	smTRANS_COMMAND	smTransCommand;

	switch( dwItemCode ) {
	case (sinBI1|sin05):	//무적스크롤
		lpPlayInfo->dwSiegeItem_Scroll_Time		= dwPlayServTime + 30*1000;
		lpPlayInfo->dwSiegeItem_Scroll_Code		= dwItemCode;
		lpPlayInfo->dwSiegeItem_Scroll_Param	= 2;			//공격력 /2
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBI1|sin06):	//크리티컬 스크롤
		lpPlayInfo->dwSiegeItem_Scroll_Time		= dwPlayServTime + 60*60*1000; //30*1000;		// pluto 페이틀 에지 1시간으로 수정
		lpPlayInfo->dwSiegeItem_Scroll_Code		= dwItemCode;
		lpPlayInfo->dwSiegeItem_Scroll_Param	= 15;			//크리티컬 +5%	// pluto 페이틀 에지
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBI1|sin07):	//추가 회피 스크롤
		lpPlayInfo->dwSiegeItem_Scroll_Time		= dwPlayServTime + 60*60*1000; //30*1000;		// pluto 어버트 스크롤 1시간으로 수정
		lpPlayInfo->dwSiegeItem_Scroll_Code		= dwItemCode;
		lpPlayInfo->dwSiegeItem_Scroll_Param	= 15;							// pluto 어버트 스크롤
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBI1|sin09 ):	//얼큰이 물약
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.code = smTRANSCODE_COMIC_SKIN;
		smTransCommand.WParam = (rand()%2)+1;
		smTransCommand.LParam = 60*10;
		smTransCommand.SParam = 0;
		smTransCommand.EParam = 0;
		lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
		return TRUE;


	case (sinBI1|sin19 ):	//뱀피릭커스핏
		//lpPlayInfo->dwTime_PrimeItem_VampCuspid		= dwPlayServTime+60*5*1000;	//5분
		return TRUE;
	case (sinBI1|sin20 ):	//뱀피릭커스핏
		//lpPlayInfo->dwTime_PrimeItem_VampCuspid		= dwPlayServTime+60*10*1000;	//10분
		return TRUE;

	case (sinBI1|sin21 ):	//마나리차징
		//lpPlayInfo->dwTime_PrimeItem_ManaRecharg	= dwPlayServTime+60*5*1000;	//5분
		return TRUE;
	case (sinBI1|sin22 ):	//마나리차징
		//lpPlayInfo->dwTime_PrimeItem_ManaRecharg	= dwPlayServTime+60*10*1000;	//10분
		return TRUE;


	case (sinBI1|sin12 ):	//써드 아이스
	case (sinBI1|sin13 ):	//경험치 증가

	case (sinBI1|sin14 ):	//써드 아이스
	case (sinBI1|sin15 ):	//경험치 증가

		return TRUE;
	}


	if ( lpPlayInfo->Position.Area!=rsCASTLE_FIELD )
		return FALSE;

	switch( dwItemCode ) {
	case (sinBC1|sin01):	//무적스크롤
		lpPlayInfo->dwSiegeItem_Scroll_Time		= dwPlayServTime + 30*1000;
		lpPlayInfo->dwSiegeItem_Scroll_Code		= dwItemCode;
		lpPlayInfo->dwSiegeItem_Scroll_Param	= 2;			//공격력 /2
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin02):	//크리티컬 스크롤
		lpPlayInfo->dwSiegeItem_Scroll_Time		= dwPlayServTime + 30*1000;
		lpPlayInfo->dwSiegeItem_Scroll_Code		= dwItemCode;
		lpPlayInfo->dwSiegeItem_Scroll_Param	= 5;			//크리티컬 +5%
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin03):	//추가 회피 스크롤
		lpPlayInfo->dwSiegeItem_Scroll_Time		= dwPlayServTime + 30*1000;
		lpPlayInfo->dwSiegeItem_Scroll_Code		= dwItemCode;
		lpPlayInfo->dwSiegeItem_Scroll_Param	= 5;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin04):	//파티원 전원 회복
	case (sinBC1|sin05):	//부활 스크롤
		return FALSE;



	case (sinBC1|sin06):	//파이어 크리스탈 저항석
		lpPlayInfo->dwSiegeItem_Stone1_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone1_Code		= snCHAR_SOUND_CASTLE_CRYSTAL_R;
		lpPlayInfo->dwSiegeItem_Stone1_Param	= 50;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin07):	//아이스 크리스탈 저항석
		lpPlayInfo->dwSiegeItem_Stone1_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone1_Code		= snCHAR_SOUND_CASTLE_CRYSTAL_B;
		lpPlayInfo->dwSiegeItem_Stone1_Param	= 50;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin08):	//라이트닝 크리스탈 저항석
		lpPlayInfo->dwSiegeItem_Stone1_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone1_Code		= snCHAR_SOUND_CASTLE_CRYSTAL_G;
		lpPlayInfo->dwSiegeItem_Stone1_Param		= 50;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin09):	//대 파이터 공격력 강화석
		lpPlayInfo->dwSiegeItem_Stone2_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone2_Code		= JOBCODE_FIGHTER;
		lpPlayInfo->dwSiegeItem_Stone2_Param	= 20;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin10):	//대 메카니션 공격력 강화석
		lpPlayInfo->dwSiegeItem_Stone2_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone2_Code		= JOBCODE_MECHANICIAN;
		lpPlayInfo->dwSiegeItem_Stone2_Param	= 20;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin11):	//대파이크맨 공격력 강화석
		lpPlayInfo->dwSiegeItem_Stone2_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone2_Code		= JOBCODE_PIKEMAN;
		lpPlayInfo->dwSiegeItem_Stone2_Param	= 20;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin12):	//대 이쳐 공격력 강화석
		lpPlayInfo->dwSiegeItem_Stone2_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone2_Code		= JOBCODE_ARCHER;
		lpPlayInfo->dwSiegeItem_Stone2_Param	= 20;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin13):	//대 나이트 공격력 강화석
		lpPlayInfo->dwSiegeItem_Stone2_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone2_Code		= JOBCODE_KNIGHT;
		lpPlayInfo->dwSiegeItem_Stone2_Param	= 20;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin14):	//대 아탈란타 공격력 강화석
		lpPlayInfo->dwSiegeItem_Stone2_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone2_Code		= JOBCODE_ATALANTA;
		lpPlayInfo->dwSiegeItem_Stone2_Param	= 20;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin15):	//대 메지션 공격력 강화석
		lpPlayInfo->dwSiegeItem_Stone2_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone2_Code		= JOBCODE_MAGICIAN;
		lpPlayInfo->dwSiegeItem_Stone2_Param	= 20;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	case (sinBC1|sin16):	//대 프리스티스 공격력 강화석
		lpPlayInfo->dwSiegeItem_Stone2_Time		= dwPlayServTime + 60*1000;
		lpPlayInfo->dwSiegeItem_Stone2_Code		= JOBCODE_PRIESTESS;
		lpPlayInfo->dwSiegeItem_Stone2_Param	= 20;
		rsSiegeItemSucess( lpPlayInfo , dwItemCode );
		return TRUE;

	}

	return TRUE;
}


//공성전 점수 로그
int RecordBlessCastleLog( rsUSER_LIST_TOP10 *lpUserListDamageTop10 )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];
	char	szBuff2[4096];
	int cnt;

	GetLocalTime( &st );
	wsprintf( szFileName , filenameBlessCaslte , HackLogDirectory , st.wMonth , st.wDay );


	wsprintf( szBuff2, "=================== Check Time [ %d:%d:%d ] =====================\r\n" ,
		st.wHour, st.wMinute , st.wSecond );


	for(cnt=0;cnt<10;cnt++) {

		wsprintf( szBuff, "%d> ClanCode[%d] Damage:%d Count:%d \r\n" ,
			cnt+1 ,
			lpUserListDamageTop10->dwUserCode[cnt] ,
			lpUserListDamageTop10->Damage[cnt] ,
			lpUserListDamageTop10->Damage[cnt] ,
			lpUserListDamageTop10->Counter[cnt] );

		lstrcat( szBuff2 , szBuff );

	}

	wsprintf( szBuff, "* Tower Crystal ( %d %d %d %d )\r\n" , 
		lpUserListDamageTop10->bCrystalTowerCount[0],
		lpUserListDamageTop10->bCrystalTowerCount[1],
		lpUserListDamageTop10->bCrystalTowerCount[2],
		lpUserListDamageTop10->bCrystalTowerCount[3] );

	lstrcat( szBuff2 , szBuff );


	if ( rsBlessCastle.lpChar_ValhallaTower && rsBlessCastle.lpChar_ValhallaTower->Flag && rsBlessCastle.lpChar_ValhallaTower->smCharInfo.dwCharSoundCode==snCHAR_SOUND_CASTLE_TOWER_B ) {
		wsprintf( szBuff, "* ValhallaTower ( %d:%d )/( %d/%d )\r\n" , 
			rsBlessCastle.lpChar_ValhallaTower->smMonsterInfo.PotionCount , 
			rsBlessCastle.lpChar_ValhallaTower->smCharInfo.Life[0],

			rsBlessCastle.lpChar_ValhallaTower->sObject_DisplayLife[0],
			rsBlessCastle.lpChar_ValhallaTower->sObject_DisplayLife[1] );

		lstrcat( szBuff2 , szBuff );
	}


	CreateDirectory( DebugLogDirectory , NULL );			//디렉토리 생성

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff2 , lstrlen(szBuff2) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}

//공성전 설정 변경 로그
int RecordBlessCastleSetup( rsPLAYINFO *lpPlayInfo , smTRANS_BLESSCASTLE *lpBlessCastleSetup )
{
	HANDLE	hFile;
	DWORD	dwAcess;
	DWORD	FileLength;
	SYSTEMTIME	st;
	char	szFileName[128];
	char	szBuff[256];
	char	szBuff2[4096];

	GetLocalTime( &st );
	wsprintf( szFileName , filenameBlessCaslte , HackLogDirectory , st.wMonth , st.wDay );

	wsprintf( szBuff , "%d:%d:%d - Name(%s)/IP(%s) MasterClan(%d) Price(%d)\r\n" ,
		st.wHour , st.wMinute , st.wSecond ,
		lpPlayInfo->smCharInfo.szName , lpPlayInfo->lpsmSock->szIPAddr ,
		rsBlessCastle.dwMasterClan , lpBlessCastleSetup->Price );

	wsprintf( szBuff2 , "%s=> TaxRate(%d) Tower(%d %d %d %d %d %d) Mercenary(%d %d %d) ClanSkill(%d)\r\n\r\n", szBuff ,
		lpBlessCastleSetup->TaxRate ,
		lpBlessCastleSetup->Tower[0] , lpBlessCastleSetup->Tower[1] , lpBlessCastleSetup->Tower[2] ,
		lpBlessCastleSetup->Tower[3] , lpBlessCastleSetup->Tower[4] , lpBlessCastleSetup->Tower[5] ,
		lpBlessCastleSetup->MercenaryNum[0] , lpBlessCastleSetup->MercenaryNum[1] , lpBlessCastleSetup->MercenaryNum[2] ,
		lpBlessCastleSetup->ClanSkill );


	CreateDirectory( DebugLogDirectory , NULL );			//디렉토리 생성

	hFile = CreateFile( szFileName , GENERIC_WRITE , FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
	if ( hFile==INVALID_HANDLE_VALUE ) return FALSE;

	FileLength = GetFileSize( hFile , NULL );
	SetFilePointer( hFile , FileLength , NULL , FILE_BEGIN );
	WriteFile( hFile , szBuff2 , lstrlen(szBuff2) , &dwAcess , NULL );
	CloseHandle( hFile );

	return TRUE;
}


//잘못된 필드 처리
int rsFault_PlayField( rsPLAYINFO *lpPlayInfo , int height )
{
	smTRANS_COMMAND_EX	smTransCommandEx;

	lpPlayInfo->sCheckPlayField_Count[1]++;		//오류난 횟수 증가

	if ( lpPlayInfo->WarningCount<10 && lpPlayInfo->sCheckPlayField_Count[1]>=3 ) {

		smTransCommandEx.size = sizeof(smTRANS_COMMAND_EX);
		smTransCommandEx.code = smTRANSCODE_SET_BLACKLIST;
		smTransCommandEx.WParam = 8860;
		smTransCommandEx.LParam = lpPlayInfo->Position.x/fONE;
		smTransCommandEx.SParam = lpPlayInfo->Position.y/fONE;
		smTransCommandEx.EParam = lpPlayInfo->Position.z/fONE;
		smTransCommandEx.WxParam = lpPlayInfo->Position.Area;
		smTransCommandEx.LxParam = height/fONE;
		smTransCommandEx.SxParam = 0;
		smTransCommandEx.ExParam = 0;

		rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommandEx );
		lpPlayInfo->WarningCount++;

		lpPlayInfo->sCheckPlayField_Count[1] = 0;
	}

	return TRUE;
}

//현재 플레이어의 필드 바닥위치 확인
int rsCheckPlayField( rsPLAYINFO *lpPlayInfo )
{

	if ( !rsServerConfig.CheckPlayField ) return TRUE;			//지형검사 서버 옵션

	lpPlayInfo->sCheckPlayField_Count[0]++;

	if ( (lpPlayInfo->sCheckPlayField_Count[0]&0xF)!=0 ) return FALSE;	//  1/16회 확인

	//if ( lpPlayInfo->AdminMode ) return FALSE;			//관리자 테스트용

	if ( lpPlayInfo->Position.Area>STAGE_AREA_MAX || lpPlayInfo->Position.Area<0 ) {
		rsFault_PlayField( lpPlayInfo , 0 );
		return FALSE;
	}

	STG_AREA	*lpStgArea = &StageArea[lpPlayInfo->Position.Area];
	smSTAGE3D	*lpStage = lpStgArea->lpStage;
	int	height;
	int heCnt;

	if ( !lpStage ) {
		rsFault_PlayField( lpPlayInfo , 0 );
		return FALSE;
	}
/*
    height = lpStage->GetFloorHeight( lpPlayInfo->Position.x ,lpPlayInfo->Position.y , lpPlayInfo->Position.z , 48*fONE );

	if ( abs( height-lpPlayInfo->Position.y )>8*fONE ) {
		rsFault_PlayField( lpPlayInfo , height );
		return FALSE;
	}
*/
	height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x ,lpPlayInfo->Position.y , lpPlayInfo->Position.z , 10*fONE );
	if ( height>0 ) {
		heCnt = 0;
		height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x + 4*fONE ,lpPlayInfo->Position.y + 4*fONE , lpPlayInfo->Position.z , 10*fONE );
		if ( height>0 ) heCnt++;
		height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x + 4*fONE ,lpPlayInfo->Position.y - 4*fONE , lpPlayInfo->Position.z , 10*fONE );
		if ( height>0 ) heCnt++;
		height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x - 4*fONE ,lpPlayInfo->Position.y + 4*fONE , lpPlayInfo->Position.z , 10*fONE );
		if ( height>0 ) heCnt++;
		height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x - 4*fONE ,lpPlayInfo->Position.y - 4*fONE , lpPlayInfo->Position.z , 10*fONE );
		if ( height>0 ) heCnt++;

		height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x + 0*fONE ,lpPlayInfo->Position.y + 2*fONE , lpPlayInfo->Position.z , 10*fONE );
		if ( height>0 ) heCnt++;
		height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x + 0*fONE ,lpPlayInfo->Position.y - 2*fONE , lpPlayInfo->Position.z , 10*fONE );
		if ( height>0 ) heCnt++;
		height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x + 2*fONE ,lpPlayInfo->Position.y + 0*fONE , lpPlayInfo->Position.z , 10*fONE );
		if ( height>0 ) heCnt++;
		height = lpStage->CheckFloorFaceHeight( lpPlayInfo->Position.x - 2*fONE ,lpPlayInfo->Position.y - 0*fONE , lpPlayInfo->Position.z , 10*fONE );
		if ( height>0 ) heCnt++;

		if ( heCnt>=8 ) {
			rsFault_PlayField( lpPlayInfo , height );
			return FALSE;
		}
	}

	lpPlayInfo->sCheckPlayField_Count[1] = 0;

	return TRUE;
}

#define PRESENTITEM_LEVEL_MAX		4

#include "AutoDropItem.h"


//저 레벨용 아이템 우연히 자동 생성하기
DWORD rsLowLevelItem( rsPLAYINFO *lpPlayInfo , smCHAR *lpChar )
{
	int rnd;
	int lev,job;
	int SelCnt;

	if ( !lpPlayInfo->sLowLevel_PresentItem[0] || lpPlayInfo->sLowLevel_PresentItem[0]>=PRESENTITEM_LEVEL_MAX ) return NULL;

	if ( abs(lpPlayInfo->smCharInfo.Level-lpChar->smCharInfo.Level)>8 ) return NULL;	//레벨차이 8 이상
	job = lpPlayInfo->smCharInfo.JOB_CODE-1;
	if ( job<0 || job>=8 ) return NULL;

	if ( lpPlayInfo->dwCode_Name&1 )
		lev = rsPresentItem_LevelType_1[job][lpPlayInfo->sLowLevel_PresentItem[0]][0];
	else
		lev = rsPresentItem_LevelType_2[job][lpPlayInfo->sLowLevel_PresentItem[0]][0];

	if ( lpPlayInfo->smCharInfo.Level<lev ) return NULL;								//선물레벨 확인

	rnd = (lpPlayInfo->smCharInfo.Level-lev+1)*5;

	if ( (rand()%1000)<rnd ) {

		SelCnt = lpPlayInfo->sLowLevel_PresentItem[0];

		lpPlayInfo->sLowLevel_PresentItem[0]++;											//저레벨용 선물 발생

		//군서버에 업데이트 정보 보냄
		rsUpdateServerParam( lpPlayInfo , smUPDATE_PARAM_LOWUSER_PRESENT , lpPlayInfo->sLowLevel_PresentItem[0] , lpPlayInfo->sLowLevel_PresentItem[1] , TRUE );

		if ( lpPlayInfo->smCharInfo.Level<(lev+10) ) {

#ifdef _TEST_SERVER
			TRANS_CHATMESSAGE TransChatMessage;

			if ( lpPlayInfo->AdminMode ) {
				wsprintf( TransChatMessage.szMessage , "필연적 아이템 과의 만남( %d )" , SelCnt );
				TransChatMessage.code = smTRANSCODE_CHATMESSAGE;
				TransChatMessage.dwIP = 0;
				TransChatMessage.dwObjectSerial = 0;
				TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);

				lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
			}
#endif

			if ( lpPlayInfo->dwCode_Name&1 )
				return rsPresentItem_LevelType_1[job][SelCnt][1];
			else
				return rsPresentItem_LevelType_2[job][SelCnt][1];
		}
	}

	return NULL;
}

//다른서버에서의 업데이트
int rsRecvUpdateServerParam( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{

	switch( lpTransCommand->WParam ) {
		case smUPDATE_PARAM_LOWUSER_PRESENT:
			lpPlayInfo->sLowLevel_PresentItem[0] = lpTransCommand->LParam;
			lpPlayInfo->sLowLevel_PresentItem[1] = lpTransCommand->SParam;
			break;
	}

	return TRUE;
}

//군섭에 업데이트 정보 보냄
int	rsUpdateServerParam( rsPLAYINFO *lpPlayInfo , DWORD dwUpdateCode , int Param1 , int Param2 , int TargetMode )
{
	smTRANS_COMMAND	smTransCommand;

	smTransCommand.size = sizeof ( smTRANS_COMMAND );
	smTransCommand.code = smTRANSCODE_UPDATE_SERVER_PARAM;
	smTransCommand.WParam = dwUpdateCode;
	smTransCommand.LParam = Param1;
	smTransCommand.SParam = Param2;
	smTransCommand.EParam = rsServerConfig.ServerCode;

	if ( lpPlayInfo->lpsmSock ) {
		if ( TargetMode )
			return rsSendDataServer( lpPlayInfo->lpsmSock , &smTransCommand );
		else
			return rsSendGameServer( lpPlayInfo->lpsmSock , &smTransCommand );
	}

	return NULL;
}


//처음시작 유저 아이템 지급
int rsStartUser_PresentItem( rsPLAYINFO *lpPlayInfo )
{
	TRANS_CHATMESSAGE TransChatMessage;
	sDEF_ITEMINFO *lpDefItem = 0;

	switch( lpPlayInfo->dwStartUser_PresentItem_Count ) {
		case 1:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ARCHER ) 
				lpDefItem = rsPutItem3( lpPlayInfo , (sinWS1|sin01) );	//아쳐 활
			else if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_ATALANTA ) 
				lpDefItem = rsPutItem3( lpPlayInfo , (sinWT1|sin01) );	//아탈 던지는창
			else if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MAGICIAN ) 
				lpDefItem = rsPutItem3( lpPlayInfo , (sinWM1|sin01) );	//매지션 요술지팡이
			else if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PRIESTESS ) 
				lpDefItem = rsPutItem3( lpPlayInfo , (sinWM1|sin01) );	//프리스티스 요술지팡이
			else {
				//그외 전사 직업 무기들
				switch( rand()%3 ) 
				{
				case 0:
					lpDefItem = rsPutItem3( lpPlayInfo , (sinWS2|sin01) );
					break;
				case 1:
					lpDefItem = rsPutItem3( lpPlayInfo , (sinWA1|sin01) );
					break;
				case 2:
					lpDefItem = rsPutItem3( lpPlayInfo , (sinWH1|sin01) );
					break;
				}
			}
			break;
		case 2:
			if ( lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_MAGICIAN || lpPlayInfo->smCharInfo.JOB_CODE==JOBCODE_PRIESTESS )
				lpDefItem = rsPutItem3( lpPlayInfo , (sinDA2|sin02) );
			else
				lpDefItem = rsPutItem3( lpPlayInfo , (sinDA1|sin02) );
			break;
//해외
		case 3:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinGP1|sin01) );
			break;
		case 4:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinGP1|sin01) );
			break;
		case 5:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinGP1|sin01) );
			break;
#ifdef _LANGUAGE_PHILIPIN	//(해외)
		case 6:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPL1|sin02) );
			break;
		case 7:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPL1|sin02) );
			break;
		case 8:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPL1|sin02) );
			break;
		case 9:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPL1|sin02) );
			break;
		case 10:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPL1|sin02) );
			break;
		case 11:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPS1|sin02) );
			break;
		case 12:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPS1|sin02) );
			break;
		case 13:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPS1|sin02) );
			break;
		case 14:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPS1|sin02) );
			break;
		case 15:
			lpDefItem = rsPutItem3( lpPlayInfo , (sinPS1|sin02) );
			break;
#endif
	}


	if ( lpDefItem ) {
		wsprintf( TransChatMessage.szMessage , srMsg_StartUser_PresentItem , lpDefItem->Item.ItemName );
		TransChatMessage.code = smTRANSCODE_MESSAGEBOX;
		TransChatMessage.dwIP = 0;
		TransChatMessage.dwObjectSerial = 0;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);

		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );

		smTRANS_COMMAND	smTransCommand;
		smTransCommand.code = smTRANSCODE_NOTICE_BOX;
		smTransCommand.size = sizeof(smTRANS_COMMAND);
		smTransCommand.WParam = lpDefItem->Item.CODE;
		smTransCommand.LParam = 0;
		smTransCommand.SParam = 0;
		smTransCommand.EParam = 0;
		lpPlayInfo->lpsmSock->Send2( (char *)&smTransCommand , smTransCommand.size , TRUE );
	}

	lpPlayInfo->dwStartUser_PresentItem_Count++;
#ifndef _LANGUAGE_PHILIPIN
	lpPlayInfo->dwStartUser_PresentItem_Time = dwPlayServTime+1000*60*1;		//일단 1 분후에 다시 준다
#else 
	lpPlayInfo->dwStartUser_PresentItem_Time = dwPlayServTime+1000*3*1;		//일단 1 분후에 다시 준다
#endif

	return TRUE;
}

////////////////////////// 베트남 경험치 시간분배 /////////////////////////////
int rsSendUserID_MainServer( rsPLAYINFO *lpPlayInfo )
{

	smTRANS_CHAR_COMMAND2	smTransCharCommand;

	smTransCharCommand.code = smTRANSCODE_USER_ID;
	smTransCharCommand.size = sizeof(smTRANS_CHAR_COMMAND2);
	smTransCharCommand.WParam = 0;
	smTransCharCommand.LParam = 0;
	smTransCharCommand.SParam = 0;

	lstrcpy( smTransCharCommand.szId , lpPlayInfo->szID );
	lstrcpy( smTransCharCommand.szName , lpPlayInfo->szName );

	return rsSendGameServer( lpPlayInfo->lpsmSock , &smTransCharCommand );
}

int rsRecvUserID_MainServer( rsPLAYINFO *lpPlayInfo , smTRANS_CHAR_COMMAND2 *lpTransCharCommand )
{
	lstrcpy( lpPlayInfo->szUserExpTimeID , lpTransCharCommand->szId );
	lstrcpy( lpPlayInfo->szUserExpTimeName , lpTransCharCommand->szName );

	if ( lpPlayInfo->dwExpGameTimeCheck==0 )
		bSql_GetExpGameTime( lpPlayInfo , 0 );

	return TRUE;
}

int rsGetExp_GameTime( rsPLAYINFO *lpPlayInfo )
{

	int gTime = lpPlayInfo->dwExpGameTime/(1000*60*60);

	if ( lpPlayInfo->dwExpGameTimeCheck ) 
	{
		if ( gTime<3 ) 
		{
			return 100;
		}
		else if ( gTime<5 ) 
		{
			return 50;
		}
		return 0;
	}

	return 100;
}

int rsDispay_GameTime( rsPLAYINFO *lpPlayInfo , DWORD dwTimeOld )//해외
{

	int gTime = lpPlayInfo->dwExpGameTime/(1000*60);
	int gTimeOld = dwTimeOld/(1000*60);
	bool	bDisplay = true;
	int	Remainder = 0;
	int	OldRemainder =0;
	TRANS_CHATMESSAGE	TransChatMessage;
	memset(&TransChatMessage,0,sizeof(TRANS_CHATMESSAGE));

	
	//----[ a. 3시간 미만 ]
	if ( gTime>=1*60 && gTimeOld<1*60 ) 
	{//1시간째
		wsprintf( TransChatMessage.szMessage , MSG_TL_1_00 ); 
	}
	else if ( gTime>=2*60 && gTimeOld<2*60 ) 
	{//2시간째
		wsprintf( TransChatMessage.szMessage , MSG_TL_2_00 ); 
	}
	//----[ b. 3시간 초과 ~ 5시간 미만 ]
	else if ( gTime>=3*60 && gTimeOld<3*60 ) 
	{//3시간째
		wsprintf( TransChatMessage.szMessage , MSG_TL_3_00 ); 
	}
	else if ( gTime>=(3*60+30) && gTimeOld<(3*60+30) ) 
	{//3시간30분째
		wsprintf( TransChatMessage.szMessage , MSG_TL_3_30 ); 
	}
	else if ( gTime>=4*60 && gTimeOld<4*60 ) 
	{//4시간째
		wsprintf( TransChatMessage.szMessage , MSG_TL_4_00 ); 
	}
	else if ( gTime>=(4*60+30) && gTimeOld<(4*60+30) ) 
	{//4시간30분째
		wsprintf( TransChatMessage.szMessage , MSG_TL_4_30 ); 
	}
	//----[ c. 5시간 초과 ]
	else if ( gTime>=5*60  ) 
	{
		Remainder = gTime % 60; // 분을 찾는다
		OldRemainder = gTimeOld % 60;

		wsprintf( TransChatMessage.szMessage , MSG_TL_X_00 ); 

		if( OldRemainder<15 && Remainder>=15 )
		{//15분
		}
		else if( OldRemainder<30 && Remainder>=30 )
		{//30분
		}
		else if( OldRemainder<45 && Remainder>=45 )
		{//45분
		}
		else if( OldRemainder > Remainder )
		{//00분
		}
		else
		{
			bDisplay = false;
		}
	}
	
	else
	{
		bDisplay = false;
	}
	

	if( bDisplay == true )
	{
		TransChatMessage.code = smTRANSCODE_WHISPERMESSAGE;
		TransChatMessage.size = 32+lstrlen(TransChatMessage.szMessage);
		TransChatMessage.dwIP = 3;
		TransChatMessage.dwObjectSerial = 0;
		lpPlayInfo->lpsmSock->Send( (char *)&TransChatMessage , TransChatMessage.size , TRUE );
	}

	return 0;
}


#include "HackTrap.h"

//해킹용 함정
int rsRecvHackTrap(rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCharCommand )
{
	smTRANS_COMMAND		smTransCommand;

	switch( lpTransCharCommand->WParam ) 
	{
	case 100:		//필드와 NPC기능 클릭 확인
		//lpTransCharCommand->SParam		필드번호
		if ( (rsHackTrap_FieldNPC[lpTransCharCommand->SParam]&lpTransCharCommand->LParam)==0 ) {
			//기능불가 필드에서 수행 (로그기록)
			if ( lpPlayInfo->WarningCount<20 || rsServerConfig.TestSeverMode ) {		//테섭은 무한기록 , 그외는 20개로 제한 (로그파일생성제한)
				smTransCommand.WParam = 8900;
				smTransCommand.LParam = lpTransCharCommand->SParam;
				smTransCommand.SParam = lpTransCharCommand->LParam;
				RecordHackLogFile( lpPlayInfo , &smTransCommand );
			}
		}
		break;

	}

	return TRUE;
}

#ifdef _CHECK_MESH
//아이템메쉬 조작검사 결과값 수신
static DWORD	dwItemMeshCode = 0;
int rsRecvCheckItemMesh( rsPLAYINFO *lpPlayInfo , smTRANS_COMMAND *lpTransCommand )
{
	smTRANS_COMMAND		smTransCommand;

	if ( !dwItemMeshCode ) {
		dwItemMeshCode = lpTransCommand->WParam;
		return TRUE;
	}

	if ( dwItemMeshCode!=lpTransCommand->WParam ) {
		//코드가 틀리면 로그에 기록후 1분후에 접속 끈어버린다 
		smTransCommand.WParam = 8910;
		smTransCommand.LParam = dwItemMeshCode;
		smTransCommand.SParam = lpTransCommand->WParam;
		RecordHackLogFile( lpPlayInfo , &smTransCommand );

		lpPlayInfo->dwHopeDisconnectTime = dwPlayServTime+60*1000;
	}

	return TRUE;
}
#endif
// pluto 제작 룬 검사
DWORD ManufactureCheckRune( DWORD RecipeCode, DWORD *pRuneCode )
{
	/*
	int RecipeIndex = -1;
	if( RecipeCode >= sin01 && RecipeCode <= sin08 )
	{
		RecipeIndex = OLD_RECIPE;
	}
	else if( RecipeCode >= sin11 && RecipeCode <= sin18 )
	{
		RecipeIndex = DISCOLORED_RECIPE;
	}
	else if( RecipeCode >= sin21 && RecipeCode <= sin28 )
	{
		RecipeIndex = ANCIENT_RECIPE;
	}
	else if( RecipeCode >= sin31 && RecipeCode <= sin38 )
	{
		RecipeIndex = DISMAL_RECIPE;
	}

	for( int i = 0; i < MAX_RECIPE_KIND; i++ )
	{
		if( RecipeIndex == RuneFormula[i].Recipe )
		{
			for( int j = 0; j < 3; j++ )
			{
				if( RuneCode == RuneFormula[i].Rune[j] )
				{
					return TRUE;
				}
			}
		}
	}
	*/

	int RuneCnt = 0;
	DWORD Arm_Armor_Code[9] = { sin01, sin02, sin03, sin04, sin05, sin06, sin07, sin08, sin09 }; // 레시피 종류
	DWORD CheckRuneCode[9][8][3] = { {	{ (sinPR3|sin01), (sinPR3|sin02), (sinPR3|sin03) },  // 룬 조합식이다
										{ (sinPR3|sin01), (sinPR3|sin02), (sinPR4|sin03) },
										{ (sinPR3|sin01), (sinPR4|sin02), (sinPR3|sin03) },
										{ (sinPR3|sin01), (sinPR4|sin02), (sinPR4|sin03) },
										{ (sinPR4|sin01), (sinPR3|sin02), (sinPR3|sin03) },
										{ (sinPR4|sin01), (sinPR3|sin02), (sinPR4|sin03) },
										{ (sinPR4|sin01), (sinPR4|sin02), (sinPR3|sin03) },
										{ (sinPR4|sin01), (sinPR4|sin02), (sinPR4|sin03) } },
										////////////////////////////////////////////////////////////////////////////////////////////	잊혀진 레시피
									 {  { (sinPR3|sin02), (sinPR3|sin03), (sinPR3|sin04) },
										{ (sinPR3|sin02), (sinPR3|sin03), (sinPR4|sin04) },
										{ (sinPR3|sin02), (sinPR4|sin03), (sinPR3|sin04) },
										{ (sinPR3|sin02), (sinPR4|sin03), (sinPR4|sin04) },
										{ (sinPR4|sin02), (sinPR3|sin03), (sinPR3|sin04) },
										{ (sinPR4|sin02), (sinPR3|sin03), (sinPR4|sin04) },
										{ (sinPR4|sin02), (sinPR4|sin03), (sinPR3|sin04) },
										{ (sinPR4|sin02), (sinPR4|sin03), (sinPR4|sin04) } },
										////////////////////////////////////////////////////////////////////////////////////////////	고대의 레시피
									 {  { (sinPR3|sin03), (sinPR3|sin04), (sinPR3|sin05) },
										{ (sinPR3|sin03), (sinPR3|sin04), (sinPR4|sin05) },
										{ (sinPR3|sin03), (sinPR4|sin04), (sinPR3|sin05) },
										{ (sinPR3|sin03), (sinPR4|sin04), (sinPR4|sin05) },
										{ (sinPR4|sin03), (sinPR3|sin04), (sinPR3|sin05) },
										{ (sinPR4|sin03), (sinPR3|sin04), (sinPR4|sin05) },
										{ (sinPR4|sin03), (sinPR4|sin04), (sinPR3|sin05) },
										{ (sinPR4|sin03), (sinPR4|sin04), (sinPR4|sin05) } },
										////////////////////////////////////////////////////////////////////////////////////////////	대지의 레시피
									 {  { (sinPR3|sin03), (sinPR3|sin04), (sinPR3|sin05) },
										{ (sinPR3|sin03), (sinPR3|sin04), (sinPR4|sin05) },
										{ (sinPR3|sin03), (sinPR4|sin04), (sinPR3|sin05) },
										{ (sinPR3|sin03), (sinPR4|sin04), (sinPR4|sin05) },
										{ (sinPR4|sin03), (sinPR3|sin04), (sinPR3|sin05) },
										{ (sinPR4|sin03), (sinPR3|sin04), (sinPR4|sin05) },
										{ (sinPR4|sin03), (sinPR4|sin04), (sinPR3|sin05) },
										{ (sinPR4|sin03), (sinPR4|sin04), (sinPR4|sin05) } },
										////////////////////////////////////////////////////////////////////////////////////////////	어둠의 레시피
									{	{ (sinPR3|sin03), (sinPR3|sin04), (sinPR3|sin05) },  
										{ (sinPR3|sin03), (sinPR3|sin04), (sinPR4|sin05) },
										{ (sinPR3|sin03), (sinPR4|sin04), (sinPR3|sin05) },
										{ (sinPR3|sin03), (sinPR4|sin04), (sinPR4|sin05) },
										{ (sinPR4|sin03), (sinPR3|sin04), (sinPR3|sin05) },
										{ (sinPR4|sin03), (sinPR3|sin04), (sinPR4|sin05) },
										{ (sinPR4|sin03), (sinPR4|sin04), (sinPR3|sin05) },
										{ (sinPR4|sin03), (sinPR4|sin04), (sinPR4|sin05) } },
										////////////////////////////////////////////////////////////////////////////////////////////	화염의 레시피
									{  { (sinPR3|sin03), (sinPR3|sin04), (sinPR3|sin05) },
										{ (sinPR3|sin03), (sinPR3|sin04), (sinPR4|sin05) },
										{ (sinPR3|sin03), (sinPR4|sin04), (sinPR3|sin05) },
										{ (sinPR3|sin03), (sinPR4|sin04), (sinPR4|sin05) },
										{ (sinPR4|sin03), (sinPR3|sin04), (sinPR3|sin05) },
										{ (sinPR4|sin03), (sinPR3|sin04), (sinPR4|sin05) },
										{ (sinPR4|sin03), (sinPR4|sin04), (sinPR3|sin05) },
										{ (sinPR4|sin03), (sinPR4|sin04), (sinPR4|sin05) } },
										////////////////////////////////////////////////////////////////////////////////////////////	바람의 레시피
									{  { (sinPR3|sin04), (sinPR3|sin05), (sinPR3|sin06) },
										{ (sinPR3|sin04), (sinPR3|sin05), (sinPR4|sin06) },
										{ (sinPR3|sin04), (sinPR4|sin05), (sinPR3|sin06) },
										{ (sinPR3|sin04), (sinPR4|sin05), (sinPR4|sin06) },
										{ (sinPR4|sin04), (sinPR3|sin05), (sinPR3|sin06) },
										{ (sinPR4|sin04), (sinPR3|sin05), (sinPR4|sin06) },
										{ (sinPR4|sin04), (sinPR4|sin05), (sinPR3|sin06) },
										{ (sinPR4|sin04), (sinPR4|sin05), (sinPR4|sin06) } },
										////////////////////////////////////////////////////////////////////////////////////////////	태양의 레시피
									{  { (sinPR3|sin05), (sinPR3|sin06), (sinPR3|sin07) },
										{ (sinPR3|sin05), (sinPR3|sin06), (sinPR4|sin07) },
										{ (sinPR3|sin05), (sinPR4|sin06), (sinPR3|sin07) },
										{ (sinPR3|sin05), (sinPR4|sin06), (sinPR4|sin07) },
										{ (sinPR4|sin05), (sinPR3|sin06), (sinPR3|sin07) },
										{ (sinPR4|sin05), (sinPR3|sin06), (sinPR4|sin07) },
										{ (sinPR4|sin05), (sinPR4|sin06), (sinPR3|sin07) },
										{ (sinPR4|sin05), (sinPR4|sin06), (sinPR4|sin07) } },
										////////////////////////////////////////////////////////////////////////////////////////////	광포한 레시피
									{  { (sinPR3|sin06), (sinPR3|sin07), (sinPR3|sin08) },
										{ (sinPR3|sin06), (sinPR3|sin07), (sinPR4|sin08) },
										{ (sinPR3|sin06), (sinPR4|sin07), (sinPR3|sin08) },
										{ (sinPR3|sin06), (sinPR4|sin07), (sinPR4|sin08) },
										{ (sinPR4|sin06), (sinPR3|sin07), (sinPR3|sin08) },
										{ (sinPR4|sin06), (sinPR3|sin07), (sinPR4|sin08) },
										{ (sinPR4|sin06), (sinPR4|sin07), (sinPR3|sin08) },
										{ (sinPR4|sin06), (sinPR4|sin07), (sinPR4|sin08) } }
										////////////////////////////////////////////////////////////////////////////////////////////	천상의 레시피
	};

	// 레시피와 룬조합에 맞는 발생 아이템
	DWORD CreateItemCode[2][9][8] = {	{	{ (sinWA1|sin14), (sinWC1|sin14), (sinWH1|sin15), (sinWP1|sin15), (sinWS1|sin16), (sinWS2|sin17), (sinWT1|sin15), (sinWM1|sin15) }, // 잊혀진 레시피 무구
											{ (sinWA1|sin15), (sinWC1|sin15), (sinWH1|sin16), (sinWP1|sin16), (sinWS1|sin17), (sinWS2|sin18), (sinWT1|sin16), (sinWM1|sin16) }, // 고대의 레시피 무구
											{ (sinWA1|sin16), (sinWC1|sin16), (sinWH1|sin17), (sinWP1|sin17), (sinWS1|sin18), (sinWS2|sin19), (sinWT1|sin17), (sinWM1|sin17) }, // 대지의 무구
											{ (sinWA1|sin17), (sinWC1|sin17), (sinWH1|sin18), (sinWP1|sin18), (sinWS1|sin19), (sinWS2|sin20), (sinWT1|sin18), (sinWM1|sin18) }, // 어둠의 레시피 무구
											{ (sinWA1|sin18), (sinWC1|sin18), (sinWH1|sin19), (sinWP1|sin19), (sinWS1|sin20), (sinWS2|sin21), (sinWT1|sin19), (sinWM1|sin19) }, // 화염의 레시피 무구
											{ (sinWA1|sin19), (sinWC1|sin19), (sinWH1|sin20), (sinWP1|sin20), (sinWS1|sin21), (sinWS2|sin22), (sinWT1|sin20), (sinWM1|sin20) }, // 바람의 레시피 무구
											{ (sinWA1|sin21), (sinWC1|sin21), (sinWH1|sin22), (sinWP1|sin22), (sinWS1|sin23), (sinWS2|sin24), (sinWT1|sin22), (sinWM1|sin22) }, // 태양의 레시피 무구
											{ (sinWA1|sin22), (sinWC1|sin22), (sinWH1|sin23), (sinWP1|sin23), (sinWS1|sin24), (sinWS2|sin25), (sinWT1|sin23), (sinWM1|sin23) }, // 광포한 레시피 무구
											{ 0, 0, 0, 0, 0, 0, 0, 0 } }, // 천상의 레시피 무구
											//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										{	{ (sinDA1|sin16), (sinDA2|sin16), (sinDS1|sin14), (sinOM1|sin15), (sinDG1|sin14), (sinOA2|sin14), (sinDB1|sin14), 0 }, // 잊혀진 레시피 갑주
											{ (sinDA1|sin17), (sinDA2|sin17), (sinDS1|sin15), (sinOM1|sin16), (sinDG1|sin15), (sinOA2|sin15), (sinDB1|sin15), 0 }, // 고대의 레시피 갑주
											{ (sinDA1|sin18), (sinDA2|sin18), (sinDS1|sin16), (sinOM1|sin17), (sinDG1|sin16), (sinOA2|sin16), (sinDB1|sin16), 0 }, // 대지의 레시피 갑주
											{ (sinDA1|sin19), (sinDA2|sin19), (sinDS1|sin17), (sinOM1|sin18), (sinDG1|sin17), (sinOA2|sin17), (sinDB1|sin17), 0 }, // 어둠의 레시피 갑주
											{ (sinDA1|sin20), (sinDA2|sin20), (sinDS1|sin18), (sinOM1|sin19), (sinDG1|sin18), (sinOA2|sin18), (sinDB1|sin18), 0 }, // 화염의 레시피 갑주
											{ (sinDA1|sin21), (sinDA2|sin21), (sinDS1|sin19), (sinOM1|sin20), (sinDG1|sin19), (sinOA2|sin19), (sinDB1|sin19), 0 }, // 바람의 레시피 갑주
											{ (sinDA1|sin23), (sinDA2|sin23), (sinDS1|sin21), (sinOM1|sin22), (sinDG1|sin21), (sinOA2|sin21), (sinDB1|sin21), 0 }, // 태양의 레시피 갑주
											{ (sinDA1|sin24), (sinDA2|sin24), (sinDS1|sin22), (sinOM1|sin23), (sinDG1|sin22), (sinOA2|sin22), (sinDB1|sin22), 0 }, // 광포한 레시피 갑주
											{ 0, 0, 0, 0, 0, 0, 0, 0 } } // 천상의 레시피 갑주
	};
	if( (RecipeCode & sinITEM_MASK2) == sinWR1 )		// 무구
	{
		for( int i = 0; i < MAX_RECIPE_KIND; i++ )
		{
			if( Arm_Armor_Code[i] == (RecipeCode & sinITEM_MASK3) )
			{
				for( int j = 0; j < MAX_RUNE; j++ )   // 룬 조합 
				{
					RuneCnt = 0;
					for( int x = 0; x < 3; x++ ) // 필요한 룬
					{
						for( int y = 0; y < 3; y++ )
						{
							if( CheckRuneCode[i][j][x] == pRuneCode[y+1] )
							{
								RuneCnt++;
								break;
							}
						}
						if( RuneCnt == 3 )
						{
							return CreateItemCode[0][i][j];
						}
					}
				}
			}
		}
	}
	else if( (RecipeCode & sinITEM_MASK2) == sinDR1 )		// 갑주
	{
		for( int i = 0; i < MAX_RECIPE_KIND; i++ )
		{
			if( Arm_Armor_Code[i] == (RecipeCode & sinITEM_MASK3) )
			{
				for( int j = 0; j < MAX_RUNE; j++ )
				{
					RuneCnt = 0;
					for( int x = 0; x < 3; x++ )
					{
						for( int y = 0; y < 3; y++ )
						{
							if( CheckRuneCode[i][j][x] == pRuneCode[y+1] )
							{
								RuneCnt++;
								break;
							}
						}
						if( RuneCnt == 3 )
						{
							if( j == 7 )
							{
								int ArmorRand = 0;
								ArmorRand = rand() % 7;
								return CreateItemCode[1][i][ArmorRand];
							}
							return CreateItemCode[1][i][j];
						}
					}
				}
			}
		}
	}
	return FALSE;
}


// pluto 선물상자
int rsPutItem_TreasureBox( rsPLAYINFO *lpPlayInfo, DWORD Code)
{
	TRANS_ITEMINFO	TransItemInfo;
	psITEM	psItem;
	int cnt;
	int nClass = 0;
	int Randum[6][8] =
	{
		{ 2000, 2900, 1000, 1500, 1000, 100, 750, 750 },
		{ 2600, 2620, 700, 1000, 1500, 80, 750, 750 },
		{ 2750, 2400, 800, 1500, 1000, 50, 750, 750 },
		{ 2450, 2850, 500, 1500, 1000, 200, 750, 750 },
		{ 2320, 2000, 1500, 1500, 1000, 180, 750, 750 },
		{ 2850, 2000, 1000, 1500, 1000, 150, 750, 750 }
	};

	switch( (Code & sinITEM_MASK3) )
	{
		case sin05:
			nClass = 0;
			break;
		case sin06:
			nClass = 1;
			break;
		case sin07:
			nClass = 2;
			break;
		case sin08:
			nClass = 3;
			break;
		case sin09:
			nClass = 4;
			break;
		case sin10:
			nClass = 5;
			break;
	}

	int CodeCount = 0;
	int RndNum = rand()%10000;
	int RndCnt = 0;
	for( cnt = 0; cnt < 8; cnt++ )
	{
		if( Randum[nClass][CodeCount] )
		{
			RndCnt += Randum[nClass][cnt];
			if( RndNum < RndCnt )
			{
				CodeCount = cnt;
				break;
			}
		}
	}

	DWORD ItemCode[6][8] =
	{
		{ (sinPM1|sin04), (sinBI1|sin08), (sinGP1|sin19), (sinFO1|sin08),(sinFO1|sin08), (sinBI2|sin09), (sinBI1|sin21), (sinBI1|sin19) },	// pluto 1등급
		{ (sinPM1|sin04), (sinBI1|sin08), (sinGP1|sin19), (sinFO1|sin08),(sinFO1|sin07), (sinBI2|sin09), (sinBI1|sin21), (sinBI1|sin19) },	// pluto 2등급
		{ (sinPM1|sin04), (sinBI1|sin08), (sinGP1|sin18), (sinFO1|sin07),(sinFO1|sin06), (sinBI2|sin09), (sinBI1|sin21), (sinBI1|sin19) },	// pluto 3등급
		{ (sinPM1|sin03), (sinBI1|sin08), (sinGP1|sin18), (sinFO1|sin06),(sinFO1|sin05), (sinBI2|sin05), (sinBI1|sin21), (sinBI1|sin19) },	// pluto 4등급
		{ (sinPM1|sin03), (sinBI1|sin08), (sinGP1|sin17), (sinFO1|sin04),(sinFO1|sin04), (sinBI2|sin05), (sinBI1|sin21), (sinBI1|sin19) },	// pluto 5등급
		{ (sinPM1|sin02), (sinBI1|sin08), (sinGP1|sin17), (sinFO1|sin04),(sinFO1|sin04), (sinBI2|sin05), (sinBI1|sin21), (sinBI1|sin19) }	// pluto 6등급
	};
	if((Code & sinITEM_MASK2) == sinSP1 )
	{

		for(int j=0 ; j < DefaultItemCount ; j++)
		{ 

			if( ItemCode[nClass][CodeCount] == DefaultItems[j].Item.CODE )
			{	
				CreateDefItem( &psItem.ItemInfo , &DefaultItems[j] );
				if( CodeCount == 0 )
				{
					psItem.ItemInfo.PotionCount = 10;
				}
				if ( lpPlayInfo->lpsmSock )
				{
					TransItemInfo.code = smTRANSCODE_PUTITEM;
					TransItemInfo.size = sizeof(TRANS_ITEMINFO);
					memcpy( &TransItemInfo.Item , &psItem.ItemInfo , sizeof( sITEMINFO ) );
					//TransItemInfo.Item.Price = Price;
					ReformItem( &TransItemInfo.Item );
					rsRegist_ItemSecCode( lpPlayInfo , &TransItemInfo , 1 );//아이템 정보송수신 구조체에 보안코드 삽입 ( 컴파일시 서버에서만 존재 )
					lpPlayInfo->lpsmSock->Send2( (char *)&TransItemInfo , TransItemInfo.size , TRUE );
				}
				return TRUE;
			}
		}
	}
	return TRUE;
}